/*
 *  This software may only be used by you under license from AT&T Corp.
 *  ("AT&T").  A copy of AT&T's Source Code Agreement is available at
 *  AT&T's Internet website having the URL:
 *
 *    <http://www.research.att.com/sw/tools/yoix/license/source.html>
 *
 *  If you received this software without first entering into a license
 *  with AT&T, you have an infringing copy of this software and cannot
 *  use it without violating AT&T's intellectual property rights.
 */

//
// XML grammar written for WebGain's JavaCC parser generator (Version 1.1).
// Also seems to work with Version 2.0, but we haven't done much testing as
// of 09/10/01.
//
// This implementation attempts to follow almost exactly the XML grammar
// as specified in this document:
//
//    Extensible Markup Language (XML) 1.0 (Second Edition)
//    W3C Recommendation 6 October 2000
//    http://www.w3.org/TR/2000/REC-xml-20001006
//
// though it is not a fully validating parser.  It makes a reasonable
// attempt to load replacement text for external (URI) entities.
// Text replacement for internal entities is performed completely, however.
// The feeling is that what is here is reasonably sufficient.
//
// If an ExternalID reference cannot be found, it will be silently ignored
// since any error triggered downstream by it not being found can easily
// be traced to its cause.
//
// The known differences (currently all intentional) between this parser
// and the above document are:
//
//    1. Keywords are case insensitive.
//    2. Attribute values (in an element) that contain only the
//	 characters [A-Za-z0-9_.:,-] need not be quoted.
//

options {
    DEBUG_PARSER = false;
    DEBUG_TOKEN_MANAGER = false;
    DEBUG_LOOKAHEAD = false;
    FORCE_LA_CHECK = false;

    STATIC = false;
    NODE_USES_PARSER = true;

    //
    // Need our own CharStream class for better control when we switch
    // input streams, so these are no longer optional.
    //
    USER_CHAR_STREAM = true;
    JAVA_UNICODE_ESCAPE = false;
}

PARSER_BEGIN(XMLParser)

package att.research.yoix;
import java.io.*;
import java.util.*;

class XMLParser

{

    private YoixParserStream  parserstream = null;
    private boolean           addtags = false;
    private String            docbase = null;
    private String            doctype_name = null;
    private String            dtd_text = null;

    private final YoixVM  VM = YoixConstants.VM;
    private final String  NL = YoixConstants.NL;
    private final String  SYNTAXERROR = YoixConstantsErrorName.SYNTAXERROR;
    private final String  INTERNALERROR = YoixConstantsErrorName.INTERNALERROR;
    private final int     YOIX_EOF = YoixConstants.YOIX_EOF;

    ///////////////////////////////////
    //
    // Private Methods
    //
    ///////////////////////////////////

    private YoixObject
    abort(String error) {

	return(abort(error, null));
    }


    private YoixObject
    abort(String error, ParseException e) {

	ArrayList  args = new ArrayList();
	String     token;
	String     expected;
	String     sep;
	Token      tok;
	int        line;
	int        column;
	int        m;
	int        n;

	//
	// Wanted better control over parser error messages, primarily
	// for consistency, so this routine is now a slightly modified
	// version of ParseException.getMessage(). Change JavaCC and
	// you may have to do some work here as well.
	//

	token_source.inError = true;

	if (e != null && e.currentToken != null) {
	    line = e.currentToken.next.beginLine;
	    column = e.currentToken.next.beginColumn;
	    args.add("Encountered");
	    token = "\"";
	    sep = "";
	    for (tok = e.currentToken.next; tok != null; tok = tok.next) {
		if (tok.kind == 0) {
		    token += sep + tokenImage[0];
		    break;
		} else token += sep + e.add_escapes(tok.image);
		sep = " ";
	    }
	    token += "\"";
	    args.add(token);
	    args.add(NL);
	    expected = NL + "    Parser was looking for one of the following tokens:" + NL;
	    for (n = 0; n < e.expectedTokenSequences.length; n++) {
		sep = "\t";
		for (m = 0; m < e.expectedTokenSequences[n].length; m++) {
		    expected += sep + e.tokenImage[e.expectedTokenSequences[n][m]];
		    sep = " ";
		}
		if (m > 0) {
		    if (e.expectedTokenSequences[n][m - 1] != 0)
			expected += sep + "...";
		    expected += NL;
		}
	    }
	    args.add(expected);
	} else {		// should be unnecessary - later
	    if (e != null)
		args.add(e.getMessage());
	    line = parserstream.getBeginLine();
	    column = parserstream.getBeginColumn();
	}

	VM.pushTag(line, column, parserstream.getName());
	return(VM.abort(error, args, e));
    }


    private void
    buildComment(SimpleNode node, Token tok) {

	node.value = new Object[] {tok != null ? tok.image : ""};
	buildDocument(node, _COMMENT);
    }


    private void
    buildCDSect(SimpleNode node, Token tok) {

	int  index;

	//
	// Right now this method won't be called when there's no "]]>" in
	// tok.image, but we decided to leave the tests in anyway.
	//
	// NOTE - we've definitely introduced overhead because each CDATA
	// section has to consume the entire XML file. We eventually will
	// investigate to see if there's a better approach.
	//

	if (tok != null && tok.image != null) {
	    if ((index = tok.image.indexOf("]]>")) >= 0) {
		parserstream.backup(tok.image.length() - index - 3);
		tok.image = tok.image.substring(0, index);
		buildDocument(node, _CDSECT, tok);
	    } else jjtree.popNode();
	} else jjtree.popNode();
    }


    private void
    buildCharData(SimpleNode node, Token tok) {

	int  index;

	if (tok != null && tok.image != null) {
	    if ((index = tok.image.indexOf("]]>")) >= 0) {
		if (index > 0) {
		    parserstream.backup(tok.image.length() - index);
		    tok.image = tok.image.substring(0, index);
		    buildDocument(node, _CHARDATA, tok);
		} else jjtree.popNode();
	    } else buildDocument(node, _CHARDATA, tok);
	} else buildDocument(node, _CHARDATA, tok);
    }


    private void
    buildDocument(SimpleNode node, int type) {

	node.setType(type);

	switch(type) {
	    case _ATTLIST_DECL:
	    case _BLOCK:
	    case _BODY:
	    case _CDSECT:
	    case _COMMENT:
	    case _CONTENT:
	    case _CONTENT_SPEC:
	    case _DEFAULT_DECL:
	    case _DTD:
	    case _ELEMENT_DECL:
	    case _ENTITY_DECL:
	    case _EXTERNAL_ID:
	    case _NOBLOCK:
	    case _NOTATION_DECL:
	    case _PROC_INST:
	    case _PROLOG:
	    case _XML:
	    case _XML_DECL:
		tagTop();
		break;
	}
    }


    private void
    buildDocument(SimpleNode node, int type, Token tok) {

	if (tok != null)
	    node.value = new Object[] {tok.image};
	buildDocument(node, type);
    }


    private YoixObject
    die(String error) {

	return(VM.die(error));
    }


    private void
    restore() {

	if (parserstream != null) {
	    parserstream = parserstream.getParent();
	    ReInit(parserstream);
	}
    }


    private void
    reset(YoixParserStream stream, boolean tags) {

	stream.setParent(parserstream);
	parserstream = stream;
	ReInit(parserstream);

	addtags = tags;
	docbase = null;
	doctype_name = null;
	dtd_text = null;

	token_source.SwitchTo(DEFAULT);
	token_source.clearStack();
	token_source.clearRef();
	token_source.inDTD = false;
	token_source.inError = false;
    }


    private void
    tagTop() {

	SimpleNode  node;
	String      source;
	int         line;
	int         column;

	if (addtags) {
	    node = (SimpleNode)jjtree.peekNode();
	    line = (token != null) ? token.beginLine : parserstream.getBeginLine();
	    column = (token != null) ? token.beginColumn : parserstream.getBeginColumn();
	    source = parserstream.getName();
	    if (node.value[0] instanceof SimpleNode) {
		node.jjtInsertChild(YoixObject.newTag(line, column, source), 0);
	    } else {
		Object val = node.value[0];
		node.value[0] = YoixObject.newTag(line, column, source);
		node.jjtAppendChild(new SimpleNode(_SELF, val));
	    }
	}
    }
}

PARSER_END(XMLParser)

// ================================================================

TOKEN_MGR_DECLS:
{
    private Hashtable  peRef = null;
    private Hashtable  geRef = null;
    private Stack      storedState = new Stack();
    boolean            inDTD = false;
    boolean            inError = false;

    private static Hashtable  geStd;
    private final String  INTERNALERROR = YoixConstantsErrorName.INTERNALERROR;

    static {
	geStd = new Hashtable(5);
	geStd.put("amp","&#38;");
	geStd.put("lt","&#60;");
	geStd.put("gt","&#62;");
	geStd.put("apos","&#39;");
	geStd.put("quot","&#34;");
    }

    ///////////////////////////////////
    //
    // XMLParserTokenManager Methods
    //
    ///////////////////////////////////

    void
    clearRef() {

	if (peRef != null)
	    peRef.clear();
	if (geRef != null)
	    geRef.clear();
    }


    void
    clearStack() {

	storedState.setSize(0);
    }


    void
    loadDTD(String dtd) {

	((YoixParserStream)input_stream).loadAux(dtd);
    }


    void
    pushState(int curLexState) {

	storedState.push(new Integer(curLexState));
    }


    boolean
    putRef(String name, String value, boolean isPERef) {

	Hashtable ref;

	if (isPERef) {
	    if (peRef == null)
		peRef = new Hashtable();
	    ref = peRef;
	} else {
	    if (geRef == null)
		geRef = new Hashtable();
	    ref = geRef;
	}
	if (ref.containsKey(name)) {
	    inError = true;
	    return(false);
	}
	ref.put(name, value);
	return(true);
    }


    void
    fixStack(int flag_state) {

	Integer  elem;
	Stack    tmpstk = new Stack();
	int      state;

	while (!storedState.empty()) {
	    elem = (Integer)(storedState.pop());
	    state = elem.intValue();
	    if (state == flag_state)
		break;
	    else tmpstk.push(elem);
	}

	pushState(DEFAULT);
	while (!tmpstk.empty()) {
	    storedState.push(tmpstk.pop());
	}
    }


    ///////////////////////////////////
    //
    // Private Methods
    //
    ///////////////////////////////////

    private String
    getPERef(String name) {

	String  value = null;

	if (peRef != null)
	    value = (String)(peRef.get(name));
	return(value);
    }


    private String
    getGERef(String name) {

	String  value = null;

	if (geRef != null)
	    value = (String)(geRef.get(name));
	if (value == null)
	    value = (String)(geStd.get(name));
	return(value);
    }


    private void
    handleCharRef(StringBuffer image) {

	if (!inError) {

	    char    ch_ref[] = input_stream.GetSuffix(lengthOfMatch - 2);
	    int     int_val = 0;
	    char    ref_val;
	    String  str = null;

	    if (ch_ref[0] == 'x') {
		try {
		    int_val = Integer.parseInt(new String(ch_ref,1,ch_ref.length-2),16);
		}
		catch(NumberFormatException e) {
		    // should never happen
		    YoixConstants.VM.abort(INTERNALERROR);
		}
	    } else {
		try {
		    int_val = Integer.parseInt(str = new String(ch_ref,0,ch_ref.length-1),10);
		}
		catch(NumberFormatException e) {
		    // should never happen
		    YoixConstants.VM.abort(INTERNALERROR);
		}
	    }
	    ref_val = (char)int_val;

	    // should never happen
	    if (ref_val == '\u0000') {
		// set so we don't issue more errors during clean-up
		inError = true;
		throw new RuntimeException("<LEXERR>character reference (&#" + (new String(ch_ref)) + ";) not understood.");
	    }
	    image.setLength(image.length() - lengthOfMatch);
	    image.append(ref_val);
	}
    }


    private void
    handleGERef(StringBuffer image, Token matchedToken) {

	String  ref_val;
	String  ge_ref;

	if (!inError) {
	    if (matchedToken == null)
		ge_ref = new String(input_stream.GetSuffix(lengthOfMatch - 1), 0, lengthOfMatch - 2);
	    else ge_ref = matchedToken.image.substring(1,lengthOfMatch-1);
	    if ((ref_val = getGERef(ge_ref)) == null) {
		// set so we don't issue more errors during clean-up
		inError = true;
		throw new RuntimeException("<LEXERR>general entity (&" + ge_ref + ";) not defined.");
	    }
	    image.setLength(image.length() - lengthOfMatch);
	    ((YoixParserStream)input_stream).loadAux(ref_val);
	    if (matchedToken != null)
		matchedToken.image = "";
	}
    }


    private void
    handlePERef(StringBuffer image, Token matchedToken) {

	if (!inError) {

	    String  ref_val;
	    String  pe_ref = new String(input_stream.GetSuffix(lengthOfMatch - 1), 0, lengthOfMatch - 2);
	    if ((ref_val = getPERef(pe_ref)) == null) {
		// set so we don't issue more errors during clean-up
		inError = true;
		throw new RuntimeException("<LEXERR>parameter entity (%" + pe_ref + ";) not defined.");
	    }

	    image.setLength(image.length() - lengthOfMatch);
	    if (matchedToken == null) {
		image.append(ref_val);
	    } else {
		((YoixParserStream)input_stream).loadAux(" " + ref_val + " ");
		matchedToken.image = "";
	    }

	}
    }


    private int
    popState() {

	int  state = ((Integer)(storedState.pop())).intValue();

	if (jjmatchedKind == TAG_END) {
	    if (state == AttlistDecl_State || state == RefDefID_State)
		state = ((Integer)(storedState.pop())).intValue();
	}

	return(state);
    }


    private void
    stripQuotes(StringBuffer image, Token matchedToken) {

	stripQuotes(image, matchedToken, false);
    }


    private void
    stripQuotes(StringBuffer image, Token matchedToken, boolean force) {

	String  buf;
	char    q;
	int     len;

	if ((len = image.length()) > 1) {
	    q = image.charAt(0);
	    if (force || q == '"' || q == '\'') {
		// assume if quoted, then quoted properly (i.e. both ends)
		buf = image.toString().substring(1,len-1);
		image.setLength(0);
		image.append(buf);
		if (matchedToken != null)
		    matchedToken.image = buf;
	    }
	}
    }
}

TOKEN : {
    <#$SPACE: [" ", "\t", "\n", "\r"]>
  | <#$S: (<$SPACE>)+>
  | <#$LANGQUES: "<?">
  | <#$LANG: "<">
  | <#$LANGSLASH: "</">
  | <#$RANG: ">">
  | <#$SLASHRANG: "/>">
  | <#$CDSTART: "<![CDATA[">
  | <#$CDEND: "]]>">
  | <#$CHAR_NOEQDASHQUESRANGRBRKSPACE: (
	"\\" | ["\u0021"-"\u002C"] |
	["\u002E"-"\u003C"] | ["\u0040"-"\u005B"] |
	["\u005E"-"\uD7FF"] | ["\uE000"-"\uFFFD"]
    )>
  | <#$CHAR_NODASHQUESRANGRBRKSPACE: ( <$CHAR_NOEQDASHQUESRANGRBRKSPACE> | "=" )>
  | <#$CHAR_NODASHQUESRANGRBRK: ( <$CHAR_NODASHQUESRANGRBRKSPACE> | <$SPACE> )>
  | <#$CHAR: (<$CHAR_NODASHQUESRANGRBRK> | ["-", "?", ">", "]"])>
  | <#$BASECHAR_NOXML: (
	["\u0041"-"\u004B"] | ["\u004E"-"\u0057"] |
	["\u0059"-"\u005A"] | ["\u0061"-"\u006B"] |
	["\u006E"-"\u0077"] | ["\u0079"-"\u007A"] |
	["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] |
	["\u00F8"-"\u00FF"] | ["\u0100"-"\u0131"] |
	["\u0134"-"\u013E"] | ["\u0141"-"\u0148"] |
	["\u014A"-"\u017E"] | ["\u0180"-"\u01C3"] |
	["\u01CD"-"\u01F0"] | ["\u01F4"-"\u01F5"] |
	["\u01FA"-"\u0217"] | ["\u0250"-"\u02A8"] |
	["\u02BB"-"\u02C1"] | "\u0386" | ["\u0388"-"\u038A"] |
	"\u038C" | ["\u038E"-"\u03A1"] | ["\u03A3"-"\u03CE"] |
	["\u03D0"-"\u03D6"] | "\u03DA" | "\u03DC" | "\u03DE" |
	"\u03E0" | ["\u03E2"-"\u03F3"] | ["\u0401"-"\u040C"] |
	["\u040E"-"\u044F"] | ["\u0451"-"\u045C"] |
	["\u045E"-"\u0481"] | ["\u0490"-"\u04C4"] |
	["\u04C7"-"\u04C8"] | ["\u04CB"-"\u04CC"] |
	["\u04D0"-"\u04EB"] | ["\u04EE"-"\u04F5"] |
	["\u04F8"-"\u04F9"] | ["\u0531"-"\u0556"] | "\u0559" |
	["\u0561"-"\u0586"] | ["\u05D0"-"\u05EA"] |
	["\u05F0"-"\u05F2"] | ["\u0621"-"\u063A"] |
	["\u0641"-"\u064A"] | ["\u0671"-"\u06B7"] |
	["\u06BA"-"\u06BE"] | ["\u06C0"-"\u06CE"] |
	["\u06D0"-"\u06D3"] | "\u06D5" | ["\u06E5"-"\u06E6"] |
	["\u0905"-"\u0939"] | "\u093D" | ["\u0958"-"\u0961"] |
	["\u0985"-"\u098C"] | ["\u098F"-"\u0990"] |
	["\u0993"-"\u09A8"] | ["\u09AA"-"\u09B0"] | "\u09B2" |
	["\u09B6"-"\u09B9"] | ["\u09DC"-"\u09DD"] |
	["\u09DF"-"\u09E1"] | ["\u09F0"-"\u09F1"] |
	["\u0A05"-"\u0A0A"] | ["\u0A0F"-"\u0A10"] |
	["\u0A13"-"\u0A28"] | ["\u0A2A"-"\u0A30"] |
	["\u0A32"-"\u0A33"] | ["\u0A35"-"\u0A36"] |
	["\u0A38"-"\u0A39"] | ["\u0A59"-"\u0A5C"] | "\u0A5E" |
	["\u0A72"-"\u0A74"] | ["\u0A85"-"\u0A8B"] | "\u0A8D" |
	["\u0A8F"-"\u0A91"] | ["\u0A93"-"\u0AA8"] |
	["\u0AAA"-"\u0AB0"] | ["\u0AB2"-"\u0AB3"] |
	["\u0AB5"-"\u0AB9"] | "\u0ABD" | "\u0AE0" |
	["\u0B05"-"\u0B0C"] | ["\u0B0F"-"\u0B10"] |
	["\u0B13"-"\u0B28"] | ["\u0B2A"-"\u0B30"] |
	["\u0B32"-"\u0B33"] | ["\u0B36"-"\u0B39"] |
	"\u0B3D" | ["\u0B5C"-"\u0B5D"] | ["\u0B5F"-"\u0B61"] |
	["\u0B85"-"\u0B8A"] | ["\u0B8E"-"\u0B90"] |
	["\u0B92"-"\u0B95"] | ["\u0B99"-"\u0B9A"] | "\u0B9C" |
	["\u0B9E"-"\u0B9F"] | ["\u0BA3"-"\u0BA4"] |
	["\u0BA8"-"\u0BAA"] | ["\u0BAE"-"\u0BB5"] |
	["\u0BB7"-"\u0BB9"] | ["\u0C05"-"\u0C0C"] |
	["\u0C0E"-"\u0C10"] | ["\u0C12"-"\u0C28"] |
	["\u0C2A"-"\u0C33"] | ["\u0C35"-"\u0C39"] |
	["\u0C60"-"\u0C61"] | ["\u0C85"-"\u0C8C"] |
	["\u0C8E"-"\u0C90"] | ["\u0C92"-"\u0CA8"] |
	["\u0CAA"-"\u0CB3"] | ["\u0CB5"-"\u0CB9"] | "\u0CDE" |
	["\u0CE0"-"\u0CE1"] | ["\u0D05"-"\u0D0C"] |
	["\u0D0E"-"\u0D10"] | ["\u0D12"-"\u0D28"] |
	["\u0D2A"-"\u0D39"] | ["\u0D60"-"\u0D61"] |
	["\u0E01"-"\u0E2E"] | "\u0E30" | ["\u0E32"-"\u0E33"] |
	["\u0E40"-"\u0E45"] | ["\u0E81"-"\u0E82"] | "\u0E84" |
	["\u0E87"-"\u0E88"] | "\u0E8A" | "\u0E8D" |
	["\u0E94"-"\u0E97"] | ["\u0E99"-"\u0E9F"] |
	["\u0EA1"-"\u0EA3"] | "\u0EA5" | "\u0EA7" |
	["\u0EAA"-"\u0EAB"] | ["\u0EAD"-"\u0EAE"] | "\u0EB0" |
	["\u0EB2"-"\u0EB3"] | "\u0EBD" | ["\u0EC0"-"\u0EC4"] |
	["\u0F40"-"\u0F47"] | ["\u0F49"-"\u0F69"] |
	["\u10A0"-"\u10C5"] | ["\u10D0"-"\u10F6"] | "\u1100" |
	["\u1102"-"\u1103"] | ["\u1105"-"\u1107"] | "\u1109" |
	["\u110B"-"\u110C"] | ["\u110E"-"\u1112"] | "\u113C" |
	"\u113E" | "\u1140" | "\u114C" | "\u114E" | "\u1150" |
	["\u1154"-"\u1155"] | "\u1159" | ["\u115F"-"\u1161"] |
	"\u1163" | "\u1165" | "\u1167" | "\u1169" |
	["\u116D"-"\u116E"] | ["\u1172"-"\u1173"] | "\u1175" |
	"\u119E" | "\u11A8" | "\u11AB" | ["\u11AE"-"\u11AF"] |
	["\u11B7"-"\u11B8"] | "\u11BA" | ["\u11BC"-"\u11C2"] |
	"\u11EB" | "\u11F0" | "\u11F9" | ["\u1E00"-"\u1E9B"] |
	["\u1EA0"-"\u1EF9"] | ["\u1F00"-"\u1F15"] |
	["\u1F18"-"\u1F1D"] | ["\u1F20"-"\u1F45"] |
	["\u1F48"-"\u1F4D"] | ["\u1F50"-"\u1F57"] | "\u1F59" |
	"\u1F5B" | "\u1F5D" | ["\u1F5F"-"\u1F7D"] |
	["\u1F80"-"\u1FB4"] | ["\u1FB6"-"\u1FBC"] | "\u1FBE" |
	["\u1FC2"-"\u1FC4"] | ["\u1FC6"-"\u1FCC"] |
	["\u1FD0"-"\u1FD3"] | ["\u1FD6"-"\u1FDB"] |
	["\u1FE0"-"\u1FEC"] | ["\u1FF2"-"\u1FF4"] |
	["\u1FF6"-"\u1FFC"] | "\u2126" | ["\u212A"-"\u212B"] |
	"\u212E" | ["\u2180"-"\u2182"] | ["\u3041"-"\u3094"] |
	["\u30A1"-"\u30FA"] | ["\u3105"-"\u312C"] |
	["\uAC00"-"\uD7A3"]
    )>
  | <#$BASECHAR: (<$BASECHAR_NOXML> | ["X", "M", "L", "x", "m", "l"])>
  | <#$IDEOGRAPHIC: (
	["\u4E00"-"\u9FA5"] | "\u3007" | ["\u3021"-"\u3029"]
    )>
  | <#$COMBINING_CHAR: (
	["\u0300"-"\u0345"] | ["\u0360"-"\u0361"] |
	["\u0483"-"\u0486"] | ["\u0591"-"\u05A1"] |
	["\u05A3"-"\u05B9"] | ["\u05BB"-"\u05BD"] | "\u05BF" |
	["\u05C1"-"\u05C2"] | "\u05C4" | ["\u064B"-"\u0652"] |
	"\u0670" | ["\u06D6"-"\u06DC"] | ["\u06DD"-"\u06DF"] |
	["\u06E0"-"\u06E4"] | ["\u06E7"-"\u06E8"] |
	["\u06EA"-"\u06ED"] | ["\u0901"-"\u0903"] | "\u093C" |
	["\u093E"-"\u094C"] | "\u094D" | ["\u0951"-"\u0954"] |
	["\u0962"-"\u0963"] | ["\u0981"-"\u0983"] |
	"\u09BC" | "\u09BE" | "\u09BF" | ["\u09C0"-"\u09C4"] |
	["\u09C7"-"\u09C8"] | ["\u09CB"-"\u09CD"] | "\u09D7" |
	["\u09E2"-"\u09E3"] | "\u0A02" | "\u0A3C" | "\u0A3E" |
	"\u0A3F" | ["\u0A40"-"\u0A42"] | ["\u0A47"-"\u0A48"] |
	["\u0A4B"-"\u0A4D"] | ["\u0A70"-"\u0A71"] |
	["\u0A81"-"\u0A83"] | "\u0ABC" | ["\u0ABE"-"\u0AC5"] |
	["\u0AC7"-"\u0AC9"] | ["\u0ACB"-"\u0ACD"] |
	["\u0B01"-"\u0B03"] | "\u0B3C" | ["\u0B3E"-"\u0B43"] |
	["\u0B47"-"\u0B48"] | ["\u0B4B"-"\u0B4D"] |
	["\u0B56"-"\u0B57"] | ["\u0B82"-"\u0B83"] |
	["\u0BBE"-"\u0BC2"] | ["\u0BC6"-"\u0BC8"] |
	["\u0BCA"-"\u0BCD"] | "\u0BD7" | ["\u0C01"-"\u0C03"] |
	["\u0C3E"-"\u0C44"] | ["\u0C46"-"\u0C48"] |
	["\u0C4A"-"\u0C4D"] | ["\u0C55"-"\u0C56"] |
	["\u0C82"-"\u0C83"] | ["\u0CBE"-"\u0CC4"] |
	["\u0CC6"-"\u0CC8"] | ["\u0CCA"-"\u0CCD"] |
	["\u0CD5"-"\u0CD6"] | ["\u0D02"-"\u0D03"] |
	["\u0D3E"-"\u0D43"] | ["\u0D46"-"\u0D48"] |
	["\u0D4A"-"\u0D4D"] | "\u0D57" | "\u0E31" |
	["\u0E34"-"\u0E3A"] | ["\u0E47"-"\u0E4E"] |
	"\u0EB1" | ["\u0EB4"-"\u0EB9"] | ["\u0EBB"-"\u0EBC"] |
	["\u0EC8"-"\u0ECD"] | ["\u0F18"-"\u0F19"] |
	"\u0F35" | "\u0F37" | "\u0F39" | "\u0F3E" |
	"\u0F3F" | ["\u0F71"-"\u0F84"] | ["\u0F86"-"\u0F8B"] |
	["\u0F90"-"\u0F95"] | "\u0F97" | ["\u0F99"-"\u0FAD"] |
	["\u0FB1"-"\u0FB7"] | "\u0FB9" | ["\u20D0"-"\u20DC"] |
	"\u20E1" | ["\u302A"-"\u302F"] | "\u3099" | "\u309A"
    )>
  | <#$DIGIT: (
	["\u0030"-"\u0039"] | ["\u0660"-"\u0669"] |
	["\u06F0"-"\u06F9"] | ["\u0966"-"\u096F"] |
	["\u09E6"-"\u09EF"] | ["\u0A66"-"\u0A6F"] |
	["\u0AE6"-"\u0AEF"] | ["\u0B66"-"\u0B6F"] |
	["\u0BE7"-"\u0BEF"] | ["\u0C66"-"\u0C6F"] |
	["\u0CE6"-"\u0CEF"] | ["\u0D66"-"\u0D6F"] |
	["\u0E50"-"\u0E59"] | ["\u0ED0"-"\u0ED9"] |
	["\u0F20"-"\u0F29"]
    )>
  | <#$EXTENDER: (
	"\u00B7" | "\u02D0" | "\u02D1" | "\u0387" | "\u0640" |
	"\u0E46" | "\u0EC6" | "\u3005" | ["\u3031"-"\u3035"] |
	["\u309D"-"\u309E"] | ["\u30FC"-"\u30FE"]
    )>
  | <#$LETTER: (<$BASECHAR> | <$IDEOGRAPHIC>)>
  | <#$NAMECHAR: (
	<$LETTER> | <$DIGIT> | "." | "-" | "_" | ":" |
	<$COMBINING_CHAR> | <$EXTENDER>
    )>
  | <#$NAME: (<$LETTER> | "_" | ":") (<$NAMECHAR>)*>
  | <#$NAMES: <$NAME> (<$S> <$NAME>)*>
  | <#$NMTOKEN: (<$NAMECHAR>)+>
  | <#$NMTOKENS: <$NMTOKEN> (<$S> <$NMTOKEN>)*>
  | <#$PERREF:  "%" <$NAME> ";">
  | <#$ENTREF:  "&" <$NAME> ";">
  | <#$CHARREF:
	"&#" (["0" - "9"])+ ";"
      | "&#x"  (["0"-"9"]|["a"-"f"]|["A"-"F"])+ ";"
    >
  | <#$REF: (<$ENTREF> | <$CHARREF>) >
  | <#$PUBID_NOSQ: (
	" " | "\n" | "\r" | ["a"-"z"] | ["A"-"Z"] | ["0"-"9"] |
	["-","(",")","+",",",".","/",":","=","?",";","!","*","#","@","$","_","%"]
    )>
  | <#$PUBID: (<$PUBID_NOSQ> | "'")>
  | <#$ENTVAL: (("\"" (~["%","&","\""] | <$PERREF> | <$REF>)* "\"") | ("'" (~["%","&","'"] | <$PERREF> | <$REF>)* "'"))>
  | <#$ATTVAL: (("\"" (~["<","&","\""] | <$REF>)* "\"") | ("'" (~["<","&","'"] | <$REF>)* "'"))>
  | <#$SYSLIT: (("\"" (~["\""])* "\"") | ("'" (~["'"])* "'"))>
  | <#$PUBLIT: (("\"" (<$PUBID>)* "\"") | ("'" (<$PUBID_NOSQ>)* "'"))>
  | <#$CHARDATA: (~["<","&"])>
  | <#$LETTER_NOXML: (<$BASECHAR_NOXML> | <$IDEOGRAPHIC>)>
  | <#$NAMECHAR_NOXML: (
	<$LETTER_NOXML> | <$DIGIT> | "." | "-" | "_" | ":" |
	<$COMBINING_CHAR> | <$EXTENDER>
    )>
  | <$VERSION_NUM: (["a"-"z", "A"-"Z", "0"-"9", "_", ".", ":"] | "-")+>
  | <$ENC_NAME: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9", "_", "."] | "-")*>
}

TOKEN [IGNORE_CASE] : {
    <XMLDECL_BGN: "<?xml"> { pushState(curLexState); } : XmlDecl_State
  | <DTD_BGN: "<!doctype"> { pushState(curLexState); pushState(RefDefID_State); } : Name_State
}

<*> TOKEN : {
    <COMMENT_BGN: "<!--"> { pushState(curLexState); } : Comment_State
}

<Name_State> TOKEN : {
    <NAME: <$NAME>> { SwitchTo(popState()); }
  | <N_LPAREN: "("> { pushState(curLexState); }
  | <N_RPAREN: ")"> { SwitchTo(popState()); }
  | <N_PCT: "%">
  | <N_QUES: "?">
  | <N_STAR: "*">
  | <N_PLUS: "+">
  | <N_PIPE: "|"> { pushState(curLexState); }
  | <N_COMMA: ","> { pushState(curLexState); }
}

<Name_State> TOKEN [IGNORE_CASE] : {
    <PCDATA: "#pcdata"> { popState(); SwitchTo(popState()); }
}

<NmToken_State> TOKEN : {
    <NMTOKEN: <$NMTOKEN>> { SwitchTo(popState()); }
}

<Comment_State> TOKEN : {
    <COMMENT: ((<$CHAR_NODASHQUESRANGRBRK>|["?",">","]"])|("-"(<$CHAR_NODASHQUESRANGRBRK>|["?",">","]"])))+>
  | <COMMENT_END: "-->"> { SwitchTo(popState()); }
}

<PiTarget_State> TOKEN : {
    <PI_TARGET: (
		 ((<$LETTER_NOXML>|["_",":","M","m","L","l"])(<$NAMECHAR>)*) |
		 ["X","x"]((<$NAMECHAR_NOXML>|["X","x","L","l"])(<$NAMECHAR>)*)*|
		 ["X","x"]["M","m"]((<$NAMECHAR_NOXML>|["X","x","M","m"])(<$NAMECHAR>)*)*|
		 ["X","x"]["M","m"]["L","l"](<$NAMECHAR>)+)> : Pi_State
}

//
// Changed from CHAR_NODASHQUESRANGRBRKSPACE to CHAR_NODASHQUESRANGRBRK on
// 8/21/10. Also made a change in the ProcInst() production, which most of
// the time refused to recognize valid processing instructions. The changes
// seem reasonable, but probably need another look.
// 

<Pi_State> TOKEN : {
    <PI_END: "?>"> { SwitchTo(popState()); }
    | <PI_TEXT: ( (<$CHAR_NODASHQUESRANGRBRK>|["-",">","]"]) |
	(<$CHAR_NODASHQUESRANGRBRK>|["-","]"])+ |
	((<$CHAR_NODASHQUESRANGRBRK>|["-","]"])*"?"("?")*(<$CHAR_NODASHQUESRANGRBRK>|["-","]"])(<$CHAR_NODASHQUESRANGRBRK>|["-","]"])*)+  )>
}

<XmlDecl_State> TOKEN [IGNORE_CASE] : {
    <VERSION: "version"> { pushState(curLexState); } : VersionNum_State
  | <ENCODING: "encoding"> { pushState(curLexState); } : EncodingDecl_State
  | <STANDALONE: "standalone"> { pushState(curLexState); } : StandAlone_State
  | <XMLDECL_END: "?>"> { SwitchTo(popState()); }

}

<VersionNum_State> TOKEN : {
    <VERSION_NUM: ("\"" <$VERSION_NUM> "\"" | "'" <$VERSION_NUM> "'")> {
	stripQuotes(image, matchedToken);
	SwitchTo(popState());
    }
}

<EncodingDecl_State> TOKEN : {
    <ENC_NAME: ("\"" <$ENC_NAME> "\"" | "'" <$ENC_NAME> "'")> {
	stripQuotes(image, matchedToken);
	SwitchTo(popState());
    }
}

<StandAlone_State> TOKEN [IGNORE_CASE] : {
    <YES: ("\"yes\"" | "'yes'")> {
	stripQuotes(image, matchedToken);
	SwitchTo(popState());
    }
  | <NO: ("\"no\"" | "'no'")> {
        stripQuotes(image, matchedToken);
        SwitchTo(popState());
    }
}

<RefDefID_State> TOKEN [IGNORE_CASE] : {
    <SYSTEM: "system"> { pushState(curLexState); } : System_State
  | <PUBLIC: "public"> { pushState(curLexState); } : Public_State
  | <NDATA: "ndata"> { pushState(curLexState); } : Name_State
  | <LBRK: "["> { pushState(curLexState); } : MarkupSep_State
}

<RefDefID_State> MORE : {
    "\"" : RefDefID_State_DQ
 |  "'"  : RefDefID_State_SQ
}

<RefDefID_State_DQ> TOKEN : {
    <DQ_ENTVAL: "\""> { stripQuotes(image, matchedToken); } : RefDefID_State
}

<RefDefID_State_DQ> MORE : {
    <DQ_ENTVAL_TEXT: ( ~["%","&","\""] )+>
 |  <DQ_PERREF: <$PERREF>> { handlePERef(image, null); }
 |  <DQ_ENTREF: <$ENTREF>>
 |  <DQ_CHARREF: <$CHARREF>> { handleCharRef(image); }
}

<RefDefID_State_SQ> TOKEN : {
    <SQ_ENTVAL: "'"> { stripQuotes(image, matchedToken); } : RefDefID_State
}

<RefDefID_State_SQ> MORE : {
    <SQ_ENTVAL_TEXT: ( ~["%","&","'"] )+>
 |  <SQ_PERREF: <$PERREF>> { handlePERef(image, null); }
 |  <SQ_ENTREF: <$ENTREF>>
 |  <SQ_CHARREF: <$CHARREF>> { handleCharRef(image); }
}

<System_State> TOKEN : {
    <SYSLIT: <$SYSLIT>> {
        stripQuotes(image, matchedToken);
        SwitchTo(popState());
    }
}

<Public_State> TOKEN : {
    <PUBLIT: <$PUBLIT>> { stripQuotes(image, matchedToken); } : System_State
}

<MarkupSep_State> TOKEN [IGNORE_CASE] : {
    <ELEMENT: "<!element"> { pushState(curLexState); pushState(ElementDecl_State); } : Name_State
  | <ATTLIST: "<!attlist"> { pushState(curLexState); pushState(AttlistDecl_State); pushState(Name_State); } : Name_State
  | <ENTITY: "<!entity"> { pushState(curLexState); pushState(RefDefID_State); } : Name_State
  | <NOTATION: "<!notation"> { pushState(curLexState); pushState(RefDefID_State); } : Name_State
}

<MarkupSep_State> TOKEN : {
    <PERREF: <$PERREF>> { handlePERef(image, matchedToken); }
  | <RBRK: "]"> { SwitchTo(popState()); }
}

<ElementDecl_State> TOKEN [IGNORE_CASE] : {
    <EMPTY: "empty">
  | <ANY: "any">
}

<ElementDecl_State> TOKEN : {
    <E_LPAREN: "("> { pushState(curLexState); pushState(Name_State); } : Name_State
  | <E_RPAREN: ")">
  | <E_PIPE: "|"> { pushState(curLexState); } : Name_State
  | <E_QUES: "?">
  | <E_STAR: "*">
  | <E_PLUS: "+">
}

<AttlistDecl_State> TOKEN [IGNORE_CASE] : {
    <NOTATION_TYPE: "notation"> : Name_State
  | <A_LPAREN: "("> { pushState(curLexState); } : NmToken_State
  | <A_PIPE: "|"> { pushState(curLexState); } : NmToken_State
  | <A_RPAREN: ")">
  | <REQUIRED: "#required"> { pushState(AttlistDecl_State); } : Name_State
  | <IMPLIED: "#implied"> { pushState(AttlistDecl_State); } : Name_State
  | <FIXED: "#fixed">
  | <STRING_TYPE: "cdata">
  | <TOKENIZED_TYPE: (
	"id" | "idref" | "idrefs" |  "entity" | "entities" | "nmtoken" | "nmtokens"
    )>
}

<AttlistDecl_State> TOKEN : {
    <ATTVAL: <$ATTVAL>> {
	pushState(AttlistDecl_State);
	stripQuotes(image, matchedToken);
    } : Name_State
}

<Attribute_State> TOKEN : {
    <ATTRNAME: <$NAME>> { pushState(curLexState); } : Value_State
  | <ETAG_END: <$SLASHRANG>> { popState(); SwitchTo(popState()); }
}

<Value_State> TOKEN : {
    <ATTRVAL: ((["a"-"z", "A"-"Z", "0"-"9", "_", ".", ":", ","] | "-")+)> {
	stripQuotes(image, matchedToken);
	SwitchTo(popState());
    }
}

<Value_State> MORE : {
    "\"" : Value_State_DQ
 |  "'"  : Value_State_SQ
}

<Value_State_DQ> TOKEN : {
    <DQ_ATTRVAL: "\""> {
	stripQuotes(image, matchedToken);
	SwitchTo(popState());
    }
}

<Value_State_DQ> MORE : {
    <DQ_ATTRTXT: ( ~["<","&","\""] )+>
 |  <DQ_ATTRENT: <$ENTREF>> { handleGERef(image, null); }
 |  <DQ_ATTRCHR: <$CHARREF>> { handleCharRef(image); }
}

<Value_State_SQ> TOKEN : {
    <SQ_ATTRVAL: "'"> {
	stripQuotes(image, matchedToken);
	SwitchTo(popState());
    }
}

<Value_State_SQ> MORE : {
    <SQ_ATTRTXT: ( ~["<","&","'"] )+>
 |  <SQ_ATTRENT: <$ENTREF>> { handleGERef(image, null); }
 |  <SQ_ATTRCHR: <$CHARREF>> { handleCharRef(image); }
}

<Content_State> TOKEN : {
    <BTAG_BGN: <$LANGSLASH>> { pushState(DEFAULT); } : Name_State
  | <CHARDATA: (<$CHARDATA>)+>
  | <ENTREF: <$ENTREF>> { handleGERef(image, matchedToken); }
  | <CHARREF: <$CHARREF>> { handleCharRef(image); matchedToken.image = image.toString(); }
}

<Content_State> TOKEN [IGNORE_CASE] : {
    <CDSTART: <$CDSTART>> { pushState(curLexState); } : CData_State
}

<CData_State> TOKEN : {
    <CDATA: (<$CHAR>)*<$CDEND>> { SwitchTo(popState()); }
}

<*> TOKEN : {
    <S: <$S>>
  | <EQ: (<S>)? "=" (<S>)?>
  | <TAG_BGN: <$LANG>> { pushState(curLexState); pushState(Content_State); pushState(Attribute_State); } : Name_State
  | <TAG_END: <$RANG>> { SwitchTo(popState()); }
  | <PI_BGN: <$LANGQUES>> { pushState(curLexState); } : PiTarget_State
}

<*> SKIP : {
    <ENTPERREF: <$PERREF>> {
	if (!inError) {
	    if (inDTD) {
		// FYI: matchedToken will be null always since this is a SKIP
		stripQuotes(image, matchedToken, true);
		if (!(((YoixParserStream)input_stream).loadAux(getPERef(image.toString())))) {
		    // set so we don't issue more errors during clean-up
		    inError = true;
		    throw new RuntimeException("<LEXERR>parameter entity (%" + image.toString() + ";) not defined.");
		}
	    } else {
		// set so we don't issue more errors during clean-up
		inError = true;
		throw new RuntimeException("<LEXERR>parameter entity (" + image.toString() + ") not expected.");
	    }
	}
    }
}

<Dummy_State> TOKEN: {
    <_ATTLIST_DECL: "ATTLIST_DECL">
  | <_ATTRIBUTE: "ATTRIBUTE">
  | <_ATT_DEF: "ATT_DEF">
  | <_ATT_TYPE: "ATT_TYPE">
  | <_BLOCK: "BLOCK">
  | <_BODY: "BODY">
  | <_CDSECT: "CDSECT">
  | <_CHARDATA: "CHARDATA">
  | <_CHOICE: "CHOICE">
  | <_COMMENT: "COMMENT">
  | <_CONTENT: "CONTENT">
  | <_CONTENT_SPEC: "CONTENT_SPEC">
  | <_DECL_SEP: "DECL_SEP">
  | <_DEFAULT_DECL: "DEFAULT_DECL">
  | <_DTD: "DTD">
  | <_ELEMENT_DECL: "ELEMENT_DECL">
  | <_ENCODING: "ENCODING">
  | <_ENTITY_DECL: "ENTITY_DECL">
  | <_ENTITY_VALUE: "ENTITY_VALUE">
  | <_ENUMERATION: "ENUMERATION">
  | <_EXTERNAL_ID: "EXTERNAL_ID">
  | <_FIXED: "FIXED">
  | <_FLAG: "FLAG">
  | <_FOLDER: "FOLDER"> // used in Yoix.java
  | <_GE_DECL: "GE_DECL">
  | <_IMPLIED: "IMPLIED">
  | <_NAME: "NAME">
  | <_NDATA_DECL: "NDATA_DECL">
  | <_NMTOKEN: "NMTOKEN">
  | <_NOBLOCK: "NOBLOCK">
  | <_NOTATION_DECL: "NOTATION_DECL">
  | <_NOTATION_TYPE: "NOTATION_TYPE">
  | <_PCDATA: "PCDATA">
  | <_PE_DECL: "PE_DECL">
  | <_PROC_INST: "PROC_INST">
  | <_PROLOG: "PROLOG">
  | <_PUBLIC: "PUBLIC">
  | <_PUBLIC_ID: "PUBLIC_ID">
  | <_REFERENCE: "REFERENCE">
  | <_REPEATED_VALUE: "REPEATED_VALUE">
  | <_REPITITION: "REPITITION">
  | <_REQUIRED: "REQUIRED">
  | <_SELF: "SELF">
  | <_SEQUENCE: "SEQUENCE">
  | <_STANDALONE: "STANDALONE">
  | <_STRING: "STRING">
  | <_SYSTEM: "SYSTEM">
  | <_TOKENIZED: "TOKENIZED">
  | <_VALUE: "VALUE">
  | <_VALUES: "VALUES">
  | <_VERSION: "VERSION">
  | <_XML: "XML">
  | <_XML_DECL: "XML_DECL">
}

//
// Everything else, so we get errors from the parser instead of the
// token manager.
//

<*> TOKEN : {<UNMATCHEDTOKEN : ~[]>}

//
// Last token number assigned by the parser.
//

<Dummy_State> TOKEN : {<LASTTOKEN : "LASTTOKEN">}

//
// Entry point for document parsing.
//

SimpleNode
parseDocument(YoixParserStream stream, boolean tags) #void : {
    reset(stream, tags);
}
{
    try {
	XML()
	{
	    Token tok = getToken(1);
	    if (tok != null && tok.image.length() > 0)
		stream.backup(getToken(1).image.length());
	    return((SimpleNode)jjtree.popNode());
	}
    }
    catch(ParseException e) {
	return(abort("XML " + SYNTAXERROR, e));
    }
    catch(RuntimeException e) {
	String  msg = e.getMessage();
	if (msg != null && msg.startsWith("<LEXERR>"))
	    return(abort("XML validation error: " + msg.substring(8)));
	else return(die(INTERNALERROR));	// should never get here!!
    }
    catch(TokenMgrError e) {
	return(die(SYNTAXERROR));	// should never get here!!
    }
    finally {
	restore();
    }
}

//
// Entry point for dtd parsing.
//

SimpleNode
parseDTD(YoixParserStream stream, boolean tags) #void : {
    reset(stream, tags);
    token_source.pushState(DEFAULT);
    token_source.SwitchTo(MarkupSep_State);
    token_source.inDTD = true;
}
{
    try {
	DTD()
	{
	    Token tok = getToken(1);
	    if (tok != null && tok.image.length() > 0)
		stream.backup(getToken(1).image.length());
	    return((SimpleNode)jjtree.popNode());
	}
    }
    catch(ParseException e) {
	return(abort("DTD " + SYNTAXERROR, e));
    }
    catch(RuntimeException e) {
	String  msg = e.getMessage();
	if (msg != null && msg.startsWith("<LEXERR>"))
	    return(abort("XML validation error: " + msg.substring(8)));
	else return(die(INTERNALERROR));	// should never get here!!
    }
    catch(TokenMgrError e) {
	return(die(SYNTAXERROR));	// should never get here!!
    }
    finally {
	restore();
    }
}

// ================================================================

void
XML() : { Token eof=null; }
{
    (eof=<EOF> | (Prolog() Body() (Misc())* [eof=<EOF>]))
    {
	int type = _XML;

	if (jjtThis.jjtGetNumChildren() == 0) {
	    if (eof == null)
		abort("XML " + SYNTAXERROR + ": document content is not recognizable as an XML document");
	    else type = YOIX_EOF;
	}
	buildDocument(jjtThis, type);
    }
}

void
DTD() : { Token eof=null; }
{
    ( LOOKAHEAD(2) eof=<EOF> | (Markups() [eof=<EOF>]))
    {
	int type = _DTD;

	if (jjtThis.jjtGetNumChildren() == 0) {
	    if (eof == null)
		abort("XML " + SYNTAXERROR + ": dtd is not recognizable as an XML dtd");
	    else type = YOIX_EOF;
	}
	buildDocument(jjtThis, type);
    }
}

void
Markups() #void : {}
{
    (MarkupDecl() | DeclSep())*
}

void
Prolog() : {}
{
    [XMLDecl()] (LOOKAHEAD(2) Misc())* [DocTypeDecl() (LOOKAHEAD(2) Misc())*]
    {
	if (jjtThis.value.length == 0)
	    jjtree.popNode();
	else buildDocument(jjtThis, _PROLOG);
    }
}

void
Misc() #void : {}
{
    Comment() | ProcInst() | <S>
}

void
Comment() : { Token tok = null; }
{
    <COMMENT_BGN> [tok=<COMMENT>] <COMMENT_END>
    {
	buildComment(jjtThis, tok);
    }
}

void
ProcInst() : { Token tgt, flag=null; }
{
    <PI_BGN> tgt=<PI_TARGET> [flag=<PI_TEXT>] <PI_END>
    {
	jjtThis.jjtAppendChild(new SimpleNode(_NAME, tgt.image));
	if (flag != null)
	    jjtThis.jjtAppendChild(new SimpleNode(_FLAG, flag.image));
	buildDocument(jjtThis, _PROC_INST);
    }
}

void
XMLDecl() : {}
{
    <XMLDECL_BGN> VersionInfo() [LOOKAHEAD(2) EncodingDecl()] [LOOKAHEAD(2) SDDecl()] [<S>] <XMLDECL_END>
    {
	buildDocument(jjtThis, _XML_DECL);
    }
}

void
VersionInfo() : { Token tok; }
{
    <S> <VERSION> <EQ> tok=<VERSION_NUM>
    {
	buildDocument(jjtThis, _VERSION, tok);
    }
}

void
EncodingDecl() : { Token tok; }
{
    <S> <ENCODING> <EQ> tok=<ENC_NAME>
    {
	buildDocument(jjtThis, _ENCODING, tok);
    }
}

void
SDDecl() : { Token yes=null, no=null; }
{
    <S> <STANDALONE> <EQ> (yes=<YES>|no=<NO>)
    {
	buildDocument(jjtThis, _STANDALONE, (yes != null) ? yes : no);
    }
}

void
DocTypeDecl() : { Token tok; }
{
    <DTD_BGN> <S> tok=<NAME> [LOOKAHEAD(2) <S> ExternalID(null, false, true)] [<S>] [LBracket() Markups() RBracket() [<S>]] <TAG_END>
    {
	doctype_name = tok.image;
	if (dtd_text != null) {
	    token_source.inDTD = true;
	    token_source.pushState(DEFAULT);
	    token_source.SwitchTo(MarkupSep_State);
	    token_source.loadDTD(dtd_text);
	    dtd_text = null;
	    Markups();
	    token_source.inDTD = false;
	    token_source.fixStack(MarkupSep_State);
	}
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _DTD);
    }
}

void
LBracket() #void : {}
{
    <LBRK>
	{
	    token_source.inDTD = true;
	    if (dtd_text != null) {
		token_source.loadDTD(dtd_text);
		dtd_text = null;
	    }
	}
}

void
RBracket() #void : {}
{
    <RBRK>
	{
	    token_source.inDTD = false;
	}
}

void
ExternalID(String name, boolean isPERef, boolean isDTD) : { Token pub=null, sys; }
{
    ((<SYSTEM> <S> sys=<SYSLIT>) | (<PUBLIC> <S> pub=<PUBLIT> <S> sys=<SYSLIT>))
    {
	if (pub != null)
	    jjtThis.jjtAppendChild(new SimpleNode(_PUBLIC, pub.image));
	jjtThis.jjtAppendChild(new SimpleNode(_SYSTEM, sys.image));

	if (isDTD) {
	    BufferedReader  reader = YoixMisc.getParserReader(sys.image);

	    if (reader != null) {
		int  cnt, size = 4096, beg = 0, len = size;
		char[] chrs = new char[size];
		char[] nchr;

		try {
		    while((cnt = reader.read(chrs,beg,len)) >= 0) {
			if (cnt > 0) {
			    if (cnt < len) {
				beg += cnt;
				len -= cnt;
			    } else {
				beg = chrs.length;
				len = size;
				nchr = new char[chrs.length + size];
				System.arraycopy(chrs,0,nchr,0,chrs.length);
				chrs = nchr;
			    }
			}
		    }
		    reader.close();
		}
		catch(IOException e) {
		    len = -1;
		}

		if (len >= 0) {
		    dtd_text = new String(chrs, 0, beg);
		}
	    }

	    int lidx;

	    if ((lidx = sys.image.lastIndexOf("/")) > 0) {
		docbase = sys.image.substring(0,lidx);
	    }
	} else if (name != null) {
	    BufferedReader  reader = YoixMisc.getParserReader(sys.image);

	    if (reader == null && docbase != null) {
		reader = YoixMisc.getParserReader(docbase + "/" + sys.image);
	    }

	    if (reader != null) {
		int  cnt, size = 4096, beg = 0, len = size;
		char[] chrs = new char[size];
		char[] nchr;

		try {
		    while((cnt = reader.read(chrs,beg,len)) >= 0) {
			if (cnt > 0) {
			    if (cnt < len) {
				beg += cnt;
				len -= cnt;
			    } else {
				beg = chrs.length;
				len = size;
				nchr = new char[chrs.length + size];
				System.arraycopy(chrs,0,nchr,0,chrs.length);
				chrs = nchr;
			    }
			}
		    }
		    reader.close();
		}
		catch(IOException e) {
		    len = -1;
		}

		if (len >= 0) {
		    if (!token_source.putRef(name,new String(chrs, 0, beg),isPERef)) {
			if (isPERef)
			    abort("XML validation error: parameter entity name (" + name + ") already in use");
			else
			    abort("XML validation error: general entity name (" + name + ") already in use");
		    }
		}
	    }
	}

	buildDocument(jjtThis, _EXTERNAL_ID);
    }
}

void
MarkupDecl() #void : {}
{
    (ElementDecl() | AttlistDecl() | EntityDecl() | NotationDecl() | ProcInst() | Comment())
}

void
DeclSep() #void : {}
{
    (<PERREF> | <S>)
}

void
ElementDecl() : { Token tok; }
{
    <ELEMENT> <S> tok=<NAME> <S> ContentSpec() [<S>] <TAG_END>
    {
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _ELEMENT_DECL);
    }
}

void
ContentSpec() : { Token tok=null; }
{
    (tok=<EMPTY> | tok=<ANY> | (LOOKAHEAD(HitMixed()) Mixed() | Children()))
    {
	buildDocument(jjtThis, _CONTENT_SPEC, tok);
    }
}

void
Mixed() : { Token tok, end=null; boolean members=false; }
{
    (<E_LPAREN> [<S>] <PCDATA> (LOOKAHEAD(2)
			    ((LOOKAHEAD(2) [<S>] <E_PIPE> [<S>] tok=<NAME> {
				members = true;
				jjtThis.jjtAppendChild(new SimpleNode(_NAME, tok.image));
			    })* [<S>] <E_RPAREN> end=<E_STAR>)
			    | ([<S>] <E_RPAREN>)
			    )
    )
    {
	if (members) {
	    if (end == null)
		jjtThis.jjtInsertChild(new SimpleNode(_REPITITION, "1"), 0);
	    else jjtThis.jjtInsertChild(new SimpleNode(_REPITITION, "0+"), 0);
	} else {
	    if (end == null)
		jjtThis.value = new Object[] {"1"};
	    else jjtThis.value = new Object[] {"0+"};
	}
	buildDocument(jjtThis, _PCDATA);
    }
}

void
Children() : { Token tok=null; }
{
    ((LOOKAHEAD(HitChoice()) Choice() | LOOKAHEAD(HitSeq()) Seq()) [tok=<E_QUES> | tok=<E_STAR> | tok=<E_PLUS>])
    {
	String  mode = "1";
	if (tok != null) {
	    if (tok.image.charAt(0) == '?')
		mode = "0-1";
	    else if (tok.image.charAt(0) == '*')
		mode = "0+";
	    else mode = "1+";
	}
	jjtThis.jjtInsertChild(new SimpleNode(_REPITITION, mode), 0);
	buildDocument(jjtThis, _VALUES);
    }
}

void
Choice() : {}
{
    ((<E_LPAREN> | <N_LPAREN>) [<S>] CP() (LOOKAHEAD(2) [<S>] <N_PIPE> [<S>] CP())+ [<S>] <N_RPAREN>)
    {
	buildDocument(jjtThis, _CHOICE);
    }
}

void
Seq() : {}
{
    ((<E_LPAREN> | <N_LPAREN>) [<S>] CP() (LOOKAHEAD(2) [<S>] <N_COMMA> [<S>] CP())* [<S>] <N_RPAREN>)
    {
	buildDocument(jjtThis, _SEQUENCE);
    }
}

void
CP() #void : { Token tok=null, rep=null; }
{
    ((tok=<NAME> | LOOKAHEAD(HitChoice()) Choice() | LOOKAHEAD(HitSeq()) Seq()) [rep=<N_QUES> | rep=<N_STAR> | rep=<N_PLUS>])
    {
	SimpleNode  node;
	String      mode = null;

	if (rep != null) {
	    if (rep.image.charAt(0) == '?')
		mode = "0-1";
	    else if (rep.image.charAt(0) == '*')
		mode = "0+";
	    else mode = "1+";
	}
	if (tok != null) {
	    if (mode != null) {
		node = new SimpleNode(_REPEATED_VALUE);
		node.jjtAppendChild(new SimpleNode(_REPITITION, mode));
		node.jjtAppendChild(new SimpleNode(_VALUE, tok.image));
	    } else node = new SimpleNode(_VALUE, tok.image);
	    jjtree.pushNode(node);
	} else {
	    if (mode != null) {
		node = (SimpleNode)jjtree.peekNode();
		node.jjtInsertChild(new SimpleNode(_REPITITION, mode), 0);
	    }
	}
    }
}

void
AttlistDecl() : { Token tok; }
{
    <ATTLIST> <S> tok=<NAME> (LOOKAHEAD(2) AttDef())* [<S>] <TAG_END>
    {
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _ATTLIST_DECL);
    }
}

void
AttDef() : { Token tok; }
{
    <S> tok=<NAME> <S> AttType() <S> DefaultDecl()
    {
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _ATT_DEF);
    }
}

void
AttType() : { Token tok = null; }
{
    (tok=<STRING_TYPE> | tok=<TOKENIZED_TYPE> | EnumeratedType())
    {
	if (tok != null) {
	    if (tok.kind == STRING_TYPE)
		jjtThis.jjtAppendChild(new SimpleNode(_STRING, tok.image.toUpperCase()));
	    else jjtThis.jjtAppendChild(new SimpleNode(_TOKENIZED, tok.image.toUpperCase()));
	}
	buildDocument(jjtThis, _ATT_TYPE);
    }
}

void
DefaultDecl() : { Token tok, fixed = null; }
{
    (tok=<REQUIRED> | tok=<IMPLIED> | ([fixed=<FIXED> <S>] tok=<ATTVAL>))
    {
	if (fixed != null)
	    jjtThis.jjtAppendChild(new SimpleNode(_FIXED));
	switch (tok.kind) {
	    case REQUIRED:
		jjtThis.jjtAppendChild(new SimpleNode(_REQUIRED));
		break;
	    case IMPLIED:
		jjtThis.jjtAppendChild(new SimpleNode(_IMPLIED));
		break;
	    default:
		jjtThis.jjtAppendChild(new SimpleNode(_VALUE, tok.image));
		break;
	}
	buildDocument(jjtThis, _DEFAULT_DECL);
    }
}

void
EnumeratedType() #void : {}
{
    NotationType() | Enumeration()
}

void
NotationType() : { Token tok; }
{
    <NOTATION_TYPE> <S> <N_LPAREN> [<S>] tok=<NAME> {
	jjtThis.jjtAppendChild(new SimpleNode(_NAME, tok.image));
    } (LOOKAHEAD(2) [<S>] <N_PIPE> [<S>] tok=<NAME> {
	jjtThis.jjtAppendChild(new SimpleNode(_NAME, tok.image));
    })* [<S>] <N_RPAREN>
    {
	buildDocument(jjtThis, _NOTATION_TYPE);
    }
}

void
Enumeration() : { Token tok; }
{
    <A_LPAREN> [<S>] tok=<NMTOKEN> {
	jjtThis.jjtAppendChild(new SimpleNode(_NMTOKEN, tok.image));
    } (LOOKAHEAD(2) [<S>] <A_PIPE> [<S>] tok=<NMTOKEN> {
	jjtThis.jjtAppendChild(new SimpleNode(_NMTOKEN, tok.image));
    })* [<S>] <A_RPAREN>
    {
	buildDocument(jjtThis, _ENUMERATION);
    }
}

void
EntityDecl() : {}
{
    (LOOKAHEAD(3) GEDecl() | LOOKAHEAD(3) PEDecl())
    {
	buildDocument(jjtThis, _ENTITY_DECL);
    }
}

void
GEDecl() : { Token tok; }
{
    <ENTITY> <S> tok=<NAME> <S> EntityDef(tok.image) [<S>] <TAG_END>
    {
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _GE_DECL);
    }
}

void
PEDecl() : { Token tok; }
{
    <ENTITY> <S> <N_PCT> <S> tok=<NAME> <S> PEDef(tok.image) [<S>] <TAG_END>
    {
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _PE_DECL);
    }
}

void
EntityDef(String name) #void : {}
{
    (EntityValue(name, false) | (ExternalID(name, false, false) [LOOKAHEAD(2) NDataDecl()]))
}

void
PEDef(String name) #void : {}
{
    (EntityValue(name, true) | ExternalID(name, true, false))
}

void
EntityValue(String name, boolean isPERef) : {
    Token tok, dq_tok = null, sq_tok = null;
}
{
    ( dq_tok=<DQ_ENTVAL> | sq_tok=<SQ_ENTVAL> )
    {
	tok = dq_tok == null ? sq_tok : dq_tok;
	if (!token_source.putRef(name,tok.image,isPERef)) {
	    if (isPERef)
		abort("XML validation error: parameter entity name (" + name + ") already in use");
	    else
		abort("XML validation error: general entity name (" + name + ") already in use");
	}
	buildDocument(jjtThis, _ENTITY_VALUE, tok);
    }
}

void
NDataDecl() : { Token tok; }
{
    (<S> <NDATA> <S> tok=<NAME>)
    {
	buildDocument(jjtThis, _NDATA_DECL, tok);
    }
}

void
NotationDecl() : { Token tok; }
{
    (<NOTATION> <S> tok=<NAME> <S> (LOOKAHEAD(HitExternalID()) ExternalID(null, false, false) | PublicID()) [<S>] <TAG_END>)
    {
	jjtThis.jjtAppendChild(new SimpleNode(_NAME, tok.image));
	buildDocument(jjtThis, _NOTATION_DECL);
    }
}

void
PublicID() : { Token tok; }
{
    (<PUBLIC> <S> tok=<PUBLIT>)
    {
	buildDocument(jjtThis, _PUBLIC_ID, tok);
    }
}

void
Body() : {}
{
    // body is used just to distinguish the topmost element
    Element(true)
    {
	buildDocument(jjtThis, _BODY);
    }
}

void
Element(boolean topmost) #void : {}
{
    (LOOKAHEAD(HitEmptyElemTag()) EmptyElemTag(topmost) | LOOKAHEAD(HitBlock()) Block(topmost))
}

void
Block(boolean topmost) : { String headname, tailname; }
{
    (headname=STag(topmost) Content() tailname=ETag())
    {
	if (!headname.equalsIgnoreCase(tailname))
	    abort("XML validation error: block name mismatch (" + headname + "!=" + tailname + ")");
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, headname), 0);
	buildDocument(jjtThis, _BLOCK);
    }
}

void
EmptyElemTag(boolean topmost) : { Token tok; }
{
    (<TAG_BGN> tok=<NAME> (LOOKAHEAD(2) <S> Attribute())* [<S>] <ETAG_END>)
    {
	if (topmost && doctype_name != null && !tok.image.equalsIgnoreCase(doctype_name))
	    abort("XML validation error: top tag name does not match DTD (" + tok.image + "!=" + doctype_name + ")");
	jjtThis.jjtInsertChild(new SimpleNode(_NAME, tok.image), 0);
	buildDocument(jjtThis, _NOBLOCK);
    }
}

void
Attribute() : { Token name, value; }
{
    (name=<ATTRNAME> <EQ> value=AttrVal())
    {
	jjtThis.jjtAppendChild(new SimpleNode(_NAME, name.image));
	jjtThis.jjtAppendChild(new SimpleNode(_VALUE, value.image));
	buildDocument(jjtThis, _ATTRIBUTE);
    }
}

Token
AttrVal() #void : { Token tok1=null, tok2=null, tok3=null; }
{
    (tok1=<ATTRVAL>|tok2=<DQ_ATTRVAL>|tok3=<SQ_ATTRVAL>)
	{
	    return(tok1 != null ? tok1 : (tok2 != null ? tok2 : tok3));
	}
}

String
STag(boolean topmost) #void : { Token tok; }
{
    (<TAG_BGN> tok=<NAME> (LOOKAHEAD(2) <S> Attribute())* [<S>] <TAG_END>)
    {
	if (topmost && doctype_name != null && !tok.image.equalsIgnoreCase(doctype_name))
	    abort("XML validation error: top block name does not match DTD (" + tok.image + "!=" + doctype_name + ")");
	return(tok.image);
    }
}

void
Content() : {}
{
    ([CharData()] ((Element(false) | Reference() | CDSect() | ProcInst() | Comment()) [CharData()])*)
    {
	int nbr;

	if ((nbr = jjtThis.jjtGetNumChildren()) > 0) {
	    // consolidate consecutive CHARDATA children
	    SimpleNode node, prev = null;
	    int i,j;
	    for (i=0, j=0; i<nbr; i++) {
		node = jjtThis.getChild(i);
		if (node.type() == _CHARDATA) {
		    if (prev == null) {
			j = i + 1;
			prev = node;
		    } else {
			prev.value[0] = (String)(prev.value[0]) + (String)(node.value[0]);
		    }
		} else {
		    if (prev != null) {
			if (j != i)
			    jjtThis.deleteChildren(j,i);
			prev = null;
			nbr = nbr - (i-j);
		    }
		}
	    }
	    if (prev != null) {
		jjtThis.deleteChildren(j,i);
	    }
	    buildDocument(jjtThis, _CONTENT);
	} else jjtree.popNode();
    }
}

void
CharData() : { Token tok; }
{
    (tok=<CHARDATA>)
    {
	buildCharData(jjtThis, tok);
    }
}

String
ETag() #void : { Token tok; }
{
    (<BTAG_BGN> tok=<NAME> [<S>] <TAG_END>)
    {
	return(tok.image);
    }
}

void
Reference() : { Token tok=null, entref=null, charref=null; }
{
    (entref=<ENTREF>|charref=<CHARREF>)
    {
	tok = (entref == null) ? charref : entref;
	if (tok.image.length() > 0)
	    buildDocument(jjtThis, _CHARDATA, tok);
	else jjtree.popNode();
    }
}

void
CDSect() : { Token tok; }
{
    (<CDSTART> tok=<CDATA>)
    {
	buildCDSect(jjtThis, tok);
    }
}

//
// Syntactic lookahead productions - primarily designed to recognize
// the real production as quickly as possible.
//

void
HitBlock() : {}
{
    (<TAG_BGN> <NAME> (LOOKAHEAD(2) <S> Attribute())* [<S>] <TAG_END>)
}

void
HitChoice() : {}
{
    (<E_LPAREN> | <N_LPAREN>) [<S>] CP() [<S>] <N_PIPE>
}

void
HitEmptyElemTag() : {}
{
    (<TAG_BGN> <NAME> (LOOKAHEAD(2) <S> Attribute())* [<S>] <ETAG_END>)
}

void
HitExternalID() : {}
{
    (<SYSTEM> | (<PUBLIC> <S> <PUBLIT> <S> <SYSLIT>))
}

void
HitMixed() : {}
{
    <E_LPAREN> [<S>] <PCDATA>
}

void
HitSeq() : {}
{
    (<E_LPAREN> | <N_LPAREN>) [<S>] CP() [LOOKAHEAD(2) [<S>] <N_COMMA>]
}

