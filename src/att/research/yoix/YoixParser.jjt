/*
 *  This software may only be used by you under license from AT&T Corp.
 *  ("AT&T").  A copy of AT&T's Source Code Agreement is available at
 *  AT&T's Internet website having the URL:
 *
 *    <http://www.research.att.com/sw/tools/yoix/license/source.html>
 *
 *  If you received this software without first entering into a license
 *  with AT&T, you have an infringing copy of this software and cannot
 *  use it without violating AT&T's intellectual property rights.
 */

//
// Yoix grammar written for WebGain's JavaCC parser generator (Version 1.1).
// Also seems to work with Version 2.0, but we haven't done much testing as
// of 9/10/01.
//

options {
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    FORCE_LA_CHECK = false;

    //
    // Need our own CharStream class for better control when we switch
    // input streams, so these are no longer optional.
    //
    USER_CHAR_STREAM = true;
    JAVA_UNICODE_ESCAPE = false;
}

PARSER_BEGIN(YoixParser)

package att.research.yoix;
import java.io.*;
import java.util.*;

class YoixParser

    implements YoixConstants

{

    private static YoixParserStream  parserstream = null;
    private static boolean           addtags = false;

    //
    // Internal parser stacks - some should be more flexible!!
    //

    private static boolean  commastack[] = new boolean[100];
    private static int      commatop = 0;
    private static int      scopestack[] = new int[100];
    private static int      scopetop = 0;
    private static int      statementstack[] = new int[100];
    private static int      statementtop = -1;
    private static Stack    exprstack = new Stack();

    //
    // This is set when we enter something other than the DEFAULT state
    // and can be used in error messages.
    //

    private static int  lexicalstatestart = -1;

    //
    // Decided to use scopestack to count local variables and remember
    // if we've seen at least one save statement.
    //

    private static final int  LOCALCOUNT = 0xFFFFF;
    private static final int  FORCEBLOCK = 0x100000;
    private static final int  ACCEPTCASE = 0x200000;
    private static final int  ACCEPTDEFAULT = 0x400000;
    private static final int  ACCEPTRESERVED = 0x800000;
    private static final int  BLOCKMASK = (LOCALCOUNT | FORCEBLOCK);
    private static final int  LABELMASK = (ACCEPTCASE | ACCEPTDEFAULT);
    private static final int  NAMEMASK = ACCEPTRESERVED;

    //
    // These are only for operator associativity.
    //

    private static final short  LEFT = -1;
    private static final short  NONE = 0;
    private static final short  RIGHT = 1;

    //
    // The following table could be used as is, but right now all we
    // do with it is build the precedence and associativity arrays.
    // The code that uses this table currently assumes all operators
    // at the same precedence level have the same associativity. In
    // addition, SimpleNodes that don't represent operators are given
    // a precedence (and associativity) that prevents rearrangement,
    // so the code that uses the table can omit some checking.
    //

    private static short  operators[] = {
     //
     // Operator		Precedence	Associativity
     // --------		----------	-------------
	MUL,			14,		LEFT,
	DIV,			14,		LEFT,
	MOD,			14,		LEFT,
	PLUS,			13,		LEFT,
	MINUS,			13,		LEFT,
	LEFTSHIFT,		12,		LEFT,
	RIGHTSHIFT,		12,		LEFT,
	UNSIGNEDSHIFT,		12,		LEFT,
	LT,			11,		LEFT,
	LE,			11,		LEFT,
	GT,			11,		LEFT,
	GE,			11,		LEFT,
	INSTANCEOF,		11,		LEFT,
	EQ,			10,		LEFT,
	NE,			10,		LEFT,
	EQEQ,			10,		LEFT,
	NEEQ,			10,		LEFT,
	EQTILDA,		10,		LEFT,
	NETILDA,		10,		LEFT,
	AND,			9,		LEFT,
	XOR,			8,		LEFT,
	OR,			7,		LEFT,
	LOGICALAND,		6,		LEFT,
	LOGICALXOR,		5,		LEFT,
	LOGICALOR,		4,		LEFT,
	QUESTIONCOLON,          3,              RIGHT,
	ASSIGN,			2,		RIGHT,
	MULEQ,			2,		RIGHT,
	DIVEQ,			2,		RIGHT,
	MODEQ,			2,		RIGHT,
	PLUSEQ,			2,		RIGHT,
	MINUSEQ,		2,		RIGHT,
	LEFTSHIFTEQ,		2,		RIGHT,
	RIGHTSHIFTEQ,		2,		RIGHT,
	UNSIGNEDSHIFTEQ,	2,		RIGHT,
	ANDEQ,			2,		RIGHT,
	XOREQ,			2,		RIGHT,
	OREQ,			2,		RIGHT,
	COMMA,			1,		LEFT,

	CONDITIONAL,		0,		LEFT,
    };

    private static short  precedence[] = new short[LASTTOKEN];
    private static short  associativity[] = new short[LASTTOKEN];

    static {
	for (int n = 0; n < precedence.length; n++) {
	    precedence[n] = (short)LASTTOKEN;	// higher than all operators
	    associativity[n] = NONE;
	}

	for (int n = 0; n < operators.length; n += 3) {
	    precedence[operators[n]] = operators[n+1];
	    associativity[operators[n]] = operators[n+2];
	}

	operators = null;
    }

    ///////////////////////////////////
    //
    // YoixParser Methods
    //
    ///////////////////////////////////

    static int
    getAssociativity(int op, int left, int none, int right) {

	int  value = none;

	if ((op >= 0 && op < associativity.length)) {
	    switch (associativity[op]) {
		case LEFT:
		    value = left;
		    break;

		case NONE:
		    value = none;
		    break;

		case RIGHT:
		    value = right;
		    break;
	    }
	}
	return(value);
    }


    static int
    getPrecedence(int op) {

	return((op >= 0 && op < precedence.length) ? precedence[op] : LASTTOKEN);
    }

    ///////////////////////////////////
    //
    // Private Methods
    //
    ///////////////////////////////////

    private static YoixObject
    abort(String error) {

	String  text;
	int     line;
	int     column;
	int     n;

	//
	// Currently only gives special treatment to INVALIDASSIGNMENT, so
	// you have to add code if you decide to support other errors that
	// need thei own attention.
	//

	if (error == INVALIDASSIGNMENT) {
	    if (token != null && parserstream.haveLine(token.beginLine)) {
		line = token.beginLine;
		column = token.beginColumn;
	    } else {
		line = parserstream.getBeginLine();
		column = parserstream.getBeginColumn();
	    }

	    if ((text = parserstream.getBufferedLine(line)) != null) {
		for (n = Math.min(column - 1, text.length() - 1); n >= 0; n--) {
		    if (text.charAt(n) == '=') {
			column = n + 1;
			break;
		    }
		}
	    }
	} else {
	    line = parserstream.getBeginLine();
	    column = parserstream.getBeginColumn();
	}

	return(abortHandler(error, line, column, -1, null, true, new ArrayList()));
    }


    private static YoixObject
    abort(ParseException e) {

	ArrayList  args = new ArrayList();
	String     text;
	String     extra = null;
	int        line;
	int        column;

	if (e != null && e.currentToken != null) {
	    line = e.currentToken.next.beginLine;
	    column = e.currentToken.next.beginColumn;

	    if ((text = parserstream.getEncounteredToken(e)) != null) {
		args.add("Encountered");
		args.add(text);
	    }

	    if ((text = parserstream.getExpectedToken(e)) != null) {
		args.add("Expected");
		args.add(text);
	    }

	    if (VM.bitCheck(N_DEBUG, DEBUG_SYNTAXERROR))
		extra = parserstream.getExpectedTokens(e);
	} else {		// should be unnecessary - later
	    line = parserstream.getBeginLine();
	    column = parserstream.getBeginColumn();
	}

	return(abortHandler(SYNTAXERROR, line, column, -1, extra, true, args));
    }


    private static YoixObject
    abort(TokenMgrError e) {

	String  error;
	int     startline;
	int     line;
	int     column;

	line = parserstream.getLine();
	column = -1;
	startline = 0;

	switch (YoixParserTokenManager.curLexState) {
	    case STATE_MULTILINE_STRING:
	    case STATE_MULTILINE_ESCAPED_STRING:
		error = UNCLOSEDSTRING;
		if (lexicalstatestart > 0 && line != lexicalstatestart)
		    startline = lexicalstatestart;
		break;

	    case STATE_CSTYLE:
	    case STATE_CPLUS:
		error = UNCLOSEDCOMMENT;
		if (lexicalstatestart > 0 && line != lexicalstatestart)
		    startline = lexicalstatestart;
		break;

	    default:		// these probably shouldn't happen
		error = SCANNERERROR;
		startline = -1;
		break;
	}

	return(abortHandler(error, line, column, startline, null, false, new ArrayList()));
    }


    private static YoixObject
    abortHandler(String error, int line, int column, int startline, String extra, boolean recover, ArrayList args) {

	String  text;
	String  prefix;
	Token   tok;
	int     n;

	//
	// Eventually could encode more in the ParseException that's handed
	// to VM.abort(), but right now the starting line is all we need. If
	// the message in the ParseException changes you will also have to
	// update methods in YoixError.java that examine ParseExceptions.
	//
	// Notice that we only set startline if it's initially negative and
	// we're working on a statement, but if you look at where we use it
	// you'll see that we only pass it along (as the message in a new
	// ParseException) if it's positive and doesn't match line.
	//

	if (startline < 0 && statementtop >= 0)
	    startline = statementstack[statementtop];

	if (parserstream.haveLine(line)) {
	    prefix = line + "";
	    for (n = Math.min(ABORTERROR.length(), 5) - prefix.length(); n > 0; n--)
		prefix = " " + prefix;
	    prefix += ": ";
	} else prefix = null;

	if ((text = parserstream.getMarkedLine(line, column, prefix, true)) != null) {
	    args.add(NL);
	    args.add(text);
	    column = -1;
	}

	if (extra != null) {
	    args.add(NL);
	    args.add(extra);
	}

	if (recover) {
	    do {
		tok = getNextToken();
	    } while (tok.kind != SEMICOLON && tok.kind != EOF);
	}

	VM.pushTag(line, column, parserstream.getName());
	return(VM.abort(error, args, new ParseException((startline > 0 && line != startline) ? startline + "": null)));
    }


    private static void
    arrangeBinary() {

	SimpleNode  operand;
	SimpleNode  operator;
	SimpleNode  next;
	int         prec1;
	int         prec2;
	int         type1;
	int         type2;

	//
	// Important method that uses the precedence[] and associativity[]
	// tables to rearrange the expression the parser has collected right
	// after a binary expression is recognized.
	//

	operand = (SimpleNode)jjtree.popNode();
	operator = (SimpleNode)jjtree.popNode();

	type1 = operator.type();
	type2 = ((SimpleNode)jjtree.peekNode()).type();
	prec1 = precedence[type1];
	prec2 = precedence[type2];

	while (prec1 > prec2 || (prec1 == prec2 && associativity[type2] == RIGHT)) {
	    next = (SimpleNode)jjtree.popNode();
	    if (next.type() == CONDITIONAL)
		unroll(next.getChild0());
	    else exprstack.push(next);
	    type2 = ((SimpleNode)jjtree.peekNode()).type();
	    prec2 = precedence[type2];
	}

	if (prec1 == precedence[ASSIGN] && type2 != LVALUE)
	    abort(INVALIDASSIGNMENT);

	//
	// For consistency, but moving operator and operand to execstack
	// is currently only needed by LOGICALAND and LOGICALOR.
	//

	exprstack.push(operator);
	exprstack.push(operand);

	while (exprstack.size() > 0) {
	    next = (SimpleNode)exprstack.pop();
	    switch (next.type()) {
		case LOGICALAND:
		case LOGICALOR:
		    jjtree.pushNode(new SimpleNode(CONDITIONAL, collectExpression()));
		    break;
	    }
	    jjtree.pushNode(next);
	}
    }


    private static void
    arrangeTernary() {

	SimpleNode  operator;
	SimpleNode  left;
	SimpleNode  right;
	SimpleNode  node;
	SimpleNode  expr;
	int         type1;
	int         type2;
	int         prec1;
	int         prec2;

	//
	// Important method that uses the precedence[] table to rearrange
	// the expression the parser has collected right after a ternary
	// expression (i.e., ?:) is recognized.
	//

	right = (SimpleNode)jjtree.popNode();
	left = (SimpleNode)jjtree.popNode();
	operator = (SimpleNode)jjtree.popNode();

	type1 = operator.type();	// currently must be QUESTIONCOLON
	prec1 = precedence[type1];
	type2 = ((SimpleNode)jjtree.peekNode()).type();
	prec2 = precedence[type2];

	while (prec1 > prec2) {
	    exprstack.push((SimpleNode)jjtree.popNode());
	    type2 = ((SimpleNode)jjtree.peekNode()).type();
	    prec2 = precedence[type2];
	}

	expr = collectExpression();
	node = new SimpleNode(type1);
	node.jjtAppendChild(expr);
	node.jjtAppendChild(left);
	node.jjtAppendChild(right);
	jjtree.pushNode(node);

	while (exprstack.size() > 0)
	    jjtree.pushNode((SimpleNode)exprstack.pop());
    }


    private static void
    backup(SimpleNode node) {

	Token  tok;

	//
	// This is only used to put parserstream back in a state that
	// is ready for the next parseStatement() call. Lookahead used
	// to recognize an "else" but not officially consumed belongs
	// to next statement and must be returned to the input stream.
	// If this step is omitted a trivial program like
	//
	//		if (1)
	//		    xxx = 10;
	//		yyy = 100;
	//
	// gets a syntaxerror. Small chance other statements will need
	// the same kind of help.
	//

	switch (node.getTaggedNode().type()) {
	    case IF:
		do {
		    if (node.getTaggedNode().length() == 2) {	// no else - restore lookahead
			if ((tok = getToken(1)) != null)
			    parserstream.backup(tok.image.length());
			break;
		    } else if (node.getTaggedNode().length() == 3) {	// always true?
			//
			// Could be "else", "else { }", which are harmless,
			// or "else if ..." with the "if" putting us back
			// where we started, so we descend down to find
			// out.
			//
			node = node.getTaggedNode().getChild2();
		    }
		} while (node.getTaggedNode().type() == IF);
		break;

	    default:
		break;
	}
    }


    private static void
    buildAttribute(int kind) {

	SimpleNode  node;

	node = new SimpleNode(ATTRIBUTE);
	node.jjtAppendChild((SimpleNode)jjtree.popNode());
	node.jjtAppendChild(YoixObject.newInt(kind));
	jjtree.pushNode(node);
    }


    private static void
    buildCast() {

	SimpleNode  expr;
	SimpleNode  node;

	expr = (SimpleNode)jjtree.popNode();
	buildExpression(expr, false);
	node = new SimpleNode(EXPRESSION);
	node.jjtAppendChild(expr);
	node.jjtAppendChild(new SimpleNode(CAST));
	jjtree.pushNode(node);
    }


    private static void
    buildDeclarator(SimpleNode node) {

	node.setType(DECLARATOR);
	scopestack[scopetop]++;
    }


    private static void
    buildExpression(SimpleNode node, boolean exchange) {

	Node  tmp;
	int   n;

	node.setType(EXPRESSION);

	//
	// Next few lines are a recent addition that seems to eliminate
	// unnecessary expression nodes. Needs to be carefully tested!!
	//
	if (node.length() == 1 && node.getChild0().type() == EXPRESSION)
	    node.value = ((SimpleNode)node.getChild0().clone()).value;

	if (exchange) {
	    if ((n = node.length() - 1) > 0) {
		tmp = node.getChild(n);
		node.jjtAddChild(node.getChild(n - 1), n);
		node.jjtAddChild(tmp, n - 1);
	    }
	}
    }


    private static void
    buildIndex(SimpleNode node) {

	int  children = node.jjtGetNumChildren();

	if (children > 0) {
	    if (children > 1 || token.kind == DOTDOTDOT)
		node.setType(RANGE);
	    else unrollTop();
	} else node.setType(RANGE);
    }


    private static void
    buildOptional(SimpleNode node) {

	if (node.jjtGetNumChildren() > 0)
	    unrollTop();
	else node.setType(EXPRESSION);
    }


    private static void
    buildParameterList(SimpleNode node) {

	node.setType(token.kind != DOTDOTDOT ? ARGLIST : VARARGLIST);
    }


    private static void
    buildPrimaryLvalue(int type) {

	switch (type) {
	    case GLOBAL:
	    case THIS:
		jjtree.pushNode(new SimpleNode(type));
		break;

	    case LVALUE:
		unrollTop();
		break;
	}
    }


    private static void
    buildStatement(SimpleNode node, int type) {

	node.setType(type);

	switch (type) {
	    case COMPOUND:
		unrollTop();
		if (((SimpleNode)jjtree.peekNode()).length() == 0)
		    ((SimpleNode)jjtree.peekNode()).setType(EMPTY);
		break;

	    case DEFAULT_:
		scopestack[scopetop] &= ~ACCEPTDEFAULT;
		break;

	    case EOF:
		validateEOF();
		node.setType(YOIX_EOF);
		break;

	    case FINALLY:
	    case SAVE:
		scopestack[scopetop] |= FORCEBLOCK;
		tagTop();
		break;

	    case FUNCTION:
		scopestack[scopetop]++;
		tagTop();
		break;

	    case IMPORT:
		tagTop();
		break;

	    case SWITCH:
		node.jjtAppendChild(YoixObject.newNull());
		tagTop();
		break;

	    default:
		tagTop();
		break;
	}
	closeStatement();
    }


    private static void
    closeExpression() {

	commatop--;
    }


    static void
    closeLexicalState() {

	lexicalstatestart = -1;
    }


    private static void
    closeScope(SimpleNode node) {

	int  count;

	if ((count = scopestack[scopetop--]&BLOCKMASK) != 0) {
	    node.setType(COMPOUND);
	    jjtree.pushNode(YoixObject.newInt(count&LOCALCOUNT));
	} else node.setType(STATEMENT);
    }


    private static void
    closeStatement() {

	statementtop--;
    }


    private static SimpleNode
    collectExpression() {

	SimpleNode  node;
	SimpleNode  arg;
	int         type;
	int         count;
	int         n;

	//
	// Eventually may want a better way to quickly recognize binary
	// operators.
	//

	for (n = 1, count = 0; n > 0; n--, count++) {
	    arg = (SimpleNode)jjtree.popNode();
	    exprstack.push(arg);
	    switch (type = arg.type()) {
		case CONDITIONAL:
		case QUESTIONCOLON:
		    break;

		default:
		    if (precedence[type] < LASTTOKEN)	// it's a binary operator??
			n += 2;
		    break;
	    }
	}

	node = new SimpleNode(EXPRESSION, count);
	for (n = 0; n < count; n++)
	    node.jjtAddChild((SimpleNode)exprstack.pop(), n);

	return(node);
    }


    private static void
    openExpression(boolean commas) {

	commastack[++commatop] = commas;
    }


    static void
    openLexicalState() {

	lexicalstatestart = parserstream.getLine();
    }


    private static void
    openScope(int mask) {

	scopestack[++scopetop] = mask;
    }


    private static void
    openStatement() {

	Token  nexttoken;
	int    line = -1;

	//
	// This is supposed to help make sure the line numbers in error
	// messages point to the start of the statement rather than to
	// the last token consumed by the statement.
	//

	try {
	    if ((nexttoken = getToken(1)) != null)
		line = nexttoken.beginLine;
	}
	catch (Throwable t) {}
	statementstack[++statementtop] = line;
    }


    private static void
    reset(YoixParserStream stream, boolean tags) {

	stream.setParent(parserstream);
	parserstream = stream;
	ReInit(parserstream);

	addtags = tags;
	commastack[0] = true;
	commatop = 0;
	scopestack[0] = 0;
	scopetop = 0;
	statementtop = -1;
	lexicalstatestart = -1;
	exprstack.removeAllElements();

	token_source.SwitchTo(DEFAULT);
    }


    private static void
    restore() {

	if (parserstream != null) {
	    parserstream = parserstream.getParent();
	    ReInit(parserstream);
	}
    }


    private static void
    tagTop() {

	SimpleNode  node;
	String      source;
	int         line;

	if (addtags) {
	    node = (SimpleNode)jjtree.popNode();
	    if (statementtop >= 0)
		line = statementstack[statementtop];
	    else line = -1;
	    if (line < 0)
		line = (token != null) ? token.beginLine : parserstream.getBeginLine();
	    source = parserstream.getName();
	    jjtree.pushNode(SimpleNode.newTagged(node, line, source));
	}
    }


    private static void
    unroll(SimpleNode node) {

	int  n;

	for (n = 0; n < node.value.length; n++)
	    jjtree.pushNode((SimpleNode)node.value[n]);
    }


    private static void
    unrollTop() {

	unroll((SimpleNode)jjtree.popNode());
    }


    private static void
    validateEOF() {

	Token  tok;

	//
	// Call the appropriate abort() method when it looks like we're not
	// supposed to accept EOF, otherwise it just returns to the caller.
	// Right now we reject EOF if we're not in the DEFAULT state or if
	// we're already working on a statement.
	//

	if (YoixParserTokenManager.curLexState == DEFAULT) {
	    if (statementtop > 0) {
		tok = new Token();
		tok.kind = 0;
		tok.next = new Token();
		tok.next.kind = 0;
		tok.next.beginLine = parserstream.getLine();
		abort(new ParseException(tok, null, null));
	    }
	} else abort((TokenMgrError)null);
    }
}

PARSER_END(YoixParser)

//
// These tokens are part of the language and are recognized in the input
// stream.
//

TOKEN : {
    <LPAREN: "(">
  | <RPAREN: ")">
  | <LBRACE: "{">
  | <RBRACE: "}">
  | <LBRACKET: "[">
  | <RBRACKET: "]">
  | <COLON: ":">
  | <SEMICOLON: ";">
  | <DOT: ".">
  | <DOTDOTDOT : "...">
  | <DOTSTAR : ".*">
  | <INCREMENT : "++">
  | <DECREMENT : "--">
  | <COMPLEMENT : "~">
  | <NOT : "!">
  | <PLUS : "+">
  | <MINUS : "-">
  | <MUL : "*">
  | <DIV : "/">
  | <MOD : "%">
  | <LEFTSHIFT : "<<">
  | <RIGHTSHIFT : ">>">
  | <UNSIGNEDSHIFT : ">>>">
  | <AND : "&">
  | <XOR : "^">
  | <OR : "|">
  | <LT : "<">
  | <GT : ">">
  | <EQ : "==">
  | <NE : "!=">
  | <EQEQ : "===">
  | <NEEQ : "!==">
  | <EQTILDA : "=~">
  | <NETILDA : "!~">
  | <LE : "<=">
  | <GE : ">=">
  | <INSTANCEOF : "instanceof">
  | <LOGICALAND : "&&">
  | <LOGICALXOR : "^^">
  | <LOGICALOR : "||">
  | <ASSIGN : "=">
  | <PLUSEQ : "+=">
  | <MINUSEQ : "-=">
  | <MULEQ : "*=">
  | <DIVEQ : "/=">
  | <MODEQ : "%=">
  | <LEFTSHIFTEQ : "<<=">
  | <RIGHTSHIFTEQ : ">>=">
  | <UNSIGNEDSHIFTEQ : ">>>=">
  | <ANDEQ : "&=">
  | <XOREQ : "^=">
  | <OREQ : "|=">
  | <COMMA : ",">
  | <QUESTION: "?">
  | <BREAK : "break">
  | <BY : "by">
  | <CASE : "case">
  | <CATCH : "catch">
  | <CONST : "const">
  | <CONTINUE : "continue">
  | <DEFAULT_ : "default">
  | <DO : "do">
  | <ELSE : "else">
  | <EXIT : "exit">
  | <FINAL : "final">
  | <FINALLY : "finally">
  | <FOR : "for">
  | <GLOBAL : "global">
  | <IF : "if">
  | <IMPORT : "import">
  | <IN : "in">
  | <INCLUDE : "include">
  | <NEW : "new">
  | <RESTRICTED : "restricted">
  | <RETURN : "return">
  | <SAVE : "save">
  | <SWITCH : "switch">
  | <SYNCHRONIZED : "synchronized">
  | <THIS : "this">
  | <TRY : "try">
  | <TYPEDEF : "typedef">
  | <WHILE : "while">
}

//
// These are reserved but not currently used.
//

TOKEN : {
    <CLASS : "class">
  | <EXTENDS : "extends">
  | <LOCKED : "locked">
  | <PRIVATE : "private">
  | <PROTECTED : "protected">
  | <PUBLIC : "public">
  | <STATIC : "static">
  | <SUPER : "super">
  | <THROW : "throw">
  | <VOID : "void">
}

//
// Reserved variable names - not allowed in declarations or as function
// parameter names.
//

TOKEN : {
    <RESERVED_ABORT : "abort">
  | <RESERVED_DEFINED : "defined">
  | <RESERVED_EOF : "EOF">
  | <RESERVED_EVAL : "eval">
  | <RESERVED_EXECUTE : "execute">
  | <RESERVED_FALSE : "FALSE">
  | <RESERVED_FALSE2 : "false">
  | <RESERVED_NULL : "NULL">
  | <RESERVED_NULL2 : "null">
  | <RESERVED_STDERR : "stderr">
  | <RESERVED_STDIN : "stdin">
  | <RESERVED_STDOUT : "stdout">
  | <RESERVED_TOSTRING : "toString">
  | <RESERVED_TRUE : "TRUE">
  | <RESERVED_TRUE2 : "true">
  | <RESERVED_UNROLL : "unroll">
  | <RESERVED_YOIX : "yoix">
}

TOKEN : {
    <NAME : <LETTER> (<LETTER>|<DIGIT>)*>
  | <#LETTER : ["a"-"z", "A"-"Z", "_", "$"]>
  | <#DIGIT : ["0"-"9"]>
}

//
// These tokens aren't matched because we never enter <STATE_DUMMY>,
// and some (the entire second group) are only used outside this file,
// but including them all here lets javacc assign unique values.
//

<STATE_DUMMY> TOKEN : {
    <ADDRESS : "ADDRESS">
  | <ARGLIST : "ARGLIST">
  | <ARRAY : "ARRAY">
  | <ATTRIBUTE : "ATTRIBUTE">
  | <BOUND_LVALUE : "BOUND_LVALUE">
  | <CAST : "CAST">
  | <COMPOUND : "COMPOUND">
  | <CONDITIONAL : "CONDITIONAL">
  | <DECLARATION : "DECLARATION">
  | <DECLARATOR : "DECLARATOR">
  | <DICTIONARY : "DICTIONARY">
  | <DVALUE : "DVALUE">
  | <EMPTY : "EMPTY">
  | <EXPRESSION : "EXPRESSION">
  | <FOREACH : "FOREACH">
  | <FUNCTION : "FUNCTION">
  | <GLOBALBLOCK : "GLOBALBLOCK">
  | <INDIRECTION : "INDIRECTION">
  | <LVALUE : "LVALUE">
  | <NAMEDBLOCK : "NAMEDBLOCK">
  | <POSTDECREMENT : "POSTDECREMENT">
  | <POSTINCREMENT : "POSTINCREMENT">
  | <PREDECREMENT : "PREDECREMENT">
  | <PREINCREMENT : "PREINCREMENT">
  | <QUALIFIER : "QUALIFIER">
  | <QUESTIONCOLON: "?:">
  | <RANGE : "RANGE">
  | <RESTRICTEDBLOCK : "RESTRICTEDBLOCK">
  | <STATEMENT : "STATEMENT">
  | <THISBLOCK : "THISBLOCK">
  | <UMINUS : "UMINUS">
  | <UPLUS : "UPLUS">
  | <VARARGLIST : "VARARGLIST">
}

<STATE_DUMMY> TOKEN : {
    <ACCESS : "ACCESS">
  | <AUDIOCLIP : "AUDIOCLIP">
  | <BLOCK : "BLOCK">
  | <BUILTIN : "BUILTIN">
  | <BUTTON : "BUTTON">
  | <CALENDAR : "CALENDAR">
  | <CALLABLE : "CALLABLE">
  | <CANVAS : "CANVAS">
  | <CERTIFICATE : "CERTIFICATE">
  | <CHECKBOX : "CHECKBOX">
  | <CHECKBOXGROUP : "CHECKBOXGROUP">
  | <CHOICE : "CHOICE">
  | <CIPHER : "CIPHER">
  | <CLIPBOARD : "CLIPBOARD">
  | <COMPILER : "COMPILER">
  | <COMPONENT : "COMPONENT">
  | <CONTROL : "CONTROL">
  | <DATAGRAMSOCKET : "DATAGRAMSOCKET">
  | <DIALOG : "DIALOG">
  | <DOUBLE : "DOUBLE">
  | <EDGE : "EDGE">
  | <ELEMENT : "ELEMENT">
  | <ERROR : "ERROR">
  | <FILE : "FILE">
  | <FILEDIALOG : "FILEDIALOG">
  | <FONT : "FONT">
  | <FRAME : "FRAME">
  | <GRAPH : "GRAPH">
  | <GRAPHICS : "GRAPHICS">
  | <GRAPHOBSERVER : "GRAPHOBSERVER">
  | <HASHTABLE : "HASHTABLE">
  | <IMAGE : "IMAGE">
  | <INTEGER : "INTEGER">
  | <INTERRUPT : "INTERRUPT">
  | <JUMP : "JUMP">
  | <KEY : "KEY">
  | <KEYSTORE : "KEYSTORE">
  | <LABEL : "LABEL">
  | <LIST : "LIST">
  | <LOCALE : "LOCALE">
  | <MARK : "MARK">
  | <MATRIX : "MATRIX">
  | <MENUBAR : "MENUBAR">
  | <MULTICASTSOCKET : "MULTICASTSOCKET">
  | <NODE : "NODE">
  | <NULL : "NULL">
  | <NUMBER : "NUMBER">
  | <OBJECT : "OBJECT">
  | <OPTION : "OPTION">
  | <PANEL : "PANEL">
  | <PARSETREE : "PARSETREE">
  | <POINTER : "POINTER">
  | <POPUPMENU : "POPUPMENU">
  | <PROCESS : "PROCESS">
  | <RANDOM : "RANDOM">
  | <REGEXP : "REGEXP">
  | <RESTORE : "RESTORE">
  | <SCREEN : "SCREEN">
  | <SCROLLBAR : "SCROLLBAR">
  | <SCROLLPANE : "SCROLLPANE">
  | <SECURITYMANAGER : "SECURITYMANAGER">
  | <SERVERSOCKET : "SERVERSOCKET">
  | <SOCKET : "SOCKET">
  | <STREAM : "STREAM">
  | <STRING : "STRING">
  | <STRINGSTREAM : "STRINGSTREAM">
  | <SUBEXP : "SUBEXP">
  | <TABLECOLUMN : "TABLECOLUMN">
  | <TABLEMANAGER: "TABLEMANAGER">
  | <TAG : "TAG">
  | <TAGGED : "TAGGED">
  | <TEXTAREA : "TEXTAREA">
  | <TEXTCANVAS : "TEXTCANVAS">
  | <TEXTFIELD : "TEXTFIELD">
  | <TEXTTERM : "TEXTTERM">
  | <THREAD : "THREAD">
  | <TIMEZONE : "TIMEZONE">
  | <URL : "URL">
  | <VECTOR : "VECTOR">
  | <WINDOW : "WINDOW">
  | <ZIP : "ZIP">
  | <ZIPENTRY : "ZIPENTRY">
}

<STATE_DUMMY> TOKEN : {
    <BUTTONGROUP : "BUTTONGROUP">
  | <COOKIEMANAGER : "COOKIEMANAGER">
  | <JBUTTON : "JBUTTON">
  | <JCANVAS : "JCANVAS">
  | <JCOLORCHOOSER : "JCOLORCHOOSER">
  | <JCOMBOBOX : "JCOMBOBOX">
  | <JCOMPONENT : "JCOMPONENT">
  | <JDESKTOPPANE : "JDESKTOPPANE">
  | <JDIALOG : "JDIALOG">
  | <JFILECHOOSER : "JFILECHOOSER">
  | <JFILEDIALOG : "JFILEDIALOG">
  | <JFRAME : "JFRAME">
  | <JINTERNALFRAME : "JINTERNALFRAME">
  | <JLABEL : "JLABEL">
  | <JLAYEREDPANE : "JLAYEREDPANE">
  | <JLIST : "JLIST">
  | <JMENU : "JMENU">
  | <JMENUBAR : "JMENUBAR">
  | <JMENUITEM : "JMENUITEM">
  | <JPANEL : "JPANEL">
  | <JPASSWORDFIELD : "JPASSWORDFIELD">
  | <JPOPUPMENU: "JPOPUPMENU">
  | <JPROGRESSBAR : "JPROGRESSBAR">
  | <JSCROLLBAR : "JSCROLLBAR">
  | <JSCROLLPANE : "JSCROLLPANE">
  | <JSEPARATOR : "JSEPARATOR">
  | <JSLIDER : "JSLIDER">
  | <JSPLITPANE : "JSPLITPANE">
  | <JTABBEDPANE : "JTABBEDPANE">
  | <JTABLE : "JTABLE">
  | <JTEXTAREA : "JTEXTAREA">
  | <JTEXTCANVAS : "JTEXTCANVAS">
  | <JTEXTFIELD : "JTEXTFIELD">
  | <JTEXTPANE : "JTEXTPANE">
  | <JTEXTTERM : "JTEXTTERM">
  | <JTOOLBAR : "JTOOLBAR">
  | <JTREE : "JTREE">
  | <JWINDOW : "JWINDOW">
  | <PATH : "PATH">
  | <TRANSFERHANDLER : "TRANSFERHANDLER">
  | <UIMANAGER : "UIMANAGER">
}

//
// Object attributes - currently only for lvalues.
//

TOKEN : {"@" : STATE_ATTRIBUTE}

<STATE_ATTRIBUTE> TOKEN : {
    <ATTRIBUTE_ACCESS : "access"> : DEFAULT
  | <ATTRIBUTE_GROWABLE : "growable"> : DEFAULT
  | <ATTRIBUTE_LENGTH : "length"> : DEFAULT
  | <ATTRIBUTE_MAJOR : "major"> : DEFAULT
  | <ATTRIBUTE_MINOR : "minor"> : DEFAULT
  | <ATTRIBUTE_NAMEOF : "nameof"> : DEFAULT
  | <ATTRIBUTE_OFFSET : "offset"> : DEFAULT
  | <ATTRIBUTE_SIZEOF : "sizeof"> : DEFAULT
  | <ATTRIBUTE_TYPENAME : "typename"> : DEFAULT
}

<STATE_ATTRIBUTE> SKIP : {" " | "\t" | "\n" | "\r" | "\f"}
<STATE_ATTRIBUTE> TOKEN : {<ATTRIBUTE_UNMATCHED : ~[]> : DEFAULT}

//
// Literals
//

TOKEN : {
    <LITERAL_INTEGER :
	["1"-"9"] (["0"-"9"])*
      | "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+
      | "0" (["0"-"7"])*
    >
}

TOKEN : {
    <LITERAL_DOUBLE :
	(["0"-"9"])+ "." (["0"-"9"])* (["e","E"] (["+","-"])? (["0"-"9"])+)?
      | (".")? (["0"-"9"])+ (["e","E"] (["+","-"])? (["0"-"9"])+)?
    >
}

TOKEN : {
    <LITERAL_CHARACTER :
	"'" (
	    ~["'","\\","\n","\r"]
	  | "\\" ~["x","\n","\r"]
	  | "\\x" ["0"-"9","a"-"f","A"-"F"]
	)* "'"
    >
}

TOKEN : {
    <LITERAL_STRING :
	"\"" (
	    ~["\"","\\","\n","\r"]
	  | "\\" ~["x","\r"]
	  | "\\x" ["0"-"9","a"-"f","A"-"F"]
	  | "\\\r\n"
	)* "\""

      | "0x\"" (
	    ["0"-"9","a"-"f","A"-"F"]
	  | [" ","\t","\n","\r"]
	)* "\""
    >
}

MORE : {
    "@<<" {YoixParser.openLexicalState();} :  STATE_MULTILINE_STRING
}

<STATE_MULTILINE_STRING> TOKEN: {
    <LITERAL_MULTILINE_STRING : ">>@"> {YoixParser.closeLexicalState();} : DEFAULT
}

<STATE_MULTILINE_STRING> MORE :
{
  <~[]>
}

MORE : {
    "@<" {YoixParser.openLexicalState();} :  STATE_MULTILINE_ESCAPED_STRING
}

<STATE_MULTILINE_ESCAPED_STRING> TOKEN: {
    <LITERAL_MULTILINE_ESCAPED_STRING : ">@"> {YoixParser.closeLexicalState();} : DEFAULT
}

<STATE_MULTILINE_ESCAPED_STRING> MORE :
{
  <~[]>
}

TOKEN : {
    <LITERAL_REGEXP :
	"#" (
	    ~["#","\\","\n","\r"]
	  | "\\" ~["x","\r"]
	  | "\\x" ["0"-"9","a"-"f","A"-"F"]
	  | "\\\r\n"
	)+ "#"
    >
}

//
// White space and comments
//

SKIP : {" " | "\t" | "\n" | "\r" | "\f"}

MORE : {"/*" {YoixParser.openLexicalState();} : STATE_CSTYLE}
<STATE_CSTYLE> SPECIAL_TOKEN : {"*/" {YoixParser.closeLexicalState();} : DEFAULT}
<STATE_CSTYLE> MORE : {<~[]>}

MORE : {"//" {YoixParser.openLexicalState();} : STATE_CPLUS}
<STATE_CPLUS> SPECIAL_TOKEN : {<"\n" | "\r" | "\r\n"> {YoixParser.closeLexicalState();} : DEFAULT}
<STATE_CPLUS> MORE : {<~[]>}

//
// Everything else, so we get errors from the parser instead of the
// token manager.
//

TOKEN : {<UNMATCHEDTOKEN : ~[]>}

//
// Last token number assigned by the parser.
//

<STATE_DUMMY> TOKEN : {<LASTTOKEN : "LASTTOKEN">}

//
// Currently the only entry point.
//

SimpleNode
parseStatement(YoixParserStream stream, boolean tags) #void : {reset(stream, tags);}
{
    try {
	Statement()
	{
	    if (VM.bitCheck(N_DEBUG, DEBUG_PARSETREE))
		VM.print(N_STDOUT, ((SimpleNode)jjtree.peekNode()).dump(PARSER_YOIX));
	    backup((SimpleNode)jjtree.peekNode());
	    return((SimpleNode)jjtree.popNode());
	}
    }
    catch(ParseException e) {
	return(abort(e));
    }
    catch(TokenMgrError e) {

	//
	// We should only get here in unusual circumstances, like a C-style
	// comment or multi-line string that wasn't closed while we were in
	// the middle of parsing a statement. Anyway this one is unusual but
	// it can occasionally happen. We leave it to the abort() defined in
	// this class to handle things.
	//
	// NOTE - our old implementation died here, be now we just abort().
	// Seems reasonable, but not 100% convinced about the change.
	//

	return(abort(e));
    }
    finally {
	restore();
    }
}

//
// Statements
//

void
Statement() : {openStatement();}
{
    <BREAK> ";"
    {
	buildStatement(jjtThis, BREAK);
    }
  | <CONTINUE> ";"
    {
	buildStatement(jjtThis, CONTINUE);
    }
  | <DO> Statement() <WHILE> Expression() ";"
    {
	buildStatement(jjtThis, DO);
    }
  | <EXIT> Optional() ";"
    {
	buildStatement(jjtThis, EXIT);
    }
  | <FINALLY> Compound(0)
    {
	buildStatement(jjtThis, FINALLY);
    }
  | LOOKAHEAD(HitForEach()) <FOR> "(" Name() <IN> Expression() (LOOKAHEAD(1) <BY> Expression())? ")" Statement()
    {
	buildStatement(jjtThis, FOREACH);
    }
  | <FOR> "(" Optional() ";" Optional() ";" Optional() ")" Statement()
    {
	buildStatement(jjtThis, FOR);
    }
  | <IF> "(" Expression() ")" Statement() (LOOKAHEAD(1) <ELSE> Statement())?
    {
	buildStatement(jjtThis, IF);
    }
  | <IMPORT> Import() ";"
    {
	buildStatement(jjtThis, IMPORT);
    }
  | <INCLUDE> Expression() ";"
    {
	buildStatement(jjtThis, INCLUDE);
    }
  | <RETURN> Optional() ";"
    {
	buildStatement(jjtThis, RETURN);
    }
  | <SAVE> Lvalue() ("=" Expression())? ";"
    {
	buildStatement(jjtThis, SAVE);
    }
  | <SWITCH> (Expression()) Compound(LABELMASK)
    {
	buildStatement(jjtThis, SWITCH);
    }
  | <SYNCHRONIZED> "(" Expression() ")" Statement()
    {
	buildStatement(jjtThis, SYNCHRONIZED);
    }
  | <TRY> Compound(0) <CATCH> "(" Parameter() ")" Compound(0)
    {
	buildStatement(jjtThis, TRY);
    }
  | <TYPEDEF> Name() "(" ParameterList() ")" Compound(0)
    {
	buildStatement(jjtThis, TYPEDEF);
    }
  | <WHILE> "(" Expression() ")" Statement()
    {
	buildStatement(jjtThis, WHILE);
    }
  | LOOKAHEAD(HitCase()) <CASE> CaseExpression() ":"
    {
	buildStatement(jjtThis, CASE);
    }
  | LOOKAHEAD(HitDefault()) <DEFAULT_> ":"
    {
	buildStatement(jjtThis, DEFAULT_);
    }
  | LOOKAHEAD(HitDeclaration()) Declaration() ";"
    {
	buildStatement(jjtThis, DECLARATION);
    }
  | LOOKAHEAD(HitFunctionDefine()) FunctionDefine()
    {
	buildStatement(jjtThis, FUNCTION);
    }
  | LOOKAHEAD(HitNamedBlock()) Lvalue() "{" (Statement())* "}"
    {
	buildStatement(jjtThis, NAMEDBLOCK);
    }
  | LOOKAHEAD(HitThisBlock()) <THIS> Lvalue() "{" (Statement())* "}"
    {
	buildStatement(jjtThis, THISBLOCK);
    }
  | LOOKAHEAD(HitGlobalBlock()) <GLOBAL> (Lvalue())? "{" (Statement())* "}"
    {
	buildStatement(jjtThis, GLOBALBLOCK);
    }
  | <RESTRICTED> (Lvalue())? "{" (Statement())* "}"
    {
	buildStatement(jjtThis, RESTRICTEDBLOCK);
    }
  | Expression() ";"
    {
	buildStatement(jjtThis, EXPRESSION);
    }
  | Compound(0)
    {
	buildStatement(jjtThis, COMPOUND);
    }
  | Qualifier() Lvalue() ("=" Expression())? ";"
    {
	buildStatement(jjtThis, QUALIFIER);
    }
  | ";"
    {
	buildStatement(jjtThis, EMPTY);
    }
  | LOOKAHEAD({scopetop == 0}) <EOF>
    {
	buildStatement(jjtThis, EOF);
    }
}

void
Compound(int mask) : {}
{
    "{" {openScope(mask);} (Statement())* {closeScope(jjtThis);} "}"
}

//
// Expressions
//

void
Expression() : {}
{
    UnaryExpression() (LOOKAHEAD(2) (
	BinaryOperator() UnaryExpression()
	{
	    arrangeBinary();
	}
      | InstanceofOperator() Name()
	{
	    arrangeBinary();
	}
      | TernaryOperator() Expression() <COLON> Expression()
	{
	    arrangeTernary();
	}
    ))*
    {
	buildExpression(jjtThis, false);
    }
}

void
UnaryExpression() : {}
{
    LOOKAHEAD(HitUnaryExpression()) UnaryOperator() UnaryExpression()
    {
	buildExpression(jjtThis, true);
    }
  | IncrementOperator(false) Lvalue()
    {
	buildExpression(jjtThis, true);
    }
  | LOOKAHEAD(HitPostIncrement()) Lvalue() IncrementOperator(true)
    {
	buildExpression(jjtThis, false);
    }
  | LOOKAHEAD(HitCast()) "(" Name() ")" UnaryExpression()
    {
	buildCast();
    }
  | LOOKAHEAD(HitLvalue()) Lvalue() ("@" Attribute())?
    {
	unrollTop();
    }
  | <NEW> Constructor()
    {
	jjtThis.setType(NEW);
    }
  | PrimaryExpression()
    {
	unrollTop();
    }
}

void
PrimaryExpression() #void : {}
{
    <LITERAL_INTEGER>
    {
	jjtree.pushNode(YoixObject.newNumber(token.image));
    }
  | <LITERAL_DOUBLE>
    {
	jjtree.pushNode(YoixObject.newDouble(token.image));
    }
  | <LITERAL_CHARACTER>
    {
	jjtree.pushNode(YoixObject.newChar(token.image));
    }
  | <LITERAL_STRING>
    {
	jjtree.pushNode(YoixObject.newString(token.image, true, true));
    }
  | <LITERAL_MULTILINE_STRING>
    {
	jjtree.pushNode(YoixObject.newString(token.image, false, true));
    }
  | <LITERAL_MULTILINE_ESCAPED_STRING>
    {
	jjtree.pushNode(YoixObject.newString(token.image, true, true));
    }
  | <LITERAL_REGEXP>
    {
	jjtree.pushNode(YoixObject.newString(token.image, true, true));
    }
  | "(" CommaExpression(true) ")"
}

void
Attribute() #void : {}
{
    (
	<ATTRIBUTE_ACCESS>
      | <ATTRIBUTE_GROWABLE>
      | <ATTRIBUTE_LENGTH>
      | <ATTRIBUTE_MAJOR>
      | <ATTRIBUTE_MINOR>
      | <ATTRIBUTE_NAMEOF>
      | <ATTRIBUTE_OFFSET>
      | <ATTRIBUTE_SIZEOF>
      | <ATTRIBUTE_TYPENAME>
    )
    {
	buildAttribute(token.kind);
    }
}

void
CaseExpression() : {}
{
    UnaryExpression()
    {
	buildExpression(jjtThis, false);
    }
}

void
CommaExpression(boolean commas) #void : {}
{
    {openExpression(commas);} Expression() {closeExpression();}
}

void
Constructor() #void : {}
{
    {openExpression(true);} Dvalue() (LOOKAHEAD(1) Initializer())? {closeExpression();}
}

void
ExpressionList() #void : {}
{
    CommaExpression(false) (LOOKAHEAD(2) "," CommaExpression(false))*
}

void
Optional() : {}
{
    (Expression())?
    {
	buildOptional(jjtThis);
    }
}

//
// Lvalues
//

void
Lvalue() : {}
{
    PrimaryLvalue() (LOOKAHEAD(1) (
	"." Name()
      | "[" Expression() "]"
      | "(" FunctionCall() ")"
    ))*
    {
	jjtThis.setType(LVALUE);
    }
}

void
PrimaryLvalue() #void : {}
{
    <GLOBAL>
    {
	buildPrimaryLvalue(GLOBAL);
    }
  | <THIS>
    {
	buildPrimaryLvalue(THIS);
    }
  | Name()
    {
	buildPrimaryLvalue(NAME);
    }
  | AddressOperator() Lvalue()
    {
	buildPrimaryLvalue(ADDRESS);
    }
  | IndirectionOperator() Pointer()
    {
	buildPrimaryLvalue(INDIRECTION);
    }
  | "(" Lvalue() ")"
    {
	buildPrimaryLvalue(LVALUE);
    }
}

void
Pointer() : {}
{
    LOOKAHEAD(HitPostIncrement()) Lvalue() IncrementOperator(true)
    {
	buildExpression(jjtThis, false);
    }
  | IncrementOperator(false) Lvalue()
    {
	buildExpression(jjtThis, true);
    }
  | (LOOKAHEAD(1) "(" CommaExpression(true) ")" | Lvalue())
    {
	unrollTop();
    }
}

//
// Imports
//

void
Import() : {}
{
    LOOKAHEAD(HitYoixModules()) Name() DotStar() DotStar()
    {
	unrollTop();
    }
  | Lvalue() (DotStar())?
    {
	unrollTop();
    }
}

//
// Declarations
//

void
Declaration() #void : {}
{
    (Qualifier())? Name() Declarator() ("," Declarator())*
}

void
Qualifier() : {}
{
    (<CONST> | <FINAL>)
    {
	jjtThis.setType(token.kind);
    }
}

void
Declarator() : {}
{
    Dvalue() ("=" Initializer())?
    {
	buildDeclarator(jjtThis);
    }
}

void
Dvalue() : {}
{
    VariableName() ("[" Index() "]")?
    {
	jjtThis.setType(DVALUE);
    }
}

void
Index() : {}
{
    (CommaExpression(false) ("," (CommaExpression(false) | <DOTDOTDOT>))?)?
    {
	buildIndex(jjtThis);
    }
}

void
Initializer() : {}
{
    CommaExpression(false)
    {
	jjtThis.setType(EXPRESSION);
    }
  | LOOKAHEAD(HitArray()) "{" ExpressionList() (LOOKAHEAD(1) ",")? "}"
    {
	jjtThis.setType(ARRAY);
    }
  | Compound(NAMEMASK)
    {
	jjtThis.setType(DICTIONARY);
    }
}

//
// Functions
//

void
FunctionCall() : {}
{
    (ExpressionList())?
    {
	jjtThis.setType(FUNCTION);
    }
}

void
FunctionDefine() #void : {}
{
    (Final())? VariableName() "(" ParameterList() ")" (Compound(0) | "=" Expression() ";")
}

void
Final() : {}
{
    <FINAL>
    {
	jjtThis.setType(FINAL);
    }
}

void
Parameter() : {}
{
    LOOKAHEAD(2) Name() VariableName()
    {
	jjtThis.setType(DECLARATION);
    }
  | VariableName()
    {
	unrollTop();
    }
}

void
ParameterList() : {}
{
    <DOTDOTDOT>
    {
	buildParameterList(jjtThis);
    }
  | (Parameter() (LOOKAHEAD(2) "," Parameter())* ("," <DOTDOTDOT>)?)?
    {
	buildParameterList(jjtThis);
    }
}

//
// Names
//

void
Name() #void : {}
{
    (<NAME> | ReservedName())
    {
	jjtree.pushNode(SimpleNode.newName(token.image));
    }
}

void
VariableName() #void : {}
{
    (<NAME> | LOOKAHEAD({(scopestack[scopetop]&NAMEMASK) != 0}) ReservedName())
    {
	jjtree.pushNode(SimpleNode.newName(token.image));
    }
}

void
DotStar() #void : {}
{
    <DOTSTAR>
    {
	jjtree.pushNode(new SimpleNode(DOTSTAR));
    }
}

void
ReservedName() #void : {}
{
    <RESERVED_ABORT>
  | <RESERVED_DEFINED>
  | <RESERVED_EOF>
  | <RESERVED_EVAL>
  | <RESERVED_EXECUTE>
  | <RESERVED_FALSE>
  | <RESERVED_FALSE2>
  | <RESERVED_NULL>
  | <RESERVED_NULL2>
  | <RESERVED_STDERR>
  | <RESERVED_STDIN>
  | <RESERVED_STDOUT>
  | <RESERVED_TOSTRING>
  | <RESERVED_TRUE>
  | <RESERVED_TRUE2>
  | <RESERVED_UNROLL>
  | <RESERVED_YOIX>
}

//
// Operators
//

void
AddressOperator() : {}
{
    <AND>
    {
	jjtThis.setType(ADDRESS);
    }
}

void
BinaryOperator() : {}
{
    (
	<MUL>
      | <DIV>
      | <MOD>
      | <PLUS>
      | <MINUS>
      | <AND>
      | <XOR>
      | <OR>
      | <LT>
      | <GT>
      | <LEFTSHIFT>
      | <RIGHTSHIFT>
      | <UNSIGNEDSHIFT>
      | <EQ>
      | <NE>
      | <EQEQ>
      | <NEEQ>
      | <EQTILDA>
      | <NETILDA>
      | <LE>
      | <GE>
      | <LOGICALAND>
      | <LOGICALXOR>
      | <LOGICALOR>
      | <ASSIGN>
      | <MULEQ>
      | <DIVEQ>
      | <MODEQ>
      | <PLUSEQ>
      | <MINUSEQ>
      | <ANDEQ>
      | <XOREQ>
      | <OREQ>
      | <LEFTSHIFTEQ>
      | <RIGHTSHIFTEQ>
      | <UNSIGNEDSHIFTEQ>
      | LOOKAHEAD(",", {commastack[commatop]}) <COMMA>
    )
    {
	jjtThis.setType(token.kind);
    }
}

void
IncrementOperator(boolean post) : {}
{
    <INCREMENT>
    {
	jjtThis.setType(post ? POSTINCREMENT : PREINCREMENT);
    }
  | <DECREMENT>
    {
	jjtThis.setType(post ? POSTDECREMENT : PREDECREMENT);
    }
}

void
IndirectionOperator() : {}
{
    <MUL>
    {
	jjtThis.setType(INDIRECTION);
    }
}

void
InstanceofOperator() : {}
{
    <INSTANCEOF>
    {
	jjtThis.setType(INSTANCEOF);
    }
}

void
TernaryOperator() : {}
{
    <QUESTION>
    {
	jjtThis.setType(QUESTIONCOLON);
    }
}

void
UnaryOperator() : {}
{
    <PLUS>
    {
	jjtThis.setType(UPLUS);
    }
  | <MINUS>
    {
	jjtThis.setType(UMINUS);
    }
  | <NOT>
    {
	jjtThis.setType(NOT);
    }
  | <COMPLEMENT>
    {
	jjtThis.setType(COMPLEMENT);
    }
}

//
// Syntactic lookahead productions - primarily designed to recognize
// the real production as quickly as possible. They sometimes accept
// more than you might expect (e.g., Name() versus VariableName()),
// but only when the mistake normally improves error messages.
//

void
HitArray() : {}
{
    "{" (LOOKAHEAD(1) "{" | CommaExpression(false) ("," | "}"))
}

void
HitCase() : {}
{
    LOOKAHEAD({(scopestack[scopetop]&ACCEPTCASE) != 0}) <CASE>
}

void
HitCast() : {}
{
    "(" Name() ")" Expression()
}

void
HitDeclaration() : {}
{
    (Qualifier())? Name() Name()
}

void
HitDefault() : {}
{
    LOOKAHEAD({(scopestack[scopetop]&ACCEPTDEFAULT) != 0}) <DEFAULT_>
}

void
HitFunctionDefine() : {}
{
    (Final())? Name() "(" HitParameterList() ")" ("=" | "{")
}

void
HitForEach() : {}
{
    <FOR> "(" Name() <IN>
}

void
HitGlobalBlock() : {}
{
    <GLOBAL> (Lvalue())? "{"
}

void
HitLvalue() : {}
{
    PrimaryLvalue() (LOOKAHEAD(1) ("." Name() | "[" Expression() "]" | "(" FunctionCall() ")"))?
}

void
HitNamedBlock() : {}
{
    Lvalue() "{"
}

void
HitParameterList() : {}
{
    ((Parameter()|<DOTDOTDOT>) (LOOKAHEAD(2) "," Parameter())* ("," <DOTDOTDOT>)?)?
}

void
HitPostIncrement() : {}
{
    Lvalue() IncrementOperator(true)
}

void
HitThisBlock() : {}
{
    <THIS> Lvalue() "{"
}

void
HitUnaryExpression() : {}
{
    UnaryOperator() UnaryExpression()
}

void
HitYoixModules() : {}
{
    <RESERVED_YOIX> <DOTSTAR> <DOTSTAR>
}
