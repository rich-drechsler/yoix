
                         Yoix Version 1.0

This is the source code for release 1.0 of the Yoix interpreter. Future
releases will support Swing, Java2D and lots of other good things, so
visit our Web site

	http://www.research.att.com/sw/tools/yoix/

frequently. Any questions, comments, or offers of help should go to

        yoix@research.att.com

and we will do our best to get you an answer, but there are just two of
us, so we can't promise to respond to everyone.

---------------
Maybe Next Time
---------------

	Documentation and implementation of CheckboxGroup.selected
	don't agree. Reading currently returns a String (the label
	of the selected checkbox). Writing only accepts a Checkbox.
	Definitely needs attention - think John prefers a Checkbox
	for both operations.

	Don't think scanf() is completely thread safe because it
	uses YoixBodyStream.getChar() which isn't synchronized.

	Currently get a FatalError, without any useful information,
	when the interpreter encounters EOF in a comment.

	Check the disconnect() comment in YoixBodyStream(). There's
	a small chance we've seen disconnect related hangs, at least
	on Unix, so we may need to take a different approach.

-------
History
-------

    Version 1.0 (5/8/02 - external release)
	The Yoix grammar now supports simple type casting that lets
	you precede an expression with a type name that's enclosed
	in parentheses. Doesn't actually duplicate the type casting
	that you get in Java or C, but the syntax will be familiar
	and it was an easy addition that should be sufficient for
	Yoix applications.

	---

	Most of the reference pages got a quick look and we fixed the
	mistakes that we noticed. There's undoubtedly more to do, but
	the documentation has definitely improved.

	---

	The nameof attribute has been improved and now does a better
	job reporting the names of elements in arrays that are used
	for storing local variables.

	---

	The argv array available in functions can now be incremented
	and decremented, which means it behaves just like the global
	version.

	---

	The run() function that can be defined in a thread can now be
	a function that accepts zero or more arguments. Internal Yoix
	code still assumes run() can be called with zero arguments, so
	you must use the syntax,

		run(...) {

		    //
		    // Use function's argv[] and argc to access
		    // unnamed arguments.
		    //
		}

	to define a run function that accepts arguments.

	---

	Some low level changes now let us postpone building VM.screen
	until it's really needed. Means applications that don't need
	screen properties don't have to pay the penalty that seems to
	accompany the first Toolkit.getDefaultToolkit() call. All of
	our previous releases built VM.screen at boot time, so every
	Yoix script paid the penalty.

	---

	Low level changes to the implementation the eval and include
	mean both now behave "correctly" when surrounded by try and
	catch, which means you can use try/catch to trap errors that
	happen during an eval or include. The change also means the
	interpreter stops executing an included file after the first
	error, which is small change in the interpreter's behavior
	that we doubt will affect any existing applications.

	---

	The folderListing builtin is now called directoryListing and
	timeFormat() is called timerFormat(). We also added a builtin
	named parseTimer() that's documented in the reference pages.

	---

	Added constants named ISO8859_1 and UTF8 to yoix.io. Each one
	is a string that the version of Java currently installed on
	your system will accept when you need to supply the name of
	corresponding encoding scheme. In most cases ISO8859_1 will
	be "ISO8859_1" and UTF8 will be "UTF8", but that mapping is
	not guaranteed so we recommend using the constants.

	---

	Modified our internal URL code slightly so that the default
	"User-Agent" property is a string that identifies the version
	of Yoix used to open the URL. For example in version "1.0" the
	default "User-Agent" property would be "Yoix 1.0". The value
	can be changed by associating a different string value with
	"User-Agent" in the URL's requestproperty dictionary.

	---

	Our CharStream.java file was generated by a very old version
	of JavaCC, but everything (except the comment at the start of
	the file) seems to be compatible with the latest JavaCC. We
	changed the comment in this release (to stop complaints from
	JavaCC version 2.1) and we plan on rebuilding CharStream.java
	in a future release, even though none of our tests turned up
	any problems.

    Version 0.9.7 (4/9/02 - external release)
	Fixed an annoying bug that resulted in NullPointerExceptions
	from Java when NULL events or layout managers were created.
	Among other things the fix means that event handlers can now
	include the type name of the event

		mouseEntered(MouseEvent e) {...}

	with their argument (in this case it's MouseEvent) without
	triggering a NullPointerException.

	---

	Fixed a Calendar bug that ignored explicit unixtime settings
	when they appeared in a calendar declaration's initializer.
	Changes to the unixtime field outside initializers were not
	broken and behaved as described in the documentation.

	---

	The VM.exitflag behavior described in the exit reference page
	and used in several examples was partly broken in an earlier
	release. The behavior has been restored and the examples now
	work properly.

	---

	The broken getopt examples in our reference pages have now
	been fixed. The reference page mistakes had been around for
	a very long time and represented an inconsistency between
	the examples in our documentation and the implementation of
	the Option type that had we had not noticed.

	---

	We changed the way dictionary initializers (like arrays) that
	don't map names to values are used. The new implementation
	stores the values at odd indices in the dictionary using the
	values at the corresponding even index to construct the name.
	For example,

		Dictionary d[] = {"one", 1, "two", 2, "three", 3};

	creates a dictionary with the three name/value pairs:

		Dictionary[3:0]
		    one=1
		   >three=3
		    two=2

	Yoix currently requires the square braces (empty or otherwise);
	forget and you'll get a typecheck error. We also recommend you
	use strings for the names (i.e., the objects at even indices).
	The interpreter won't complain, at least not in this release,
	but it uses toString() to generate the names, and that really
	can lead to strange names and confusing dumps.

	---

	Made a small change to the code that handles initializers so
	that an empty initializer of the form {} now behaves exactly
	as if no initializer had been supplied. This also cleaned up
	a mistake in the interpreter that allowed

		Dictionary d = {};

	but rejected

		Array a = {};

	with a typecheck error.

	---

	New builtins this time include urlDecode, urlEncode, gvsubsti,
	vsubsti, indexOfObject, lastIndexOfObject, crc32, timeFormat,
	and addColor. All are documented in new reference pages.

	---

	The unroll builtin now accepts a destination as an optional
	second argument, which means elements can now be copied from
	one object to another using a single builtin call.

	---

	Yoix include statement no longer complains when the argument
	evaluates to NULL, and the defined builtin no longer complains
	when either argument is NULL.

	---

	Added a mechanism that lets you organize checkbox menu items
	into a group that behaves like radio buttons. See the Menu
	reference page for more details.

	---

	MenuBar and PopupMenu now include builtins named getEnabled,
	getState, setEnabled, and setState that can give Yoix programs
	some control over individual menu items that was missing from
	our previous releases. See the MenuBar and PopupMenu reference
	pages for more details.

	---

	The text that's selected (i.e., highlighted) by a TextField
	and TextArea can now be accessed by reading or writing the
	selected and selectedends fields that we added this release.
	See the TextField and TextArea reference pages for the details.

	---

	Made lots of changes to the Tree type, improved the reference
	page, and expanded the examples. The walk builtin now takes a
	different first argument and returns a boolean rather that a
	Tree. Some of the changes are incompatible with our previous
	releases, but we doubt anyone is currently using Yoix Trees
	in a production program. See the Tree reference page for more
	details.

	---

	A Canvas can now add actionPerformed() and itemStateChanged()
	event handlers and receive ActionEvent and ItemEvent events,
	which lets a Canvas easily simulate a Button or Checkbox. An
	ItemEvent is sent to the itemStateChanged() handler whenever
	the value stored in the state field changes. ActionEvent is
	a bit more complicated, but generally simulates the standard
	behavior you get with a Button. The actionPerformed() event
	handler gets an ActionEvent when a button that was pressed in
	the Canvas is released when the cursor is in the Canvas. Our
	implementation also checks and updates state and only sends
	the ActionEvent if state was zero when the button was pressed
	and non-zero when it is released. The examples in the Canvas,
	drawString, and Image reference pages have been updated to use
	actionPerformed().

	Other types, like a TextCanvas, may exhibit the same behavior,
	but Yoix programs should not rely on it unless the new event
	handlers are listed in the appropriate reference pages.

	---

	We made a small change to the behavior of the state field in
	components, like a Canvas, that can automatically draw raised
	borders. Setting the state field to 0 or 1 still simulates a
	raised or lowered button, exactly the way it's described in
	the documentation. However setting state to a negative value,
	like -1, now draws a simple outline around the component using
	bordercolor (or foreground if bordercolor is not specified).

	---

	Made some changes and additions to the Yoix implementation of
	GridLayout, and there's a small chance one change could affect
	some existing applications. There are three new fields, namely
	model, orientation, and useall in GridLayout that control the
	the layout manager. Model picks the low level layout algorithm
	and should be -1, 0 (the default), or 1. Setting model to -1
	uses the GridLayout algorithm from previous releases, which is
	exactly what Java's AWT implementation supplied. The problem
	we had with the algorithm is that columns is usually ignored
	which can be confusing, so we added the model 0 algorithm and
	made it the default. Under model 0 rows and columns are both
	used, but the actual grid size depends on the orientation and
	the number of components that need to be placed in the grid.
	Model 1 is a variation of model 0 that uses rows and columns
	to pick the minimum grid size. For example,

		GridLayout manager = {
		    int rows = 2;
		    int columns = 3;
		    int orientation = HORIZONTAL;	// the default
		    int model = 1;
		};

	defines a layout manager that uses 3 columns, at least 2 rows,
	and places components in the grid horizontally in rows that
	always have three columns. Additional rows are added as needed
	when more than six components are placed in the grid. Change
	the orientation to VERTICAL and the layout manager uses 3 or
	more columns that have exactly 2 rows. Components are placed
	vertically (from top to bottom) in columns that are arranged
	from left to right in the grid.

	The useall field controls how invisible components are handled.
	When it's TRUE, which is the default, all components, whether
	visible or not, are used in the sizing and layout calculations.
	Setting useall to FALSE means skip the components that aren't
	visible, which is the behavior you get from most other layout
	managers. We considered making FALSE the useall default, but
	TRUE matches the existing GridLayout behavior, and that seems
	like a reasonable choice for grids.

	---

	Decided to back out a simple change that we made in release
	0.9.5b, but there's a small chance existing applications may
	be affected. Please let us know if you experience problems
	that are related to our waffling on this matter. We apologize
	in advance for any inconvenience and will consider kludges
	(there are several that are obvious) if it turns out to be a
	big problem for anyone.

	In release 0.9.5b we made a one-line change to the interpreter
	so that the boolean value associated with any pointer object
	used the value that would be reported by the sizeof attribute.
	We have now restored the original code that associates false
	with NULL pointers and true with non-NULL pointers. The first
	change simplified some code (see the 0.9.5b notes) but meant
	that a simple loop like

		while (line = stdin.nextline)
		    stdout.nextline = line;

	would stop at the first empty line unless it was changed to

		while ((line = stdin.nextline) != NULL)
		    stdout.nextline = line;

	Restoring the old code makes the first loop work, but code
	that relied on the 0.9.5b change may misbehave.

	---

	We decided to replace the command field in ItemEvent, which
	was a String, with a field named item that's declared to be
	and Object. Even though this is an incompatible change, we
	don't anticipate many problems, because itemStateChanged()
	event handlers rarely looked at the command field. However,
	if this does cause you problems let us know quickly and we
	will consider a fix (probably one the supports both command
	and item fields).

	---

	Added an integer field named pressed to MouseEvents that is
	non-zero when at least one button is pressed at the time of
	the event. Should be faster than counting modifier bits and
	safer than keeping a running count in a Yoix program. We may
	add it to KeyEvent and ActionEvent in a future release.

	---

	The user.timezone property seems to be empty in new versions
	of Java, so we compensate in getProperty(), getProperties(),
	and in the code that initializes yoix.system.USERTIMEZONE.
	The value that we substitute when the user.timezone property
	is empty comes from Java's TimeZone class, which seems to be
	able to find a reasonable answer.

	---

	TableManager now includes a builtin named html() that returns
	an HTML representation of the rows and columns in the managed
	table. See the TableManager reference page for more details.

	---

	TableColumn and TableManager now include a field named index
	that can be used to find the last row (or rows in the case of
	a TableManager) that was selected. In addition TableColumn
	defines a builtin named value() that returns the text that's
	displayed in a row. See the TableColumn and TableManager
	reference pages for more details.

	---

	The tempnam builtin now accepts an optional third argument
	that's appended to the generated file name and can be used
	to build filetype specific temporary files.

	---

	Modified substi builtin so it accepts a Subexp object as the
	second argument. Data stored in the target and ranges fields
	in the Subexp are used to make the substitution. See the substi
	reference page for more details.

	---

	Added pixelwidth and pixelheight values to VM.screen. They're
	distances measured in the Yoix default coordinate system of 72
	dots per inch that are guaranteed to cover a 1x1 square when
	they're transformed to screen coordinates. The numbers don't
	measure pixels but instead provide a reasonable lower bound,
	in Yoix coordinates, that maps to a single pixel.

	---

	Buttons now always include a definition of the command field
	that's NULL by default. As in previous releases command is
	used, when it's not NULL, to set the command string in the
	ActionEvent that's generated when the button is pressed. The
	command field can only be changed when the button is declared.

	---

	The atInterrupt() callback function that was added to Threads
	is now called afterInterrupt(). Was and still is undocumented
	but that may eventually change.

	---

	Added a field named coordinates to MouseEvent. It's a Point
	that usually matches the location field, which is where the
	event happened, but custom components may sometimes want to
	pass a different set of coordinates to event handlers. It's
	currently undocumented in the MouseEvent page - we will go
	into more detail in a future release.

	---

	Although fputc() was documented and listed in yoix.stdio, the
	actual implementation (in YoixModuleStdio.java) was missing so
	it didn't work. The oversight has been fixed in this release.

	---

	Removed debugging code in YoixAWTTextTerm.java that was used
	to make sure tabs were correctly expanded. Code that was left
	in by accident printed an 'x' instead of space when the tabs
	in a Yoix TextTerm were expanded.

	---

	Fixed code in YoixBodyComponent.pickForeground() that looked
	like a typo. For some reason the false branch in the second
	test called YoixMake.javaBackground(obj), which was clearly
	a mistake.  Assigning a foreground color to all components
	that extend YoixAWTCanvas now forces the component to repaint
	itself if the color really changed. The behavior now matches
	what automatically happens when a component's background color
	changes and also matches our documentation.

	---

	Updated graph code (YoixBodyElement and YoixGraphElement) to
	fix a few minor bugs and add name cache.

	---

	A few reference pages that were only partially complete have
	not been included in this release. We're working on them, but
	they probably will remain very low on our list of "things to
	do" until someone actually complains.

    Version 0.9.6a (10/12/01 - external release)
	The Yoix XML parser now supports text replacement, which was
	a feature that we promised to implement in our last release.

	---

	The Java code that dumps parse trees now runs significantly
	faster than the code that was supplied in the last release.
	The speed improvement was obtained by using a StringBuffer,
	rather than concatenating Strings.

    Version 0.9.6 (10/2/01 - external release)
	The Java code that starts the Yoix interpreter was completely
	rewritten and as a result most applications start faster than
	they did in previous releases. We think this is a significant
	improvement that on its own makes this a valuable release.

	In our older releases everything that could be used by a Yoix
	program (e.g., all types and everything under yoix) was built
	before the interpreter started reading your program. As the
	interpreter grew the overhead increased and every program, no
	matter how simple, paid a penalty. For example, even a trivial
	yoix program like

		exit(0);

	had to wait until everything, including all the AWT and GUI
	initialization finished, before it could simply exit. Our new
	approach builds a minimal subset, starts the interpreter, and
	arranges to build everything else when the program ask for it.
	In most cases the new approach is a clear winner that saves
	time and memory, but when it's not (e.g., a big application
	that uses lots of stuff) still it performs as well as the old
	implementation. Incidentally there's a new VM.debug flag that
	you can set directly using

		VM.debug |= 64;		// 64 == 0x40

	or on the yoix command line using -d64 that prints a line of
	information (there eventually may be more) whenever a module
	is loaded.

	---

	The Yoix interpreter now includes an XML parser (written for
	the JavaCC parser generator) and provides Yoix programs with
	an easy interface to that parser. Except for text replacement,
	which we hope to add in the near future, we think our parser
	does a pretty good job following the grammar described in the
	document,

		http://www.w3.org/TR/2000/REC-xml-20001006

	which is an excellent place to start if you're looking for a
	technical description of XML.

	Yoix programs can access the XML parser using Tree variables,
	which aren't new but have been extended to support more than
	one parser. For example,

		import yoix.parser.*;
		Tree t;
		t.parser = PARSER_XML;	// the default is PARSER_YOIX

	creates a Tree variable that's ready to parse XML documents.
	Just assign a string to t.parse,

		t.parse = "<?xml version=\"1.0\"?> <greeting>Hello, world!</greeting>";

	and you end up with a Tree variable that represents the XML
	that was stored in t.parse. You can dump the tree on standard
	output by typing,

		stdout.nextbuf = t.tree;

	but you should read the Tree reference page if you want to do
	much more.

	---

	We added graph support to Yoix, but there's currently no easy
	way to display them. Graphs can be created by running a Yoix
	program that builds and connects the individual elements or
	by handing an XML graph description to the xmlGraph builtin.
	The details and examples can be found in the Edge, Element,
	Graph, Node, and xmlGraph reference pages. Graph display will
	be added to Yoix in the near future, but probably not until
	we support the Java2D graphics model.

	---

	Yoix now supports user modules, which are special Java classes
	that extend a new class named YoixModule and follow a few other
	rules that will be detailed in a future release. User modules
	are automatically loaded when they're referenced by dot notation
	that starts with "yoix.module." and ends with the full Java class
	name. Obviously class files that implement user modules must be
	put in a directory that Java checks when it looks for classes,
	which means you may have to adjust the script (probably just the
	CLASSPATH setting) that runs yoix.

	NOTE - documentation and other missing pieces will be supplied
	in the near future - hopefully in our next release. Until then
	the curious can grab the source and look at ExampleModule.java
	and YoixModule.java. The code and comments in ExampleModule.java
	should answer many of your questions.

	---

	We removed support for loadBuiltins() from the documentation
	and source in favor of the user module approach, which is now
	the only supported way to build and load your own builtins. We
	doubt loadBuiltins() was used any serious application, but if
	we're wrong and you complain quickly enough we may reconsider
	the decision.

	---

	In previous releases VM and typedict were reserved words and
	there was one instance of each dictionary. In this release
	they are no longer reserved and global scopes, which start
	automatically with all execute() calls and some named blocks,
	now get their own copy of VM and typedict. The copy of VM is
	initialized by duplicating the current VM, but the typedict
	copy is always loaded with a standard collection of types.
	In other words, VM settings are exported but typedefs aren't.

	---

	Removed exec from the reserved name list and moved the exec()
	builtin, which is used to start a process, to yoix.system. The
	changes mean existing yoix programs that used exec() may have
	to import yoix.system.exec or reference the builtin using its
	its full name (i.e., yoix.system.exec()).

	---

	The restrictions on string initializers has been relaxed. An
	initializer that represents an array of numbers still can't
	be assigned directly to a string, so

		String s = {1, 2, 3, 4};

	is not allowed, but use square brackets to explicitly

		String s[10] = {1, 2, 3, 4};

	or implicitly

		String s[] = {1, 2, 3, 4};

	set the size of the new string and the declaration will be
	accepted - numbers from the initializer are copied into the
	corresponding positions in the new string.

	---

	Eased some of the size restrictions on initializers used in
	array and string construction (via declarations or new). The
	initializer can now be bigger than the object that's being
	created and the interpreter will not complain. For example,
	try something like

		String str[3] = "now is the time";

	using an old version and you get a rangecheck error, but in
	this release str ends up containing the first three letters
	of the initializer.

	---

	Modified YoixBodyStrem.openURL() so that Yoix programs that
	try to open a non-existent URL for reading or writing always
	get NULL. Previous implementation would only return NULL if
	the URL was opened for writing. Also decided to ignore bad
	requestproperty values instead of aborting.

	---

	VM.errorcount, VM.errorlimit, and VM.securitymanager fields
	have been removed. Access must now be made using new builtins
	getErrorCount, setErrorCount, getErrorLimit, serErrorLimit,
	and getSecurityManager, which were added to yoix.system. The
	change was made because each new global scope gets its own,
	so the counters had to move from the VM dictionary to the
	YoixVM class file.

	The VM.dump field that controls the depth of object dumps
	is now called VM.dumpdepth. The VM.timestamp field, which
	gets set every time the interpreter starts, is now called
	VM.starttime. An undocumented field named VM.interruptflags
	that controlled some low level thread behavior is gone.

	NOTE - we decided to lock the permissions assigned to objects
	stored in VM, which means those permissions can't be modified
	by Yoix programs. This probably is a temporary change that
	was done primarily to improve the performance of some low
	level code.

	---

	Added builtins named loadINI, readINI, remINI, and writeINI
	to the yoix.windows dictionary (which is also new) that let
	Yoix programs manipulate Windows initialization files. The
	loadINIFile builtin that was added to yoix.system in version
	0.9.5a has been completely replaced by loadINI. The builtins
	and implementation details were suggested by Chris Coggburn.

	---

	The boolean value associated with a function now is false
	when the function is NULL and true otherwise. Was a simple
	fix in YoixInterpreter.booleanValue().

	---

	Added an optional argument to the getProperty builtin that's
	used as the return value, instead of NULL, when the lookup of
	the original property fails.

	---

	Fixed an obscure bug in the parser that resulted in a syntax
	error when "new" was used as an argument in a function call,
	but only when "new" had an initializer that relied on a comma
	expression. The fix was trivial.

	---

	Fixed a mistake that caused a NullPointerException when the
	text field in a TableColumn was accessed before anything was
	stored there.

	---

	Added -l and +l options to YoixMain.java so you can control
	the error limit from the command line. Both options set the
	limit, but +l tells the interpreter to silently ignore all
	subsequent changes.

	---

	Updated make.bat so it should work with the current source
	package, but it's unsupported and a very low priority, so
	the new version probably has not been tested yet. Should
	be close if it doesn't quite work - please let us know if
	you have problems or your own fixes.

	---

	Added a few things to TableColumn and TableManager that let
	programs set foreground and background colors for individual
	rows. Also added a function named afterLoad() that's called
	(when it's not null) after the table is loaded but before
	it's displayed. Much of this will change in the near future,
	so it's not documented and we don't recommend experimenting
	with the new TableColumn and TableManager fields.

	---

	A very low level change in YoixPointerActive.put() now waits
	until setField() returns before storing the new value in the
	data dictionary. Added cast() to YoixInterfacePointer class
	so the general error checking handled by put() could happen
	before the setField() call. The change shouldn't affect Yoix
	programs, but our implementation introduced a little bit of
	overhead that so far has not been noticeable in any of the
	tests we've run. The change also meant we had to add cast()
	to all classes that extend YoixPointer.

    Version 0.9.5b (7/31/01 - external release)
	The send() and receive() builtins were using utf8_encoding
	which just didn't look right, at least not for binary data.
	Changed both to iso8859_1_encoding, and it now looks like
	we can transmit binary data. Noticed utf8_encoding in a
	few other places - check it before the next release.

	---

	Using separate threads to send() and receive() on a single
	DatagramSocket sometimes hung because Java synchronizes the
	receive() method and our implementation of send() called
	setSoTimeout() in java.net.DatagramSocket, which is also
	synchronized. Fix was easy because timeouts only affect
	receive(), so there was no reason to set them during send.

	---

	Added code to YoixInterruptable.java that should let Yoix
	programs interrupt a receive operation. Didn't run tests
	on all systems to see if it really was necessary - will do
	it before our next major release. Introduced overhead to
	every receive() call that we may be able to can reduce or
	eliminate (next time).

	---

	The receive() builtin would throw a NullPointerException
	when the port couldn't be used (e.g., it was privileged).
	We now catch the exception and have receive() return -1.
	In addition we added code that should make sure receive()
	can be interrupted on all platforms.

	---

	The address field in a DatagramSocket and ServerSocket was
	never really used by the Yoix interpreter, but it led to some
	confusing code (even in our own examples), so we decided to
	remove it.

	---

	Changed the interpreter slightly so that the boolean value
	associated with any pointer uses the value reported by the
	sizeof attribute. Previous releases returned false when the
	pointer was NULL and true otherwise. It's a minor extension
	that means code like

		while (ptr@sizeof > 0) {
		    stuff...
		    ptr++;
		}

	can be replaced by,

		while (ptr) {
		    stuff...
		    ptr++;
		}

	which will run faster. Changed one line in booleanValue()
	(file YoixInterpreter.java) and ran a few tests, but it
	probably checked a bit more.

	---

	Several low level changes in YoixMake() currently related
	to how typedef initializers are used. Needs a close look
	and maybe more thought. Nothing appears to be broken, but
	the whole initialize() related code in YoixMake() is still
	confusing and probably inconsistent. We suspect the same
	kind of changes should go in with type templates.

	---

	One line change (currently) in variable declaration code
	that now applies sizeof() to an initializer to determine
	the default size of a new object when [] is encountered
	in a declaration. Works nicely for strings (and we think
	it's probably the right thing to do) because copyInto()
	uses overlay() for strings. However YoixMisc.copyInto()
	code behaves differently for other objects. This must be
	addressed before too long - we probably need to carefully
	check all copy loops in our Java code that start at 0 and
	end and at length()!!

    Version 0.9.5a (7/25/01 - external release)
	Added AudioClip support and eventually plan on supporting
	the entire javax.sound package. Thanks to Chris Coggburn
	for the suggestions.

	---

	Implemented "named blocks", which were available in an old
	version of the language, but intentionally omitted from
	Yoix. Turns out we often wanted the feature, so it's back
	in and here's an example:

		//
		// First create a dictionary, often with some
		// extra room for any variables that will be
		// declared in the "named block".
		//
		Dictionary dict[10] = {
		    String str = "this is a test";
		    double d = 1.2345;
		};

		//
		// This is the "named block". It tells the Yoix
		// interpreter to use dict for the storage that
		// would normally be automatically allocated by
		// the interpreter immediately before entering
		// the block.
		//
		dict {
		    int n = 4;

		    str[n++] = 'X';
		};

	Dump the context of dict using something like

		printf("dict=%O\n", dict);

	and you should understand what happened. "Named blocks" is
	not a completely accurate description, because the parser
	currently accepts any lvalue (including a simple name) that
	resolves to an object (like a dictionary) that maps names
	to values.

	---

	Modified the "named block" implementation by adding

		global XXX {
		    ...
		}

	to the language so programs can choose to start a new global
	block if they want. The usual named block requirements all
	apply, but XXX must also contain or accept valid definitions
	of argv, argc, envp, and errordict, which are automatically
	added to XXX if they're missing.

	---

	Modified shift operators slightly. Left shifting now shifts
	bits out of the operand, which is like C rather than Java,
	negative shift values change the shift direction, and the
	type of the left operand determines the type of the result.

	---

	Added a text field to TableColumn. It's currently read-only,
	which means TableColumns must be loaded by a TableManager,
	but that may change in the near future. Still needs to be
	documented.

	---

	In all previous versions reading a TableManager's text field
	appended a newline to every line whenever inputfilter was a
	string. In this version the newline is used as separator, so
	it's now missing from the last line. Changed for consistency
	with TableColumn addition and so strsplit(), strjoin(), and
	qsort() could be used to separate lines, sort them, and then
	reload the table.

	---

	The qsort() builtin now accepts additional array arguments
	after the first array, that are rearranged in parallel with
	the original array. Each optional array must be at least as
	large (when measured by sizeof) as the array that's sorted.
	Also changed low-level qsort() methods so they start sorting
	at the array's current offset, rather than at offset 0.

	---

	Added a builtin named loadINIFile() to yoix.system that can
	build a dictionary that represents a Windows INI file. Not
	extensively tested, but it did seem to work on all our test
	files. First argument currently must be a string that is the
	pathname of the INI file. The second argument is an optional
	dictionary that gets loaded with the key/value pairs that
	represent the INI file. Thanks again to Chris Coggburn the
	suggestion and description of Windows INI files.

	---

	Implemented and documented the isHashtable() and isVector()
	builtins.

	---

	Low level change - YoixInterpreter.statement() no longer
	pushes and pops a MARK before handling every statement.

    Version 0.9.5 (7/6/01 - external release)
	Implemented the Yoix version of finally. Syntax is slightly
	different than Java, because the Yoix version isn't tied to
	try/catch and there's nothing in the grammar that says you
	can only define one finally in each compound statement. The
	one that's kicked off right before a block ends, is the last
	finally statement that the interpreter executed in that block.
	For example,

		import yoix.stdio.*;

		int  n = -100;
		{
		    int  n = 100;
		    finally {
			printf("this will not execute\n");
		    }
		    n++;
		    finally {
			printf("local n=%d\n", n);
		    }
		    n++;
		}

		n--;
		finally {
		    printf("global n=%d\n", n);
		}
		n--;

	prints something like

		local n=102
		global n=-102

	on standard output.

	---

	All functions now have access to a local argc and argv that
	describe the function call. Global argc and argv are hidden
	inside the body of a function, but can be accessed by using
	global.argc and global.argv. argv[0] is the function name and
	argc is the number of elements in argv[], which is 1 more than
	the number of arguments in the function call.

	WARNING - unfortunately this is an incompatible change. Any
	existing code that used argc or argv in the body of a function
	should now use global.argc and global.argv.

	---

	An important consequence of the fact that function arguments
	can be accessed using the argv[] is that a definition like,

		f(...) {

		}

	which say the function accepts zero or more arguments, makes
	sense and is now accepted by the parser. In older versions we
	could take the address of a named argument and get access to
	the argument array, but that implied that functions with a
	variable argument list needed at least one named argument.

	---

	We spent some time documenting functions, and even though we
	didn't finish we still recommend that you look the functions
	reference page (it's listed under the grammar section). We
	hope to finish next time and incorporate the description in
	the paper.

	---

	Added === and !== binary operators to Yoix. Currently both
	work exactly like the == and != operators except when both
	operands are strings. In that case === and !== compare the
	two strings very much like the Yoix strcmp() builtin rather
	than comparing them as "pointers". For example,

		import yoix.stdio.*;

		String s1 = "A test string";
		String s2 = s1;
		String s3 = "A test string";
		String s4[] = s1;

		printf("Testing the == operator\n");
		printf("  s1 == s2 is %s\n", s1 == s2 ? "true" : "false");
		printf("  s1 == s3 is %s\n", s1 == s3 ? "true" : "false");
		printf("  s1 == s4 is %s\n", s1 == s4 ? "true" : "false");
		printf("  s2 == s3 is %s\n", s2 == s3 ? "true" : "false");
		printf("  s2 == s4 is %s\n", s2 == s4 ? "true" : "false");
		printf("  s3 == s4 is %s\n", s3 == s4 ? "true" : "false");

		printf("\nTesting the === operator\n");
		printf("  s1 === s2 is %s\n", s1 === s2 ? "true" : "false");
		printf("  s1 === s3 is %s\n", s1 === s3 ? "true" : "false");
		printf("  s1 === s4 is %s\n", s1 === s4 ? "true" : "false");
		printf("  s2 === s3 is %s\n", s2 === s3 ? "true" : "false");
		printf("  s2 === s4 is %s\n", s2 === s4 ? "true" : "false");
		printf("  s3 === s4 is %s\n", s3 === s4 ? "true" : "false");

	prints something like

		Testing the == operator
		  s1 == s2 is true
		  s1 == s3 is false
		  s1 == s4 is false
		  s2 == s3 is false
		  s2 == s4 is false
		  s3 == s4 is false

		Testing the === operator
		  s1 === s2 is true
		  s1 === s3 is true
		  s1 === s4 is true
		  s2 === s3 is true
		  s2 === s4 is true
		  s3 === s4 is true

	on standard output.

	Incidentally, one nice consequence of === is that it helps
	us clarify the Yoix switch statement, because we can now say
	that the Yoix interpreter uses === to compare switch statement
	and case label expressions.

	WARNING - there's a chance we'll extend === and !== to other
	data types in the near future, so for now you should restrict
	their use in Yoix programs to the case when you're sure both
	operands of === and !== are strings.

	---

	Added Vector and Hashtable as new Yoix types. They're more
	flexible than the Yoix Array and Dictionary types, but using
	a Vector or Hashtable introduces overhead and you sacrifice
	some convenience and performance (e.g., your program can't
	index through them or use dot notation to recover a value
	from a Hashtable). However, the ability to remove objects
	from a Vector or Hashtable or to associate any two objects
	in a Hashtable are features that will occasionally be worth
	the overhead and performance penalties.

	Our implementation introduced fields that may not be familiar
	to Java programmers, so read the documentation before using
	them in a Yoix program. The good news is there aren't too
	many fields and we tried to keep our Vector and Hashtable
	implementations as consistent as possible. In addition, we
	may decide to add indexing to our hashtables or implement a
	new type (e.g., HashVector) in a future release.

	---

	The root field in windows (frame, dialog, etc.) now behaves
	exactly like "this", which should mean that event handlers in
	windows can now look like event handlers in other components.
	In other words, event handlers in a frame, dialog, or window
	can now use the root field or "this" interchangeably, because
	root won't be NULL.

	Documentation needs to be changed. Tried to implement the same
	behavior in Panels, but had trouble, so root in a Panel can
	currently still be NULL. Eventually will look into it again,
	but not for a while.

	---

	The components field in windows (frame, dialog, etc.) is now
	no longer emptied and set to NULL when the window is disposed.
	The required cleanup, if any, is now handled by finalize(),
	which means event handlers (and anyone else for that matter)
	should no longer have to worry about components going to NULL
	or objects disappearing from components just because a window
	has been disposed.

	---

	Added a super.finalize() call whenever one of our classes
	defined its own finalizer. Turns out the 1.3 implementation
	of Frame.java (and probably others too) leaks memory if its
	finalizer method isn't called. The 1.3.1 complier will also
	complain if the super.finalize() call isn't in a try/catch!!

	---

	When the version of unroll() in our earlier releases was used
	in a function call, all uninitialized elements were replaced
	by an empty object, which is an undocumented internal object
	that Yoix programs can't use. It was a mistake that has been
	fixed in this release, so when you use unroll in a function
	call you now only get the defined entries.

	---

	TableColumn, TextCanvas, and TextTerm now skip the optimization
	triggered when savegraphics (currently an undocumented field)
	is set to TRUE when Java 1.3.X is used on Window 9X. Apparently
	saving and re-using a Graphics object can cause strange behavior
	on older Windows systems - we saw the problem while scrolling a
	large table.

	---

	Fixed a simple mistake in the parser (file YoixParser.jjt) that
	failed to recognize a block with a save and/or finally but no
	local variables as compound statement. Mistake happened when
	closeScope() used LOCALCOUNT instead of BLOCKMASK to make the
	decision. See the next section for an example.

	---

	Our implementation of save in all previous releases failed to
	restore the access permissions associated with a variable when
	a block was exited. That meant something like

		import yoix.stdio.*;

		int x = 1;
		{
		    save x;		// save current permissions and value
		    const x = 200;	// new change permissions and value
		    int  dummy;		// required - see previous section
		    printf("inner x=%d\n", x);
		}
		printf("outer x=%d\n", x);
		x++;			// this would fail
		printf("final x=%d\n", x);

	would fail when the interpreter tried to increment x.

	---

	Added a highlighted field to TableColumn and TableManager that
	can be used to highlight individual rows in a table or column
	and to extract a string that represents the highlighted rows
	in a column or table.

    Version 0.9.4 (5/25/01 - external release)
	Fixed a mistake in our stream code that resulted in a memory
	leak because all data structures associated with a stream that
	was opened for writing weren't removed from a static dictionary
	used by the interpreter when that stream was closed. The fix
	was trivial, but the leak could have a significant impact on
	some applications, so we recommend that you start using this
	version as soon as possible.

	---

	We worked hard at trying to provide interruptible IO operations
	in Yoix, and we think we've made good progress. Unfortunately
	it's a very difficult Java problem, so we can't claim complete
	success, but our approach is flexible and it should be able to
	address omissions when they come up. There's a good description
	of the issues at

	    http://developer.java.sun.com/developer/bugParade/bugs/4154947.html

	that you can read if you're curious about interruptible IO in
	Java and happen to belong to the Java Developer Connection. If
	you have the Yoix source look at file YoixInterruptable.java
	and the uses of YoixInterruptable in the other source files if
	you're interested in our approach.

	---

	Removed synchronization and/or modified the implementation of
	some of the methods in many of the YoixAWT*.java files. Main
	reason was because we stumbled into a somewhat reproducible
	deadlock while experimenting with a prerelease version of the
	1.3.1, which we were using because we had several reports of
	deadlock when the 1.1.8 Java Virtual Machine was being used.
	The initial deadlock report turned out to be a long-standing
	Java bug described in the two reports

	    http://developer.java.sun.com/developer/bugParade/bugs/4091873.html
	    http://developer.java.sun.com/developer/bugParade/bugs/4135813.html

	that are available to members of the Java Developer Connection.
	The bottom line, at least as far as we understand, is that all
	Java 1.1.X virtual machines can (but usually don't) deadlock
	if class has a finalizer that calls a synchronized method. The
	problem, according to the bug reports, is fixed in 1.2 and 1.3,
	but it will not be fixed in 1.1.

	Sun has now officially released 1.3.1 and we're satisfied that
	the finalizer deadlock problem has been fixed. We've done quite
	a bit of testing using 1.3.1 and we like what we've seen, so we
	recommend that you start using 1.3.1 to run the Yoix interpreter
	as soon as possible. Go to

	    http://java.sun.com/

	and you should be able to find Sun's official 1.3.1 release for
	Windows, Linux, and Solaris.

	---

	Added code to YoixAWTTableManager.java that recovers the text
	that was loaded in a table from the individual columns, which
	means the duplicate that was saved in the data dictionary has
	also be eliminated. This change reduces memory used by tables,
	but means the string obtained by reading the text field may
	not exactly match the string that was stored in that field.

	---

	Added preferredsize, minimumsize, and maximumsize fields to
	Panels, which should help when you need more control over the
	layout manager sizing choices.

	---

	List and Choice now include fields named labels and mappings
	that can be used instead of or in combination with the items
	field. The labels array will help you load a list or choice
	from an array of strings that isn't organized in pairs, but
	instead only contains the strings that are loaded in the list
	or choice. The mappings array should help you set the values
	returned by a list or choice from an array of strings that
	isn't organized in pairs.

	---

	Added an ipad field to TextCanvas, TextTerm, and TableColumn
	objects that sometimes helps when you need more control over
	how text is displayed by the object. We have only implemented
	the adjustments that correspond to non-negative ipad.top and
	ipad.bottom, which can be used to adjust the separation of the
	lines displayed by the object. The ipad.left and ipad.right
	adjustments have not been implemented or even defined in this
	release (we're not sure if they should apply to words, spaces,
	characters, lines, etc.).

	---

	Added DEBUG_SYNCHRONIZED to YoixConstants.java and used it in
	YoixInterpreter.java to control debugging output generated by
	the code implements synchronized statements. It's currently
	defined as 0x20, so the debugging output can be enabled from
	the command line using the -d32 option or by executing

		VM.debug |= 0x20;

	in a Yoix program. The new debugging output should help if you
	need to track down a deadlock problem and suspect it's caused
	by a Yoix program (but not the Yoix interpreter itself).

	---

	Fixed several mistakes, all related to case sensitivity, in our
	low level regular expression code.

    Version 0.9.3 (4/23/01 - external release)
	Modified the grammar and interpreter so include now accepts
	an expression (which must evaluate to a String) rather than
	requiring a String literal. For example, something like

	    import yoix.system.*;
	    include getProperty("user.home") + "/xxx.yx";

	is now allowed and is how your program could include a file
	named xxx.yx that's located in the user's home directory. We
	decided to ease the restrictions on include because the eval
	builtin meant there really was no restriction on what a yoix
	program could include. In other words, something like

	    String  prog;
	    prog = "import yoix.system.*;";
	    prog += "include getProperty(\"user.home\") + \"/xxx.yx\";";
	    eval(prog);

	has always been allowed and is what a Yoix program would have
	to do include the same file in earlier releases.

	---

	Fixed several mistakes that led to inconsistent behavior when
	a thread was interrupted or killed. One problem was that the
	Yoix interpreter was too aggressive catching Exceptions, and
	as a result it often missed an InterruptException, which in
	some cases appeared as an InterruptedIOException. Low level
	code, mostly for stacks and threads, also needed lots of work,
	so the fixes were non-trivial and touched many source files.
	We're not completely finished, but at this point the behavior
	when you interrupt or kill a thread (by setting interrupted or
	alive fields to FALSE) seems to be quite good.

	---

	Added Java code to YoixBodyComponent.java that invalidates a
	Label whenever new text is stored in the Label. Calling Java's
	invalidate() method ensures that the Label uses the new text
	string when layout managers ask for size preferences. The same
	kind of problem showed up when a new set of items were stored
	in a Choice, and it was fixed in the same way. A few other AWT
	components may benefit from the same kind of change - we will
	eventually take a closer look.

	---

	Storing NULL in the size field of a Frame, Dialog, or Window
	now changes the size of that object to its preferred size. In
	old versions setting size to NULL when the object was declared
	set the object's size to its preferred size, but storing NULL
	in the size field after an object had been declared (outside
	the initializer) accomplished nothing.

	---

	Cursors now behave something like the background, foreground,
	and font fields, with STANDARD_CURSOR substituting for NULL.
	In other words, the cursor assigned to a component, like a
	Button, that does not explicitly pick one of it's own, means
	use the cursor assigned to the nearest component that contains
	the button and has a cursor other than STANDARD_CURSOR. The
	new behavior means you often can change the cursor displayed
	by everything in a Frame by storing a new value in the Frame's
	cursor field.

	---

	Starting the Yoix interpreter no longer depends on executing
	Java's

		Toolkit.getDefaultToolkit()

	method, which sometimes failed (e.g., under X windows on Unix
	when DISPLAY was incorrect or just not set). The changes mean
	the error is postponed and should now only show up when your
	Yoix program tries to create a Frame, Dialog, FileDialog, or
	Window. We eventually will try to ease the restrictions even
	more.

	---

	Custom fields can now be added to Thread objects when they're
	declared. Details mirror what's always been available with the
	Yoix versions of most AWT objects (e.g., Frame, Button, etc.).
	The change makes it easier write a thread run() function that
	accesses custom information that belongs to the thread.

	---

	Fixed a mistake in the implementation of the wait() builtin in
	YoixBuiltinsThread.java that accidentally used the wrong object
	when it made the call to Java's wait(). The mistake meant wait
	didn't work with synchronized and notifyAll(), which meant it
	was completely useless.

	---

	A few places in the interpreter (e.g., htoa() builtin) where
	we converted Java byte arrays to Java Strings called a String
	constructor that didn't explicitly specify an encoding. The
	mistake was only noticeable when a program worked with binary
	data on a platform (e.g., most PCs) that used something other
	ISO8859-1 as the default encoding and you happened to be using
	a builtin, like htoa(), that included the String constructor
	mistake.

	---

	Fixed a bug in the implementation of the substring() builtin
	that incorrectly used the ending index, when it was supplied.
	The mistake accidentally added the starting and ending indices
	and issued a "badargument" error message when the result was
	larger than the length of the string.

	---

	Modified strsplit() so an empty string delimiter (i.e., "")
	splits individual characters out of the source string. Older
	versions returned an array with a copy of the original source
	string as the only element when the delimiter was the empty
	string.

	---

	Added the strjoin() builtin. Takes an array of strings and a
	delimiter as arguments and joins them, so it's pretty much
	the inverse of strsplit(). Currently not forgiving about the
	elements in the array - maybe later.

	---

	Fixed a permissions mistake that prevented initialization of
	the requestproperty field in a URL. We still haven't updated
	the URL reference page with a more complete description of the
	requestproperty array, so here's a simple example

		import yoix.io.*;

		u = open(
		    "http://www.research.att.com/sw/tools/yoix/index.html",
		    "r",
		    new Dictionary {
			Array requestproperty = {
			    "User-Agent", "requestproperty test",
			};
		    }
		);

		while ((stdout.nextbuf = u.nextbuf) != NULL) ;

	that reads our index.html page and tries to leave an entry in
	the httpd log that includes the string "requestproperty test".

	---

	A trivial change to YoixParser.backup() so it can recognize
	if-else statements without requiring unnecessary lookahead.
	This corrected a mistake that only occasionally affected the
	performance of the interpreter when run in interactive mode.
	Users who encountered the problem would find they needed to
	type an additional token (e.g., semicolon) before an if-else
	statement would be executed.

	---

	Added an autotrim field to many AWT components. Setting it to
	TRUE automatically trims white space from both ends of text
	strings that are stored into or retrieved from the component.
	Was added for efficiency (explicit trim() calls can be skipped
	by setting autotrim to TRUE). Very useful when you work with a
	TextField, but less so with most other AWT components.

	---

	Added an enabled field to all AWT components, but our custom
	components, like TextCanvas, currently don't do anything when
	enabled is changed.

	---

	Several event handlers that are built into TableManagers and
	TextTerms (e.g., mousePressed()) now let yoix programs define
	their own versions of those event handlers that don't override
	the internal versions, but only when the programs event handler
	explicitly returns FALSE. A bit confusing and still needs to
	be documented and/or modified.

	---

	Changed the gsubsti() and substi() builtins so they accept a
	Regexp or String (the pattern) as the second argument. Also
	added strtod() and strton() builtins to yoix.string.

	---

	Added an optional second argument to the toBack() and toFront()
	builtins that lets Yoix programs raise or lower the children of
	a window after the operation is applied to the window.

	---

	The isCallable() builtin now only returns nonzero when either
	isBuiltin() or isFunction() return 1. Before the fix any NULL
	object (e.g., a NULL String) would pass.

	---

	Added atInterrupt() to Threads. It's called, if it's not NULL,
	right after a running thread is interrupted (but not when it's
	killed). This was a late addition that hasn't been well tested
	and may not be particularly useful.

	---

	Added a hack to YoixBodyComponent.setTitle() to compensate for
	Frame titles that sometimes disappeared when they were changed
	on some Unix systems using some versions of Java. Didn't bother
	to track this one down because it's not particularly important
	and we weren't able to find a real fix. All we were able to do
	was skip the AWT setTitle() call when the old and new titles
	matched.

	---

	Minor change to List and Choice code so that they check the
	item count before calling removeAll(). Only done to eliminate
	Motif warning messages that showed up on our SGI and probably
	only happened using an older version of JDK.

	---

	Minor fixes to the offsetBytes() builtin and the Java code (in
	YoixBodyStream.java) that handles the low level details.

	---

	Added a displayed field to TableManagers, mostly for a project
	that was using Yoix tables. Done quickly, so it probably needs
	to be revisited and documented.

	---

	Added -p and -P options to YoixMain.java - they probably should
	be documented somewhere??

    Version 0.9.2b (2/8/01 - external release)
	Fixed an obscure bug related to variable declarations in a
	block, like a function body, that's executed more than once.
	Problem happened when the Yoix code looked something like:

	    f() {
		String s1;
		String s2;
		int    n1;
		int    n2;

		...

		if (some_test()) {      // assume first call fails here
		    printf("something went wrong\n");
		    return;
		}

		Array a1;       // sometimes an error on second call

		...
	    }

	Bug happened because we use a single dictionary that's saved
	in the parse tree for the function body (and filled in as the
	declarations are executed) to store the offsets into an array
	that's really used for the local storage. Mapping depends on
	the order that declarations are executed, but in this case it
	would look like,

	    Dictionary          Local Storage Array
	    ----------          -------------------
	    |s1 |  0 | -------> value of s1 (at offset 0)
	    ----------
	    |s2 |  1 | -------> value of s2 (at offset 1)
	    ----------
	    |n1 |  2 | -------> value of n1 (at offset 2)
	    ----------
	    |n2 |  3 | -------> value of n2 (at offset 3)
	    ----------
	    | empty  |          uninitialized
	    ----------

	right before the first some_test() call. Problem is, we assign
	offsets based on an integer (named next in YoixBodyBlock.java)
	that's set to zero each time a new block is started and that
	integer was only incremented when we declared a variable that
	wasn't already mentioned in the dictionary. Now when we call
	f() but don't trigger the some_test() error, we end up with

	    Dictionary          Local Storage Array
	    ----------          -------------------
	    |s1 |  0 | ---+---> value of s1 (at offset 0)
	    ----------    |
	    |s2 |  1 | -------> value of s2 (at offset 1)
	    ----------    |
	    |n1 |  2 | -------> value of n1 (at offset 2)
	    ----------    |
	    |n2 |  3 | -------> value of n2 (at offset 3)
	    ----------    |
	    |a1 |  0 | ---+     uninitialized
	    ----------

	so we think a1 belongs at offset 0 in the array that's used for
	local variable storage, and we end up with a BADDECLARATION error
	because that spot has already been allocated to s1. The fix was
	easy and isolated to file YoixBodyBlock.java.

	---

	Added a scroll field to Lists that gives programs some control
	over whether the List uses horizontal and vertical scrollbars.
	For example, setting the scroll field to VERTICAL means the
	Java code that implements the Yoix version of the List tries
	to figure out the maximum length of a line (plus a bit) and
	uses that value whenever Java ask for a preferred, minimum,
	or maximum size. Still need to tune things so we get the best
	possible results. Also, our implementation is only advisory
	because AWT Lists don't really let us control the scrollbars.

    Version 0.9.2a (1/29/01 - external release)
	Unfortunately our tests of the Yoix installer on Windows were
	a bit lacking and we missed several problems that didn't show
	up when we ran in our environment on Windows NT. At some point
	carriage returns in a file that's used to build yoix.bat were
	deleted (probably during an ftp transfer from Windows to Unix),
	which meant they were also missing from the initial portion of
	every yoix.bat file that the Yoix installer built. Windows NT
	didn't mind, but Windows 95 (and probably 98) complained when
	we tried to run yoix.bat. The carriage returns are back and we
	really did run some tests on Windows 95.

	---

	We also didn't have Java installed in a standard place on our
	Windows NT system, so we didn't have to deal with pathnames
	that included spaces (e.g., when Java is installed somewhere
	under the "Program Files" directory). The Yoix installer now
	puts double quotes around the path that points to java or jre
	in the yoix.bat file that it builds for you whenever it finds
	a space or tab in that path.

	---

	Updated make.bat so it works with the current source package,
	which means you can build yoix.jar on Windows after you install
	JavaCC and a version of JDK. We ran a few tests on Windows NT
	it seemed to work properly, but we also added carriage returns
	to every line, so there's a chance make.bat will also work on
	Windows 95.

	---

	All bitwise and shift operators now work with Yoix doubles in
	a way that we think is consistent and useful. Internally the
	new behavior casts a double to a long, performs the operation
	on the long, and then casts the long back to a Yoix double.

	---

	Added >>> and >>>= operators to Yoix for unsigned right shifts
	of integers or doubles.

	---

	The Yoix parser now automatically converts integer constants
	(in decimal, hex, or octal notation) that don't fit in 32 bits
	to doubles. The rules in older releases were undocumented and
	confusing.

	---

	Added pointInRect() and pointInPolygon() to yoix.graphics.

	---

	Wrote quite a bit of new code designed to compensate for the
	inconsistent background colors across operating systems and
	different Java releases. The changes mean a more consistent
	look when you switch between Sun's 1.1, 1.2, and 1.3 releases
	of Java on a single operating system. There's a TextArea and
	TextField bug in Sun's current 1.3 release that ignores all
	background color changes to a readonly TextComponent, but the
	behavior, at least according to Java bug report 4403599, will
	eventually be fixed.

	---

	Part of the background color changes involved fixing our own
	Java code (in file YoixBodyComponent.java) so that it dealt
	with NULL background colors in a consistent way. In general
	storing NULL in the background (or foreground) field means
	the component takes its background or foreground color from
	the nearest container (e.g., Panel or Frame) that contains
	the component and has a non NULL background (or foreground)
	field. If there's no such container the component takes on a
	default. TextField, TextArea, and List components use white
	as the default background color, as does a Choice on Windows.
	Other components use the background and foreground fields in
	VM.screen dictionary as the defaults.

	    NOTE - the same changes will be applied to the font
		   field sometime soon (probably before our next
		   release). In addition we realize there a few
		   obscure cases that don't work quite right, but
		   we doubt anyone will stumble into them.

	Small, but incompatible change to the strsplit() builtin. The
	new behavior is documented in the reference page.

	---

	Types created using typedef, which is not currently documented,
	now inherit an appropriate typename.

	---

	The TableManager reference page now describes the text field,
	which is an important field that was accidentally omitted in
	our earlier documentation.

    Version 0.9.2 (1/10/01 - external release)
	Images are now supported. See the Image reference page for more
	details and examples. We tried to design a simple interface and
	eliminate the distinction between an off-screen drawable image
	and an image produced by an ImageProducer. We think you will be
	pleasantly surprised, particularly if you have ever used images
	in a Java program.

	---

	Any Frame, Dialog, Window, Panel, or Canvas can now cover its
	background with an image. It's also easy to automatically scale
	or tile the background with the image - just change the value
	stored in the backgroundhints field. See the reference pages for
	more details.

	---

	Most of the painting methods in Java's java.awt.Graphics class
	have been implemented as Yoix builtins and are now available in
	the yoix.graphics dictionary. See reference pages for builtins
	like drawLine() or fillPolygon() for more details and examples.

	---

	Selecting items in a List by storing an integer, string, or array
	in the List's selected field now makes the selected item visible.
	The last item selected by an array is currently the one that ends
	up visible.

	---

	Added a requestfocus field to the Yoix implementation of the AWT
	components (e.g., Button, Label, Frame) that can actually use it
	to gain or transfer the keyboard focus. requestfocus worked in
	version 0.9.1, but it was an optional field that could only be
	added in a declaration.

	---

	Addressed a TextField problem that showed up on some Unix systems
	that resulted in disappearing underscores and clipped descenders.
	The fixes are platform dependent and are currently only applied
	on Irix and some Linux systems.

	---

	Implemented builtins that provide some of the arbitrary precision
	arithmetic capabilities available in Java's java.math class. See
	the reference pages for builtins like bigAdd() or bigDivide() for
	more details.

	---

	The stringWidth() builtin has been documented and moved from the
	yoix.string dictionary to yoix.graphics.

	---

	Added builtin named cstring() to the yoix.string dictionary. See
	the reference page for more details.

	---

	Miscellaneous undocumented changes - mostly minor enhancements and
	bug fixes.

    Version 0.9.1 (11/15/00 - external release)

------------
Requirements
------------

You need JavaCC and a relatively recent version (1.1.6 or newer) of the
Java Development Kit (JDK or SDK) before you can build anything. Actually
we now strongly recommend that you run the Yoix interpreter using version
1.3.1, which has now been officially released by Sun. For JDK (or SDK) go
to

	http://java.sun.com/

and download one of Sun's official versions. If necessary, Linux users can
go to

	http://www.blackdown.org/

and find older releases. We used 1.1 for most of our early development and
testing, but version 1.3.1 now looks like the best choice (as long as you
ignore the deprecated messages from javac), In fact we used 1.3 to build
the jar files that we included in our last two releases.

JavaCC is a parser generator that belongs to WebGain. Just visit

	http://www.webgain.com/

and you can download it for free. We're most familiar with Version 1.1, but
our initial tests seem to indicate that Version 2.0 can also be used.

-------------
Building Yoix
-------------

We usually work on source files for a while and then type something like

	make RUNARGS='Tests/components.yx' run

to test our changes. You'll find a few test files in the Tests directory,
but you should build your own if you do anything significant. RUNARGS are
arguments that are handed to the interpreter, so we often also type

	make RUNARGS='-d1' run

when we want to start an interactive session and have the Yoix interpreter
dump the value of all expressions that also happen to be statements. Omit
the -d1 and you start an interactive session that's not nearly as noisy.

-----------------
Building yoix.jar
-----------------

If you just want a jar file type,

	make yoix.jar

or

	make JAVACFLAGS=-O yoix.jar

if you want an optimized version.

-------------------
Source Organization
-------------------

Our source file naming conventions are a bit cumbersome, but a single Java
package seemed appropriate, so we often used class names (i.e., file names)
to help impose some order.

    YoixAWTXXX
	Very low level implementation of an XXX using Java's AWT package.
	These are support classes that are only used

    YoixBodyXXX
	Low level implementation of a Yoix XXX Object. For example, you would
	look at YoixBodyArray.java to see how Yoix Arrays are implemented. A
	few of these classes (e.g., YoixBodyComponent and YoixBodyStream) are
	considerably more complicated. YoixBodyComponent is a huge class that
	implements all the Yoix versions of AWT Components (plus a few).

    YoixBuiltins
	Reserved builtins - they're always available and they can never be
	redefined.

    YoixBuiltinsXXX
	Builtins loaded in dictionary yoix.XXX

    YoixConstantsXXX
	Interfaces that define constants used in most of the source files.

