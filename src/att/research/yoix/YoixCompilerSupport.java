/*
 *  This software may only be used by you under license from AT&T Corp.
 *  ("AT&T").  A copy of AT&T's Source Code Agreement is available at
 *  AT&T's Internet website having the URL:
 *
 *    <http://www.research.att.com/sw/tools/yoix/license/source.html>
 *
 *  If you received this software without first entering into a license
 *  with AT&T, you have an infringing copy of this software and cannot
 *  use it without violating AT&T's intellectual property rights.
 */

package att.research.yoix;
import att.research.yoix.jvma.*;
import java.util.*;

public abstract
class YoixCompilerSupport

    implements YoixConstants

{

    //
    // Mostly special purpose methods called from assembly language that's
    // generated by YoixCompiler.
    //
    // If methods like YoixInterpreter.expressionArithmetic() were changed
    // to take different arguments then we could could reduce some overhead
    // in several of these methods - later.
    //

    ///////////////////////////////////
    //
    // YoixCompilerSupport Methods
    //
    ///////////////////////////////////

    public static void
    abortBadOperand() {

	VM.abort(BADOPERAND);
    }


    public static void
    abortIllegalJump() {

	//
	// Eventually should think about this. Error handling and tags will
	// need attention first.
	//

	VM.abort(ILLEGALJUMP);
    }


    public static void
    abortTypecheck() {

	VM.abort(TYPECHECK);
    }


    public static YoixObject
    assignObject(YoixObject obj, YoixObject dest, int index) {

	//
	// This duplicates what's currently done when the Yoix interpreter
	// handles an assignment expression.
	//
	// NOTE - the order of the arguments was picked to match what's on
	// the JVM stack whenever we call this method.
	//

	return((YoixObject)dest.put(index, obj, true).clone());
    }


    public static void
    assignObjectVoid(YoixObject obj, YoixObject dest, int index) {

	dest.put(index, obj, true);
    }


    public static YoixObject
    assignObject(YoixObject lval, YoixObject obj) {

	//
	// This duplicates what's currently done when the Yoix interpreter
	// handles an assignment expression.
	//
	// NOTE - the order of the arguments was picked to match what's on
	// the JVM stack whenever we call this method.
	//

	return((YoixObject)lval.put(lval.offset(), obj, true).clone());
    }


    public static void
    assignObjectVoid(YoixObject lval, YoixObject obj) {

	lval.put(lval.offset(), obj, true);
    }


    public static int
    declareVariable(SimpleNode node, String typename, int index, YoixStack stack) {

	SimpleNode  child;
	SimpleNode  dnode;
	SimpleNode  inode;
	YoixObject  lval;
	int         offset = -1;

	if (VM.isTypename(typename)) {
	    child = node.getChild(index);
	    dnode = child.getChild0();
	    inode = child.getChild1();
	    lval = YoixBodyBlock.newDvalue(dnode.getChild0().stringValue());
	    YoixInterpreter.declareVariable(lval, typename, dnode, inode, stack);
	    if (node.getChild0().type() != NAME)
		YoixInterpreter.qualifier(node.getChild0(), lval.get(), stack);
	    offset = lval.offset();
	} else VM.abort(BADTYPENAME, typename);

	return(offset);
    }


    public static void
    declareVariableVoid(SimpleNode node, String typename, int index, YoixStack stack) {

	SimpleNode  child;
	SimpleNode  dnode;
	SimpleNode  inode;
	YoixObject  lval;

	if (VM.isTypename(typename)) {
	    child = node.getChild(index);
	    dnode = child.getChild0();
	    inode = child.getChild1();
	    lval = YoixBodyBlock.newDvalue(dnode.getChild0().stringValue());
	    YoixInterpreter.declareVariable(lval, typename, dnode, inode, stack);
	    if (node.getChild0().type() != NAME)
		YoixInterpreter.qualifier(node.getChild0(), lval.resolve(), stack);
	} else VM.abort(BADTYPENAME, typename);
    }


    public static YoixObject
    expressionArithmetic(YoixObject left, YoixObject right, int op, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(left);
	stack.pushYoixObject(right);
	YoixInterpreter.expressionArithmetic(op, stack);

	return(stack.popYoixObject());
    }


    public static YoixObject
    expressionAttribute(SimpleNode node, YoixStack stack) {

	YoixInterpreter.expressionAttribute(node, stack);
	return(stack.popYoixObject());
    }


    public static YoixObject
    expressionBitwise(YoixObject left, YoixObject right, int op, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(left);
	stack.pushYoixObject(right);
	YoixInterpreter.expressionBitwise(op, stack);

	return(stack.popYoixObject());
    }


    public static YoixObject
    expressionCast(YoixObject obj, String typename, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushString(typename);
	stack.pushYoixObject(obj);
	YoixInterpreter.expressionCast(stack);

	return(stack.popYoixObject());
    }


    public static YoixObject
    expressionInitializer(SimpleNode node, YoixStack stack) {

	YoixInterpreter.expressionInitializer(node, stack);
	return(stack.popYoixObject());
    }


    public static boolean
    expressionInstanceof(YoixObject obj, String typename, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(obj);
	stack.pushString(typename);
	YoixInterpreter.expressionInstanceof(stack);

	return(stack.popYoixObject().booleanValue());
    }


    public static YoixObject
    expressionNew(SimpleNode node, YoixStack stack) {

	YoixInterpreter.expressionNew(node, stack);
	return(stack.popYoixObject());
    }


    public static YoixObject
    expressionPostDecrement(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPostDecrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPostDecrementVoid(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPostDecrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPostDecrement(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPostDecrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPostDecrementVoid(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPostDecrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPostIncrement(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPostIncrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPostIncrementVoid(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPostIncrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPostIncrement(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPostIncrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPostIncrementVoid(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPostIncrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPreDecrement(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPreDecrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPreDecrementVoid(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPreDecrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPreDecrement(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPreDecrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPreDecrementVoid(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPreDecrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPreIncrement(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPreIncrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPreIncrementVoid(YoixObject lval, YoixStack stack) {

	stack.pushYoixObject(lval);
	YoixInterpreter.expressionPreIncrement(stack);
	stack.popYoixObject();
    }


    public static YoixObject
    expressionPreIncrement(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPreIncrement(stack);

	return(stack.popYoixObject());
    }


    public static void
    expressionPreIncrementVoid(YoixObject dest, int index, YoixStack stack) {

	stack.pushLvalue(dest, index);
	stack.peekYoixObject().setResolve(true);
	YoixInterpreter.expressionPreIncrement(stack);
	stack.popYoixObject();
    }


    public static boolean
    expressionRelational(YoixObject left, YoixObject right, int op, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(left);
	stack.pushYoixObject(right);
	YoixInterpreter.expressionRelational(op, stack);

	return(stack.popYoixObject().booleanValue());
    }


    public static boolean
    expressionRERelational(YoixObject left, YoixObject right, int op, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(left);
	stack.pushYoixObject(right);
	YoixInterpreter.expressionRERelational(op, stack);

	return(stack.popYoixObject().booleanValue());
    }


    public static YoixObject
    expressionShift(YoixObject left, YoixObject right, int op, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(left);
	stack.pushYoixObject(right);
	YoixInterpreter.expressionShift(op, stack);

	return(stack.popYoixObject());
    }


    public static YoixObject
    expressionUnary(YoixObject right, int op, YoixStack stack) {

	//
	// NOTE - we also currently ignoring the YoixObject.resolve() call
	// that's triggered by stack.popRvalue(). Think we can get around
	// it in YoixCompiler when we start dealing with lvalues.
	//

	stack.pushYoixObject(right);
	YoixInterpreter.expressionUnary(op, stack);

	return(stack.popYoixObject());
    }


    public static YoixObject
    functionCall(YoixObject lval, YoixObject argv[], YoixStack stack) {

	YoixObject  tag;
	int         argc;
	int         n;

	//
	// NOTE - we may not be getting an lvalue as the first argument, so
	// the compiler code might need checking.
	//
	// NOTE - the direct call of execute() made here should be OK, but
	// if there are any problems you can change it to:
	//
	//     return((YoixObject)lval.execute(argv).clone());
	//
	// Basically all we're doing eliminating one method call and making
	// the assumption that lval is a pointer.
	//

	if ((argc = argv.length) > 0) {
	    for (n = 0; n < argc; n++) {
		if (argv[n].canUnroll()) {
		    argv = YoixMisc.unrollArray(argv);
		    break;
		}
	    }
	}

	if ((tag = stack.peekYoixObject(null)) != null) {
	    if (tag.isTag() && lval.isFunctionPointer())
		((YoixBodyTag)tag.body()).setFunctionName(lval.name());
	}

	return((YoixObject)(((YoixInterfacePointer)lval.value[0]).execute(lval.offset(), argv, lval).clone()));
	
    }


    public static YoixObject
    lvalue(SimpleNode node, YoixStack stack) {

	YoixInterpreter.lvalue(node, stack);
	return(stack.popYoixObject());
    }


    public static YoixObject
    lvalueByExpression(YoixObject left, YoixObject right) {

	YoixObject  lval = null;

	left.resolve();

	if (right.isInteger()) {
	    lval = YoixObject.newLvalue(left, left.offset() + right.intValue());
	    lval.setResolve(true);
	} else if (right.isString()) {
	    lval = YoixObject.newLvalue(left, right.stringValue());
	    lval.setResolve(true);
	} else VM.abort(TYPECHECK);

	return(lval);
    }


    public static YoixObject
    lvalueByName(YoixObject obj, String name) {

	YoixObject  lval;

	lval = YoixObject.newLvalue(obj.resolve(), name);
	lval.setResolve(true);

	return(lval);
    }


    public static void
    lvalueIncrement(int incr, YoixObject lval) {

	lval.incrementLvalue(incr);
    }


    public static YoixObject
    newBlockLvalue(String name) {

	return(YoixBodyBlock.newLvalue(name));
    }


    public static YoixObject
    newBlockLvalue(int level, int offset) {

	return(YoixBodyBlock.newLvalue(level, offset));
    }


    public static YoixObject
    newGlobalLvalue() {

	YoixObject  lval;

	lval = YoixObject.newLvalue(YoixBodyBlock.getGlobal(), 0);
	lval.setResolve(false);

	return(lval);
    }


    public static YoixObject
    newThisLvalue() {

	YoixObject  lval;

	lval = YoixObject.newLvalue(YoixBodyBlock.getThis(), 0);
	lval.setResolve(false);

	return(lval);
    }


    public static int
    pickSwitchStatementIndex(SimpleNode node, YoixObject expr) {

	//
	// This method probably can be eliminated (assuming permissions of
	// the real version are OK).
	//

	return(YoixInterpreter.pickSwitchStatementIndex(node, expr));
    }


    public static void
    popForEachBlock(YoixStack stack) {

	//
	// Unfortunately this method can now provide access to the stack
	// that wasn't previously available - investigate later.
	// 

	stack.popBlock();
    }


    public static void
    popTag(YoixStack stack) {

	stack.popYoixObject();
    }


    public static YoixObject
    pushForEachBlock(YoixObject obj, String name, YoixStack stack) {

	stack.pushForEachBlock(name, (YoixObject)obj.clone());
	return(YoixBodyBlock.getBlockValues(0));
    }


    public static void
    pushTag(SimpleNode node, YoixStack stack) {

	stack.pushYoixObjectClone(node.getTaggedLocation());
	if (VM.bitCheck(N_DEBUG, DEBUG_TAGGEDSTATEMENT))
	    VM.print(N_STDOUT, stack.peekYoixObject());
    }


    public static YoixObject
    statementBeginCompound(SimpleNode node, YoixStack stack) {

	YoixObject  names;
	YoixObject  values;

	//
	// Unfortunately this method can now provide access to the stack
	// that wasn't previously available - investigate later.
	// 

	names = node.getLocalDict();
	values = YoixObject.newArray(names.length());
	stack.pushLocalBlock(names, values, false);
	return(values);
    }


    public static void
    statementEndCompound(YoixStack stack) {

	//
	// Unfortunately this method can now provide access to the stack
	// that wasn't previously available - investigate later.
	// 

	stack.popBlock();
    }


    public static void
    statementEOF(YoixStack stack) {

	stack.jumpToEOF();
    }


    public static void
    statementExit(YoixObject value, YoixStack stack) {

	stack.pushYoixObject(value);
	stack.jumpToExit();
    }


    public static void
    statementFinally(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementFinally(node, stack);
    }


    public static void
    statementFunction(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementFunction(node, stack);
    }


    public static void
    statementImport(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementImport(node, stack);
    }


    public static void
    statementInclude(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementInclude(node, stack);
    }


    public static void
    statementNamedBlock(SimpleNode node, int type, YoixStack stack) {

	YoixInterpreter.statementNamedBlock(node, type, stack);
    }


    public static void
    statementQualifier(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementQualifier(node, stack);
    }


    public static void
    statementSave(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementSave(node, stack);
    }


    public static void
    statementSynchronized(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementSynchronized(node, stack);
    }


    public static void
    statementTry(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementTry(node, stack);
    }


    public static void
    statementTypedef(SimpleNode node, YoixStack stack) {

	YoixInterpreter.statementTypedef(node, stack);
    }


    public static void
    storeDouble(double value, YoixObject dest, int index) {

	//
	// The isPointer() check is probably unnecessary. Also eventaully
	// may consider adding a "void" version of put to the classes that
	// implement YoixInterfacePointer.
	//

	if (dest.isPointer())
	    ((YoixInterfacePointer)dest.value[0]).put(index, YoixObject.newDouble(value), false);
	else VM.abort(TYPECHECK);
    }


    public static void
    storeInt(int value, YoixObject dest, int index) {

	//
	// The isPointer() check is probably unnecessary. Also eventaully
	// may consider adding a "void" version of put to the classes that
	// implement YoixInterfacePointer.
	//

	if (dest.isPointer())
	    ((YoixInterfacePointer)dest.value[0]).put(index, YoixObject.newInt(value), false);
	else VM.abort(TYPECHECK);
    }


    public static void
    storeObject(YoixObject obj, YoixObject dest, int index) {

	//
	// The isPointer() check is probably unnecessary. Also eventaully
	// may consider adding a "void" version of put to the classes that
	// implement YoixInterfacePointer.
	//

	if (dest.isPointer())
	    ((YoixInterfacePointer)dest.value[0]).put(index, obj != null ? obj : YoixObject.newNull(), false);
	else VM.abort(TYPECHECK);
    }


    public static void
    typecheckIfNotPointer(YoixObject obj) {

	if (obj.isPointer() == false)
	    VM.abort(TYPECHECK);
    }
}

