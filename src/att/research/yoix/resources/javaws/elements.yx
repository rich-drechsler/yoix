//
// This is a stand-alone application that includes most of ychart.yx and
// displays several interactive versions of the periodic table, including
// one puzzle, a chart of the naturally occurring isotopes, and a fairly
// simple chart of the nuclides that lists no more than one decay mode per
// isotope. It was created by combining almost all of ychart.yx with data
// for isotopes that was organized so ychart.yx would be happy and it's all
// packed into a single file so this is the only place you have to look if
// you're curious and want to understand how it works. That also means it's
// the only file you need if you want to move it somewhere else (e.g., a web
// server) or send it to a friend.
//
// You can run this script, assuming it's named elements.yx, using
//
//	yoix elements.yx
//
// By default the Yoix interpreter doesn't impose security restrictions on
// scripts with names that don't end in .yxs, however the --applet command
// line option asks the interpreter to run the script as an applet. In other
// words,
//
//	yoix --applet elements.yx
//
// runs elements.yx as an applet, while
//
//	yoix elements.yx
//
// runs elements.yx as a "completely trusted application", which means it
// can (among other things) read and write local files, execute programs on
// your computer, and establish connections to sites on the internet. Move
// or copy the script to elements.yxs and
//
//	yoix elements.yxs
//
// and
//
//	yoix --applet elements.yxs
//
// both run as Yoix applets.
//
// All the data needed to build and display the tables is included in this
// file, so most things work in applet mode. The main exceptions are external
// web sites that you can connect to using the "Open" button that's located
// in the upper right corner of the screen. By default the interpreter won't
// let you open them unless you explicitly allow it before requesting applet
// mode, which means specially crafted -S options must precede the --applet
// option if you want to access external web sites. For example,
//
//	yoix -Sallow:connect:www.webelements.com:80 --applet elements.yx
//
// runs the script as an applet, but still lets you read web pages on the
// webelements site, while
//
//	yoix -Sallow:connect:en.wikipedia.org:80 --applet elements.yx
//
// lets you connect to the wikipedia site (take a look at the URLs mentioned
// in the GetExternalSiteURL() function that's defined later in this script).
// Precede --applet by both -S options and you will be able to read web pages
// on the wikipedia and webelements sites.
//
// The -S option also lets you ask to be prompted for an answer when there's
// a security check, so
//
//	yoix -Sprompt:connect --applet elements.yx
//
// will show a dialog with information about the connection whenever there's
// a connect security check. Prompting is interesting and works nicely with
// connect, but it's not appropriate for every security "category" because
// it occasionally causes deadlock that we suspect may be unavoidable.
//

import yoix.*.*;
import yoix.apple.*;

//
// The periodic table was our first example, and even though it included a
// 2500 cell "Chart of the Nuclides", Yoix code on its own handled it all
// pretty well. Our Unicode example, which currently displays 16K cells at
// a time, worked as a pure Yoix application but it just wasn't responsive
// enough, so we built a small Yoix module (i.e,, special Java code that's
// accessible from Yoix scripts) to handle some of the time-consuming tasks,
// and that's what we import next.
//
// NOTE - if you're curious about the module grab our source package and
// and you'll find the ychart module in att/research/yoix/ychart.
//

import yoix.ychart.*;

//
// The next two lines (as we discussed in the tutorial) are often set in
// production scripts. You can use the -g command line option to force
// line number and source file info back into into error messages, which
// effectively overrides VM.addtags.
//

VM.create = FALSE;		// require declarations for variables
VM.addtags = FALSE;		// don't save line and source file info

//
// We start with a few variable definitions, some of which can be changed
// by command line options. Others (e.g., SHARESELECTION) are initialized
// here, but really should be set by custom application code.
//
// NOTE - in the default Yoix coordinate system a length of 72 corresponds
// to one inch on your screen, so when you see expressions like 2*72 it's
// usually safe think 2 inches. You may also notice that we usually don't
// carry out multiplications or divisions when we're working with numbers
// that represent lengths in the default coordinate system, so we tend to
// write 72.0/8 instead of 9.
//
// NOTE - we used Unicode character \x00ae in the TITLE string. You'll see
// it displayed as a registered mark in the title. You can use the YChart
// YChart application that displays Unicode characters to find characters
// that you might want to display in an application.
//

String TITLE = "Yoix\x00ae YChart";
String PROGRAM = "yoix";
int    PRELOAD_CHARTS = FALSE;
int    REVERSE_VIDEO = FALSE;

String SCREEN_FONT = "Lucida-bold-12";
String CHART_FONT = "Lucida-bold-12";

Color SCREEN_BACKGROUND = yoix.xcolor.gray85;
Color SCREEN_FOREGROUND = Color.black;
Color TEXT_BACKGROUND = Color.white;
Color TEXT_FOREGROUND = Color.black;

double CHART_WIDTH = VM.screen.width - 2*72.0;
double CHART_HEIGHT = min(0.6*(VM.screen.width - 2*72.0), VM.screen.height - 72.0);
double CHART_MARGIN = 72.0/8;

double CELL_ASPECT_RATIO = -1;			// width/height (uninitialized if negative)
double CELL_BORDER = -1;			// for raised/lowered button (uninitialized if negative)
double CELL_MARGIN = -1;			// interior margin for each cell (uninitialized if negative)
double CELL_SEPARATION = -1;			// fraction of cell height or width (uninitialized if negative)

double LINEWIDTH = 1.5;				// default linewidth for path
double GRIDLINEWIDTH = 1.0;			// width of grid lines - when drawn
double SYNCDELAY = 0.25;			// delay, in seconds, for syncing cell detail with selected cell
double CELLDETAILWIDTH = 3.0*72.0;		// preferred width of the cell detail pane
String INITIALCELL = NULL;			// name of the initially selected cell
int    ARROW_MARKS = FALSE;		        // controls initial mark style
int    MAXSTEPS = 5;				// number of steps used to automatically move cells home
int    PAINT_USECLIP = TRUE;			// to select cells in Paint()
int    SHARESELECTION = TRUE;			// sometimes changed by application code
int    SHOWEXTERNALPANEL = TRUE;		// controls initial visibility of the external url panel
int    SHOWFINDPANEL = FALSE;		        // controls initial visibility of the find panel
int    TITLESET = FALSE;                        // used by SetFrameTitle
int    USEYCHART = TRUE;
int    VALIDATEYCHART = TRUE;
int    YCHARTWARNING = TRUE;

String BROWSER_COMMAND = NULL;
int    SET_BROWSER_COMMAND = TRUE;

//
// These are a few common menu itme labels that can appear in all charts.
//

String ALL_OFF = "All Off";
String ALL_ON = "All On";
String COLUMN_LABELS = "Show Column Labels";
String ROW_LABELS = "Show Row Labels";

//
// A late addition that probably belongs somewhere else - we'll look into
// it in the next release.
//

int FILTER_MENU_SIZE = CHART_HEIGHT/14;

//
// Several Yoix related URLs that are only used by the Help menu. Set them
// to NULL and the menu items will be permanently hidden. Incidentally, we
// prefer the shorter URLs, but they're equivalent to
//
//	http://www.research.att.com/sw/tools/yoix/
//	http://www.research.att.com/sw/tools/yoix/yoix_tutorial.html
//
// which are considerably longer and much more obscure.
//
// NOTE - these websites no longer work, so both are currently set to NULL.
//

String YOIXHOME = NULL;
String YOIXTUTORIAL = NULL;

//
// The next three functions are pretty simple, but there's quite a bit you
// can learn from them, so we included lots of comments. The first two are
// for errors and the last processes the script's command line options.
//

Die(String format, ...) {
    String message;

    //
    // This function combines a format string and any optional arguments
    // into a string that's written to standard error and displayed in a
    // message dialog (via showMessageDialog()) and exits after the user
    // dismisses the dialog. The message itself is created by strfmt(),
    // which handles format strings and arguments exactly like printf().
    //
    // This is a short function that uses several subtle Yoix programming
    // techniques that we'll try to explain. The ... in the argument list
    // means Die() can be called with a variable number of arguments, as
    // long as there's at least one string that we can reference using the
    // name "format". In other words
    //
    //    Die("Testing 1, 2, 3");
    //
    // and
    //
    //    Die("Testing %d, %d, %d", 1, 2, 3);
    //
    // are allowed and display exactly the same error message.
    //
    // The test in the if statement is equivalent to
    //
    //    if (format != NULL)
    //
    // so the call
    //
    //    Die(NULL);
    //
    // means quit without giving an explanation. The long version of the
    // test (i.e., format != NULL) is clearer and usually preferred, but
    // the short version will run slightly faster, however the difference
    // is so small that in this case you could never measure it (you only
    // get one chance to die).
    //
    // If you're new to Yoix the next line
    //
    //    message = strfmt(unroll(&format));
    //
    // is undoubtedly confusing. Function arguments are always stored in
    // an array that can be referenced by the name argv. The first element
    // in that array (i.e., argv[0]) is the function's name, so our format
    // argument would be argv[1]. Taking the address of format returns a
    // "pointer" to where format is stored (i.e., argv[1]).
    //
    // The last piece of the puzzle is unroll(), which is a builtin that
    // gets special treatment by the Yoix interpreter when it's used in a
    // function call. Normally unroll returns an array, but in a function
    // call the interpreter decides that the individual elements of that
    // array (rather than the array itself) should be the arguments in the
    // function call. So when we call
    //
    //     Die("Testing %d, %d, %d", 1, 2, 3);
    //
    // the unroll() builtin fools strfmt() into believing the call really
    // was,
    //
    //     strfmt("Testing %d, %d, %d", 1, 2, 3);
    //
    // which is exactly what we want.
    //

    if (format) {
	message = strfmt(unroll(&format));
	fprintf(stderr, "%s: %s\n", PROGRAM, message);
	showMessageDialog(defined("mainscreen") ? mainscreen : NULL, message, toUpperCase(PROGRAM) + " Error", ERROR_MESSAGE);
    }
    exit(1);
}

Warn(String format, ...) {
    String message;

    //
    // Generates a warning message, exactly the way Die() does, but omits
    // the exit() so the program continues after the warning is issued and
    // the user dismisses the dialog.
    //

    if (format) {
	message = strfmt(unroll(&format));
	fprintf(stderr, "%s: %s\n", PROGRAM, message);
	showMessageDialog(defined("mainscreen") ? mainscreen : NULL, message, toUpperCase(PROGRAM) + " Warning", WARNING_MESSAGE);
    }
}

Options() {
    Option option;
    int    ch;

    //
    // This function handles the command line options and it's all pretty
    // standard stuff, however there's something important to pay attention
    // to here. Every function defines an array named argv and an integer
    // named argc that are always available but only contain information
    // about the function call itself. Command line options and arguments
    // also end up in an array named argv and an integer named argc, but
    // they're defined in the global scope, so we have to prefix argv and
    // argc with "global.".
    //
    // NOTE - command line options usually can be introduced by '-' or '+'
    // (see optstr discussion in the Option reference page for more info)
    // and you may notice at least two options currently use the initial
    // character, which is available as option.optchar, to pick the value
    // that's assigned to a variable.
    //
    // NOTE - try a few of these options. For example,
    //
    //     yoix elements.yxs +r
    //
    // should start with the chart drawn on a white background and
    //
    //     yoix elements.yxs -s0.1
    //
    // adds a small separation (one tenth of a cell) between each cell. As
    // you can see below, options are processed in a loop so you can use
    // as many as you want on the command line.
    //

    while ((ch = option.getopt(global.argv, "a:b:f:m:prs:uw:yB:P:T:Y")) != -1) {
	switch (ch) {
	    case 'a':
		CELL_ASPECT_RATIO = max(atof(option.optarg), 0.0);
		break;

	    case 'b':
		CELL_BORDER = max(atof(option.optarg), 0.0);
		break;

	    case 'f':
		CHART_FONT = option.optarg;
		break;

	    case 'm':
		CELL_MARGIN = max(atof(option.optarg), 0.0);
		break;

	    case 'p':
		PRELOAD_CHARTS = (option.optchar == '+');
		break;

	    case 'r':
		REVERSE_VIDEO = (option.optchar == '+');
		break;

	    case 's':
		CELL_SEPARATION = max(atof(option.optarg), 0.0);
		break;

	    case 'u':
		PAINT_USECLIP = (option.optchar == '+');
		break;

	    case 'w':
		LINEWIDTH = atof(option.optarg);
		break;

	    case 'y':
		USEYCHART = (option.optchar == '+');
		break;

	    case 'B':
		BROWSER_COMMAND = option.optarg;
		SET_BROWSER_COMMAND = FALSE;
		break;

	    case 'P':
		PROGRAM = option.optarg;
		break;

	    case 'T':
		TITLE = option.optarg;
		TITLESET = TRUE;
		break;

	    case 'Y':
		USEYCHART = (option.optchar == '+');
		YCHARTWARNING = FALSE;
		break;

	    case '?':
		Die("%s", option.opterror);
		break;

	    default:
		Die("missing case for option %c%c", option.optchar, ch);
		break;
	}
    }
    global.argc -= option.optind;
    global.argv += option.optind;
}

//
// We want to handle command line options now so the values stored in the
// variables that we've already defined can be changed before the rest of
// the program gets a chance to use them, so the next thing we do is call
// Options().
//

Options();

//
// Colors used in chart cells are chosen from the CellColors dictionary,
// which is defined next. Most are for cell backgrounds, but all of them
// should be coordinated. We picked simple names, like RED and BLUE, for
// colors despite the fact that they don't match their namesakes.
//

Dictionary CellColors[0, ...] = {	// the ... here means no upper bound
    //
    // Definitions for BLACK, WHITE, and LIGHTGRAY are required no matter
    // what charts are being displayed because they're needed in several
    // painting functions defined in the common chart code.
    //
    // NOTE - don't forget to test reverse video mode if you change these
    // colors.
    //

    Color BLACK = Color.black;				// required
    Color WHITE = Color.white;				// required
    Color LIGHTGRAY = yoix.xcolor.gray93;		// required

    Color MEDIUMLIGHTGRAY = yoix.xcolor.gray75;
    Color GRAY = yoix.xcolor.gray65;
    Color MEDIUMDARKGRAY = yoix.xcolor.gray55;
    Color DARKGRAY = yoix.xcolor.gray45;
    Color UNKNOWN = yoix.xcolor.gray70;

    Color RED = getHSBColor(0.025, 0.50, 0.75);
    Color TAN = getHSBColor(0.1, 0.25, 0.75);
    Color BROWN = getHSBColor(0.1, 0.50, 0.75);
    Color YELLOW = getHSBColor(0.17, 0.50, 0.75);
    Color GREEN = getHSBColor(0.40, 0.25, 0.75);
    Color CYAN = getHSBColor(0.50, 0.50, 0.75);
    Color BLUE = getHSBColor(0.57, 0.50, 0.75);
    Color MAGENTA = getHSBColor(0.85, 0.25, 0.75);

    Color GOLD = getHSBColor(0.15, 0.75, 0.975);
};

//
// We manage most fonts in a simple cache, which in this case is a growable
// dictionary named FontCache that's populated and used by GetCachedFont(),
// which is defined below. It's not something you normally do, but in this
// script there are places where we want to compare one font to another and
// do it quickly. When you create fonts using declarations and compare them
// using == they usually won't match, even if identical specifications were
// used to create the fonts. For example, do something like
//
//	Font f1 = {String name = "Times-Roman-10";};
//	Font f2 = {String name = "Times-Roman-10";};
//
// and then test equality using
//
//	if (f1 == f2)
//	    yoix.stdio.printf("fonts match\n");
//	else yoix.stdio.printf("fonts don't match\n");
//
// and you'll see what we mean. However, change the declarations to
//
//	Font f1 = {String name = "Times-Roman-10";};
//	Font f2 = f1;
//
// and run the equality test and you'll find they now match. In this case
// f2 "points to" or "references" the object that the interpreter created
// when it processed the declaration of f1.
//

Dictionary FontCache[0, ...];		// the ... here means no upper bound

//
// The next few lines are simple function definitions that can be used to
// select cached fonts that are suitable for a particular purpose (e.g.,
// for the text in a chart cell that's supposed to be big relative to the
// other text in that cell). The definitions are made via expressions and
// in these definitions the expression is the appropriate GetCachedFont()
// call.
//

GetLargeCellFont() = GetCachedFont("CHART_FONT", 2.8);
GetNormalCellFont() = GetCachedFont("CHART_FONT", 1.0);
GetSmallCellFont() = GetCachedFont("CHART_FONT", 0.67);
GetTinyCellFont() = GetCachedFont("CHART_FONT", 0.5);
GetChartFont() = GetCachedFont("CHART_FONT", 1.0);
GetHeadingFont() = GetCachedFont("SCREEN_FONT", 1.4);
GetScreenFont() = GetCachedFont("SCREEN_FONT", 1.0);
GetScaledChartFont(double scale) = GetCachedFont("CHART_FONT", scale);

GetCachedFont(String prefix, double scaling) {
    String name = (scaling == 1.0) ? prefix : prefix + toString(scaling);

    //
    // Creates a unique name for a font by combining prefix and scaling and
    // then looks for that name in FontCache. If there's no definition for
    // name make sure there's a font associated with prefix and then use its
    // scalefont() builtin to create the font we're looking for.
    //
    // NOTE - notice that we used
    //
    //		prefix + toString(scaling)
    //
    // instead of
    //
    //		prefix + scaling
    //
    // to create the name. The obvious reason is that adding a double to a
    // string isn't allowed (try it and you'll get a badoperand error), so
    // we use toString(scaling) to create a string from scaling and adding
    // two strings is allowed and does what you should expect. But even if
    // scaling was an integer, which would eliminate the badoperand error,
    // we still would need toString(scaling) because adding an integer to
    // a String (which is a pointer) behaves just like C and increments or
    // decrements that pointer rather than automatically concatenating the
    // string reprentation of the integer to the string (as happens in Java).
    //
    // NOTE - Another reasonable way to generate the name would be to use
    // the strfmt() builtin.
    //

    if (!defined(name, FontCache)) {
	if (!defined(prefix, FontCache)) {
	    if (defined(prefix, global))	// FALSE is a mistake but we'll cover it up
		FontCache[prefix] = new Font {String name = global[prefix];};
	    else FontCache[prefix] = new Font {String name = "Lucida-bold-12";};
	}
	FontCache[name] = FontCache[prefix].scalefont(scaling);
    }
    return(FontCache[name]);
};

//
// The "normal" cell font is used so often that we decided to build it now
// and save a reference so it can be accessed without requiring a function
// call. Only makes a noticeable difference in big charts and even then it
// won't save all that much.
//

Font NormalCellFont = GetNormalCellFont();

//
// The next few functions were borrowed from our YWAIT package, but in most
// cases we made changes that were appropriate for this script.
//

CopyFromSystemClipboard(Object dest) {
    Clipboard clipboard;
    Object    contents;
    Array     ends;

    //
    // Gets the contents of the system clipboard and decides if it can be
    // copied into dest. Right now the code only supports copying strings
    // into an editable JTextField, JTextArea, or JTextPane.
    //

    if (dest != NULL) {
	if ((clipboard = GetSystemClipboard()) != NULL) {
	    if ((contents = clipboard.contents) != NULL) {
		if (contents instanceof String) {
		    if (dest instanceof JTextField || dest instanceof JTextArea || dest instanceof JTextPane) {
			if (dest.edit) {
			    ends = dest.selectedends;
			    if (ends[1] > ends[0])
				deleteText(dest, ends[0], ends[1] - ends[0]);
			    insertText(dest, contents, dest.caret);
			}
		    }
		}
	    }
	}
    }
}

CopyToSystemClipboard(Object source) {
    Clipboard clipboard;
    Object    contents;

    //
    // Copies source to the clipboard if it's a String, otherwise it must
    // be a JTextField, JTextArea, or JTextPane and in that case we copy
    // the current selection, if there is one, to the system clipboard,
    // except when source is a JTextField that has a nonzero echo field.
    //

    if ((clipboard = GetSystemClipboard()) != NULL) {
	if (source instanceof String)
	    contents = source;
	else if (source instanceof JTextField)
	    contents = (source.echo == 0) ? source.selected : NULL;
	else if (source instanceof JTextArea || source instanceof JTextPane)
	    contents = source.selected;
	if (contents != NULL)
	    clipboard.setContents(contents);
    }
}

DragGestureRecognized(e) {
    Dictionary cell;
    Array      ends;
    int        index;

    //
    // A generic dragGestureRecognized() event handler that lets selected
    // Swing components serve as the source for drag and drop operations
    // when this function is assigned to the dragGestureRecognized() event
    // handler for those components. Current versions of Yoix require that
    // you also store NULL in each component's transferhandler field before
    // this custom dragGestureRecognized() event handler will be activated.
    // For example
    //
    //     JTextArea ta = {
    //         String text = "This is a test";
    //         Object transferhandler = NULL;
    //
    //         Function dragGestureRecognized = DragGestureRecognized;
    //     };
    //
    // creates a JTextArea that uses this function to start a drag and drop
    // operation.
    //
    // NOTE - in a function "this" refers to the compound object (i.e., an
    // object, like a Dictionary or JTextArea, that associates names with
    // values) that contains the definition of the function that's being
    // executed, so in our example "this" refers to the JTextArea that we
    // named "ta" when its dragGestureRecognized() function is executed.
    //
    // NOTE - Yoix supports Swing's automatic drag handling, but we usually
    // prefer the behavior that we get from custom event handlers like this
    // one. Take a look at the description of dragenabled in the reference
    // pages for Swing components for more information.
    //

    if (this instanceof JTextArea || this instanceof JTextField || this instanceof JTextPane) {
	//
	// The checks make sure we only start dragging (by returning
	// a non-NULL value) if the event happened inside the current
	// selection.
	//
	if (!(this instanceof JTextField) || this.echo == 0) {
	    if ((ends = this.selectedends) != NULL) {
		index = this.viewToModel(e.location);
		if (index >= ends[0] && index < ends[1])
		    e.visual = selected;
	    }
	}
    } else if (this instanceof JCanvas) {
	if (defined("dragtext", this))
	    e.visual = this.dragtext;
    } else if (defined("text", this)) {
	//
	// This will cover quite a few other components, but it may not
	// be what you want. We look for a field named dragtext first and
	// use it if it's defined and not NULL, which gives the component
	// a way to drag something other than what's actually displayed.
	//
	e.visual = (defined("dragtext", this) && this.dragtext != NULL) ? this.dragtext : this.text;
    }
    return(e.visual);
}

GetSystemClipboard() {
    Clipboard clipboard = NULL;

    //
    // Wraps the getSystemClipboard() call in a try/catch to trap security
    // exceptions that might be triggered if the script is running as an
    // applet. Adding
    //
    //     -Sallow:clipboard
    //
    // to the command line options used to start the Yoix interpreter will
    // enable clipboard access provided it precedes the --applet option.
    //

    try {
	clipboard = getSystemClipboard();
    }
    catch(e) {
	Warn(e.message);
    }
    return(clipboard);
}

KeyPressed(e) {
    //
    // A generic keyPressed() event handler that can be used to add keyboard
    // control over cut and paste to selected Swing components by assigning
    // this function to component's keyPressed() event handler. For example,
    //
    //     JTextArea ta = {
    //         String text = "This is a test";
    //
    //         Function keyPressed = KeyPressed;
    //     };
    //
    // creates a JTextArea and that uses this function as its keyPressed()
    // event handler.
    //
    // Notice that some system dependent code is used here. On a Mac users
    // should hold the META key to initiate the copy or paste, and if we're
    // using the Windows look and feel (which is only available on Windows)
    // we skip the paste because it's been done for us.
    //

    if (e.modifiersdown & CTRL_DOWN_MASK || (ISMAC && (e.modifiersdown & META_DOWN_MASK))) {
	switch (e.keycode) {
	    case KeyCode.VK_C:
		CopyToSystemClipboard(this);
		break;

	    case KeyCode.VK_V:
		if (strcasecmp(VM.screen.uimanager.lookandfeel, "Windows"))
		    CopyFromSystemClipboard(this);
		break;
	}
    }
}

//
// The next function is used to build simple icons that can be displayed on
// JButtons. The code originally came from our YWAIT package, but it's been
// extensively modified and simplified for use in this script. Even so it's
// still a little tricky and not particularly important, so we're not going
// to expend much energy explaining it and you shouldn't worry about trying
// to follow this part.
//

BuildControlIcon(int icontype, double width, double height, Color iconcolor, ...) {
    //
    // This function returns an image to the caller that paints itself with
    // a simple shape (i.e., triangle or square) that's suitable for use as
    // the icon displayed by a JButton. The caller can supply an optional
    // scaling factor, which is 0.6 by default, that controls the amount of
    // unused space around the outside of the image. In most cases 0.6 is
    // reasonable, however you may want to increase it for images that will
    // be displayed in very small buttons.
    //

    Image image = {
	int type = TYPE_RGB_ALPHA;	// alpha - so button shows through

	Dimension size = {
	    double width = width;
	    double height = height;
	};

	Graphics graphics = {
	    int linejoin = JOIN_MITER;
	    int linecap = CAP_BUTT;
	    int antialiasing = TRUE;
	};

	Point midpoint = {
	    double x = width/2;
	    double y = height/2;
	};

	Color iconcolor = iconcolor;
	int   icontype = icontype;
	int   side = ((argc > 5) ? argv[5] : 0.6)*min(width, height);

	paint(Rectangle rect) {
	    graphics {
		erasedrawable(0.0);		// make a transparent image
		moveto(midpoint.x, midpoint.y);

		switch(icontype) {
		    case '^':
			appendpath(DrawTriangle(1.0, 1.0, 0));
			break;

		    case 'v':
			appendpath(DrawTriangle(1.0, 1.0, 180));
			break;

		    case '<':
			appendpath(DrawTriangle(1.0, 1.0, -90));
			break;

		    case '>':
			appendpath(DrawTriangle(1.0, 1.0, 90));
			break;

		    case 'x':
			appendpath(DrawX(1.0, 1.0, 0));
			break;

		    default:
			appendpath(DrawSquare(0.75, 0.75, 0));
			break;
		}

		foreground = iconcolor;
		fill();
	    }
	}

	DrawSquare(double sx, double sy, double angle) {
	    double dx = side/2;
	    Path   path;

	    path {		// named block
		moveto(0, 0);
		rmoveto(dx, dx);
		rlineto(-side, 0);
		rlineto(0, -side);
		rlineto(side, 0);
		rlineto(0, side);
		closepath();
		moveto(0, 0);
		if (sx != 1 || sy != 1)
		    scalepath(sx, sy);
		if (angle != 0)
		    rotatepath(angle);
	    }
	    return(path);
	}

	DrawTriangle(double sx, double sy, double angle) {
	    double dx = side/2;
	    double dy = sqrt(3)*side/4;
	    Path   path;

	    path {		// named block
		moveto(0, 0);
		rmoveto(dx, dy);
		rlineto(-side, 0);
		rlineto(dx, -2 * dy);
		rlineto(dx, 2 * dy);
		closepath();
		moveto(0, 0);
		if (sx != 1 || sy != 1)
		    scalepath(sx, sy);
		if (angle != 0)
		    rotatepath(angle);
	    }
	    return(path);
	}

	DrawX(double sx, double sy, double angle) {
	    double dx = 0.6*midpoint.x;
	    double dy = 0.6*midpoint.y;
	    double lw = dx/6.0;
	    Path   path;

	    path {		// named block
		moveto(-dx, -dy);
		rmoveto(lw, -lw);
		rlineto(2*dx, 2*dy);
		rlineto(-2*lw, 2*lw);
		rlineto(-2*dx, -2*dy);
		closepath();
		moveto(dx, -dy);
		rmoveto(lw, lw);
		rlineto(-2*dx, 2*dy);
		rlineto(-2*lw, -2*lw);
		rlineto(2*dx, -2*dy);
		closepath();
		moveto(0, 0);
		if (sx != 1 || sy != 1)
		    scalepath(sx, sy);
		if (angle != 0)
		    rotatepath(angle);
	    }
	    return(path);
	}
    };
    return(image);
}

////////////////////////////
//
// Constructor Section
//
////////////////////////////

//
// The next function creates the internal representation of a chart, as a
// big dictionary, that's returned to the caller. In other words, this is
// the function that's called whenever we need a new chart. The dictionary
// itself, at least the one that you can see in ConstructChart(), spans at
// least 3000 lines and is a big part of the reusable code that can handle
// different kinds of charts (not just periodic tables). Most of the code
// that has to be written for a new application involves implementations
// of the 20 (or so) "Application Functions" defined in ConstructChart().
//

ConstructChart(Dictionary chartdata, String model, Pointer clearcache, Pointer updatestatus) {
    //
    // This function first combines the reusable code in the growable "chart"
    // dictionary that's declared below with application specific code that's
    // passed in through the chartdata argument and then calls
    //
    //     chart.Initialize()
    //
    // to build the data structures that the chart needs. Incidentally, if
    // didn't already guess, we should point out that the chartdata argument
    // will be the ChartData Dictionary that you built in your application's
    // data file.
    //
    // As we already noted, there's lots here and much of it is complicated,
    // so most of this function can be skipped until you decide you're ready
    // to tackle it, but understanding what this function does is easy and
    // really only means looking at a few lines of code. The first argument
    // passed to ConstructChart() must be a dictionary named chartdata and
    // there's a big growable dictionary named chart that's declared right
    // after these comments. To see how they're related skip to the end of
    // chart's declaration (3000+ lines) and you'll find some comments and
    // three lines of code that explain the relationship.
    //
    // If you're interested in building a custom chart you should look for
    // the section labeled "Application Functions" (about 320 lines down in
    // chart dictionary).
    //

    Dictionary chart[0, ...] = {
	String  chartmodel = model;
	Pointer clearcache = clearcache;
	Pointer updatestatus = updatestatus;

	int initialized = FALSE;
	int cellslabeled = FALSE;

	//
	// Three variables are required and must be properly set by every
	// LoadChart() implementation - they're checked by ValidateChart(),
	// which calls Die() when things don't look right.
	//

	Array chartcells = NULL;
	int   simplecellmodel = FALSE;
	int   rows = -1;
	int   columns = -1;

	//
	// By default all charts are cached, but if your applicaton supports
	// several large charts you may want to disable caching, by setting
	// cachechart to FALSE, if you think memory is an issue. Charts that
	// aren't cached don't maintain any state information and have to be
	// completely rebuilt before they can be displayed again. Caching can
	// be enabled for some charts and disabled in others. If you want to
	// remove all cached charts call ClearCachedCharts() in your version
	// of LoadChart().
	//

	int cachechart = TRUE;

	//
	// If defined, this must be the full name of the Java class file that
	// contains chartmode specific methods that can be used for low level
	// Java support. It's not required even it there is such a class file.
	// Take a look at our unicode chart for examples.
	//

	String supportclass = NULL;

	//
	// The special "arrow selector" buttons can be attached to one of the
	// selectors (currently the three possible JChoices that can be shown
	// at the bottom of the screen) by setting arrowselector the index of
	// the selector (0, 1, 2, or 3) in LoadChart(). The direction of the
	// arrow (or the direction of traversal through the selector's items)
	// is revered when the sign of arrowdirection is changed. Requesting
	// a selector that isn't visible means the arrow keys will be visible
	// but they won't function. Assigning -1 to arrowselector or zero to
	// arrowdirection means hide the "arrow selector" buttons.
	//
	// The "arrow selectors" provide additional visual feedback when the
	// user selects the next or previous cell that can be helpful when
	// sequentially selected cells tend to be far apart, but most charts
	// don't need them.
	//

	int arrowselector = -1;
	int arrowdirection = 1;

	//
	// These are occasionally modified in LoadChart() even though most of
	// the default values can be adjusted by options, which always take
	// precedence and override values assigned by LoadChart().
	//

	double cellaspect = CELL_ASPECT_RATIO;
	double cellborder = CELL_BORDER;
	double cellmargin = CELL_MARGIN;
	double cellseparation = CELL_SEPARATION;
	double chartmargin = CHART_MARGIN;

	//
	// These can be used to control the automatic placement of selected
	// cells and the behavior of the zoom slider.
	//

	int screenanchor = CENTER;
	int cellanchor = CENTER;

	Insets screenanchorinsets = NULL;
	Point  screenanchoroffset = NULL;
	int    fuzzyanchor = TRUE;
	int    anchorenabled = TRUE;

	//
	// Setting this to FALSE hides labels in cells that aren't selected.
	// We thought this might occasionaly be useful if the chart is being
	// used as a teaching tool
	//

	int showunselectedlabels = TRUE;

	//
	// These are special purpose variables that can also be set when the
	// chart is loaded. Most are only needed when you're building a chart
	// that's supposed to be a "puzzle" like the one we include with our
	// Periodic Table example.
	//

	Array scatterrects = NULL;
	int   autocheck = FALSE;
	int   showgrid = FALSE;
	int   snaptogrid = FALSE;
	int   scatter = FALSE;
	int   puzzle = FALSE;

	//
	// These are special data structures that are automatically filled in
	// by ValidateChart() after it checks your chart. rowends can be used
	// to find the first and last columns in a row and columnends can be
	// used to find the first and last rows in a column. A NULL entry in
	// either array means there are no cells in that row or column.
	//
	// The rest of the data structures aren't as easy to explain so the
	// details will have to wait for another release.
	//
	// NOTE - setting validatecells to FALSE means LoadChart() set every
	// slot in chartscells to NULL or a valid dictionary. It can be used
	// so reduce the startup overhead when your LoadChart() implementation
	// has completely built the required data structures.
	//

	Dictionary namemap = NULL;
	Dictionary findmap = NULL;
	Array      allcells = NULL;
	Array      allnames = NULL;
	Array      rowends = NULL;
	Array      columnends = NULL;
	int        validatecells = TRUE;

	//
	// These are layout dependent variables that can change when the user
	// does things, like resize the screen. Values are user space points
	// and dimensions and should be initialized in the default coordinate
	// system. After that panning and zooming adjustments are recorded as
	// changes to the CTM used by the JCanvas to display the chart.
	//
	// NOTE - chartbounds covers all of chartcells, but omits decorations
	// like chart labels and other types of padding.
	//

	Rectangle boundingbox = NULL;
	Rectangle chartbounds = NULL;
	Rectangle chartgrid = NULL;
	Rectangle chartgrid_old = NULL;
	Dimension cellsize = NULL;
	double    celldiagonal;
	double    cellinset;
	double    columnwidth;
	double    columnwidth_old;
	double    rowheight;
	double    rowheight_old;
	Array     scatterweights = NULL;
	Array     chartlabels = NULL;
	int       labelspercell = 0;

	//
	// These are numbers that we use to decide if a feature, like a label,
	// is too small to bother painting. They're set in SyncMinimumSizes(),
	// which is called whenver the user zooms in or out.
	//

	double minpointsize;
	double minbordersize;
	double minlabelsize;
	double minselectedsize;
	double minmarksize;

	//
	// This is incremented when a new chart cell is created, so when we're
	// done it's the total number of cells that were created. The value at
	// the time the cell was created is also stored in each cell and can be
	// used to sort cells by "input order".
	//

	int cellcount = 0;
	int visiblecellcount = 0;

	//
	// This is a string that's supposed to represent the current status of
	// the chart's initialzation. It's supposed to be displayed by the GUI
	// whenever the function that was passed to Initialize() as an argument
	// is called. It's set to NULL when the initialization is complete.
	//

	String chartstatus = NULL;

	//
	// Cells that are dragged out of the chart are appended to the doubly
	// linked circular movedcells list and their slot in chartcells is set
	// to NULL. Cells that are moved back to the chart are unlinked from
	// movedcells and put back in their chartcells slot. The cell at the
	// end of the movedcells list is painted last and searched first.
	//

	const Dictionary movedcells = {
	    Pointer next = NULL;
	    Pointer prev = NULL;
	};

	//
	// These are used to highlight a cell's real position in the chart as
	// that cell is dragged around on the screen.
	//

	Dictionary movingcell = NULL;
	Rectangle  movingcellhome = NULL;
	Color      movingcellhomecolor = NULL;

	//
	// We use an array to save the paths that the user draws on the screen.
	//

	Array marks = NULL;
	Array badcell_mark = NULL;

	//
	// We also can draw links, as stright lines with optional decorations
	// at each end, between cells. Right now we really only using one link
	// that temporarily highlights the "panning" path when the selected
	// cell is changed.
	//

	Array links = NULL;

	//
	// The following dictionary is used to manage filters and is filled in
	// when we load the filters menu (if there is one).
	//

	Dictionary filters[0, ...];
	int        filtermask = 0;

	//
	// This is a place where the GUI code can save state information that
	// applies to this chart, usually right before it switches to another
	// chart, so it can be restored when the user switches back.
	//

	Object savedstate = NULL;

	//
	// The generators used for cell and chart labels are created once and
	// the results are saved here (for each chart). It's not only done for
	// performance reasons, but also because they might be modified by the
	// code that uses them. Applications create custom generators using the
	// GetCellLabelGenerators() and GetChartLabelGenerators() functions and
	// the arrays they return are automatically saved here.
	//

	Array cellgenerators = NULL;
	Array chartgenerators = NULL;

	//
	// Cells usually are labeled in a separate thread.
	//

	Thread labelthread = {
	    int daemon = TRUE;
	    int priority = MIN_PRIORITY + 1;
	};

	//
	// These are rather obscure and only needed when a chart has at least
	// one cell that covers more than one grid location (i.e., it's wider
	// or taller than a single grid cell or isn't positioned at the upper
	// left corner of each grid cell). In most charts multicellchart won't
	// be TRUE and the multicelldata array will remain NULL.
	//
	// NOTE - cell layering currently doesn't work the way you might guess
	// when overlapping cells belong to different grid cells. Right now all
	// cells in the grid cell with the higher chartcells index will cover
	// all cells in the grid cell with the lower index (when they overlap).
	// However layering of cells within a single grid cell behaves the way
	// you would expect, so if you need overlapping cells consider mapping
	// all cells to a single grid cell. Changing the behavior would be easy
	// and we may do it in a future release, but it's also going to be more
	// expensive (which is why we've punted for now).
	//

	Array multicelldata = NULL;
	int   multicellchart = FALSE;
	int   lastcelllayer = 0;

	//
	// Applications occasionally need a more flexible cell label placement
	// policy. The official request is made via the "floater" field in cell
	// label generators and the existence of one or more floating labels is
	// automatically recorded in floatinglabels.
	//

	int floatinglabels = FALSE;

	//
	// These are the text strings that appear in the default sorting menu
	// that's built by GetSelectorMenuData() and they're also the strings
	// that are handed to GetSelectorData() function.
	//

	final String SORTBY_COLOR = "Sort by Color";		// unimplemented
	final String SORTBY_COLUMNS = "Sort by Columns";	// unimplemented
	final String SORTBY_INPUT_ORDER = "Sort by Input Order";
	final String SORTBY_NAME = "Sort by Name";
	final String SORTBY_ROWS = "Sort by Rows";

	//
	// These constants are used to set bits in a cell's flags field. Cells
	// are built by the NewChartCell() function, which is defined later in
	// this dictionary, so that's where you can find out what else is in a
	// cell.
	//
	// NOTE - bits that aren't used as flags are reserved for filtering, so
	// make sure you adjust CELL_FITLER_STARTBIT if you add flags. Actually
	// we've intentionally left room of one additional flag.
	//

	final int CELL_SELECTED = 0x01;
	final int CELL_VISIBLE = 0x02;
	final int CELL_MULTICELL = 0x04;

	final int CELL_FITLER_STARTBIT = 4;

	//
	// These constants are used when we build arrowheads that can be added
	// to a link.
	//
	// NOTE - right now we only support one temporary link that's sometimes
	// used to point to the "next" or "previous" selected cell.
	//

	final double ARROWTIP_ANGLE = PI/5;
	final double ARROWEDGE_COS = cos(ARROWTIP_ANGLE/2);
	final double ARROWEDGE_SIN = sin(ARROWTIP_ANGLE/2);
	final double ARROWEDGE_TAN = ARROWEDGE_SIN/ARROWEDGE_COS;

	////////////////////////////
	//
	// Application Functions
	//
	////////////////////////////

	//
	// These are the functions that you redefine, via the chartdata argument
	// that you passed to ConstructChart(), when you want to create a custom
	// chart. The only function you have to define is LoadChart(), which lets
	// you arrange blank cells in a chart. It's a good start, but eventually
	// you'll want more, and that's what the other functions are for. The two
	// functions that let you add text to a chart are GetCellLabelGenerators()
	// and GetChartLabelGenerators().
	//
	// We tried to include comments in most of the application functions that
	// should help you decipher what they're used for and what's required in
	// a custom implementation. Unfortunately the functions that deal with the
	// "selectors" (i.e., the combboxes positioned at the bottom middle of the
	// screen) are the trickiest and right now they're also the functions with
	// the worst documentation. We will try to remedy the situation in another
	// release.
	//

	AfterPressed(Dictionary cell, Event e) {
	    //
	    // This function is called after the user changes a cell's selection
	    // state using the mouse, which usually means pressing and releasing
	    // button 1 while holding the CTRL key. The official way to find out
	    // if the cell is selected of not is to use
	    //
	    //     IsCellSelected(cell);
	    //
	    // which just checks a bit in cell.flags.
	    //
	}

	GetCellBackground(Dictionary cell, Dictionary dict) {
	    Color color = CellColors.TAN;

	    //
	    // Returns the color that should be used to paint the background of
	    // cell. The dict argument, if it's not NULL, is the dictionary that
	    // was created by GetColorMenuData() that corresponds to the current
	    // color menu selection. The only required field in that dictionary
	    // is named text, but it's not unusual for GetColorMenuData() to add
	    // fields to help this function and GetColorTipText(). In other words,
	    // GetColorMenuData(), GetColorTipText() and this function often need
	    // to be coordinated.
	    //
	    // The following simple example
	    //
	    //     if (defined("command", dict)) {	// check for NULL is normally sufficient
	    //         switch (dict.command) {
	    //             case "red":
	    //                 color = CellColors.RED;
	    //                 break;
	    //
	    //             case "blue":
	    //                 color = CellColors.BLUE;
	    //                 break;
	    //         }
	    //     }
	    //
	    // works with the example code in GetColorMenuData() and shows how
	    // dict is used to help in color selection. More realistic examples
	    // would also use fields in the cell dictionary to pick the color.
	    //
	    // NOTE - don't forget that you can always use fprintf() to find out
	    // what's happening  when this function is called. For example,
	    //
	    //     fprintf(stderr, "%O\n", dict);
	    //
	    // will let you see what's in dict, which you should recognize as one
	    // one of the dictionaries that you built in GetColorMenuData().
	    //

	    return(color);
	}

	GetCellDetail(Dictionary cell) {
	    String detail = NULL;

	    //
	    // Returns an HTML description of cell that can be displayed alongside
	    // the chart.
	    //

	    return(detail);
	}

	GetCellDetailDividerModel() {
	    int model = 0;

	    //
	    // This function returns an integer that can be used to control the
	    // behavior of the divider in the JSplitPane that's used to display
	    // cell detail when this chart is selected. Model 1 is useful when
	    // you have a single chart and want to show the cell detail when it
	    // starts. This function can also be useful when your application is
	    // configured to display several charts that are reasonably different
	    // (e.g, one could be a puzzle) and you want different behavior for
	    // each of the charts. The supported "models" are:
	    //
	    //     0 - the location of the divider is never modified when
	    //         this chart is selected. This is the default model
	    //         and it starts with the cell detail panel hidden.
	    //
	    //     1 - the first time this chart is selected the divider
	    //         will be positioned to display cell detail if the
	    //         panel isn't currently showing, but after that the
	    //         divider will only be adjusted to preserve the last
	    //         state (i.e., showing or not) when this chart is
	    //         selected. 
	    //
	    //     2 - the first time this chart is selected the divider
	    //         will be positioned to hide cell detail if the panel
	    //         is currently showing, but after that the divider
	    //         is only adjusted to preserve the last state (i.e.,
	    //         showing or not) when this chart is selected.
	    //
	    // We probably will implement additional models in future releases,
	    // but for now these are the ones we needed in existing applications.
	    //

	    return(model);
	}

	GetCellLabelGenerators() {
	    Array generators = NULL;

	    //
	    // Builds an array of objects called "generators" that can be used to
	    // place text strings in chart cells. Each element in the array that we
	    // return must be a dictionary that describes a line that's displayed in
	    // each cell.
	    //
	    // Every line that appears in every cell in a chart is built using the
	    // array that we return, so it shouldn't be surprising that generating
	    // cell labels can take a while. Each "generator" is a dictionary that
	    // has two parts. The top level provides an overall description of one
	    // line in a cell. For example, the "font" field selects the font used
	    // by every string on this line and it's the height of that font and
	    // the value assigned to "leading" that determines the vertical extent
	    // of the line. The second part is the "layout" array that consists of
	    // one or more dictionaries that describe individual text strings that
	    // appear on a line. All fields are optional and are given reasonable
	    // defaults when they're omitted, but no text will appear in the cell
	    // unless there a dictionary in layout with a GetText() function that
	    // returns some text.
	    //
	    // The fields recognized in the "generator" dictionaries are:
	    //
	    //     baseline
	    //         An integer that controls where the baseline for this
	    //         line goes relative to the other lines that precede it
	    //         the array. The value must be TOP, BOTTOM, or CENTER
	    //         and right now the last line (i.e., the last element
	    //         in the array that we return) is the only one that can
	    //         have its baseline set to CENTER. A line with baseline
	    //         set to TOP is added to the top of the cell but below
	    //         other lines already at the top. A line with baseline
	    //         set to BOTTOM is added to the bottom of the cell but
	    //         above any lines already at the bottom. The default
	    //         value is TOP.
	    //
	    //     font
	    //         The font used for all text on this line. The size
	    //         of the font only determines its size relative to the
	    //         fonts used on other lines. The default value is the
	    //         font returned by GetNormalCellFont().
	    //
	    //     layout
	    //         An array of dictionaries that describe the individual
	    //         text strings that appear on this line. There normally
	    //         will be 1, 2, or 3 elements in this array that describe
	    //         text that should appear at the LEFT, CENTER, and RIGHT
	    //         of this line. There currently aren't any checks that
	    //         prevent more than three elements, however text placed
	    //         at one position (e.g., LEFT) will be drawn on top of
	    //         text already drawn at that location. A NULL layout is
	    //         allowed and stands for an empty line that's colored
	    //         according to the value returned by GetBackground().
	    //         The default value is NULL.
	    //
	    //     leading
	    //         A double that's the spacing between this line and
	    //         the one below it, specified as a fraction of the
	    //         height of the font used on this line. The default
	    //         value is 0.1.
	    //
	    //     selected
	    //         An integer that should be TRUE or FALSE that marks
	    //         labels that should be highlighted when the cell is
	    //         officially selected. All generators except the last
	    //         are assigned FALSE as their default value.
	    //
	    //     visible
	    //         An integer that can be set to FALSE if you want to
	    //         completely hide the line. This field was added for
	    //         for debugging and development purposes and isn't
	    //         normally initialized. The default value is TRUE.
	    //
	    //     GetBackground(Dictionary cell)
	    //         A function that returns the color that's used as the
	    //         background for this line in the cell that's passed as
	    //         the argument. A NULL return means the background color
	    //         of cell shows through. The default value is a function
	    //         that returns NULL.
	    //
	    //         This function is always called in the context of the
	    //         generator dictionary that we're describing here, so
	    //         you can make additional data avaiable to it by adding
	    //         fields to this dictionary.
	    //
	    //     GetForeground(Dictionary cell)
	    //         A function that returns the color that's used to paint
	    //         the text on this line. The default value is a function
	    //         that returns Color.black.
	    //
	    //         This function is always called in the context of the
	    //         generator dictionary that we're describing here, so
	    //         you can make additional data avaiable to it by adding
	    //         fields to this dictionary.
	    //
	    // It's the dictionaries in the layout array that select the text and
	    // and decide where it's placed on each line. The fields recognized in
	    // those dictionaries are:
	    //
	    //     alignment
	    //         An integer that determines where text associated with
	    //         this dictionary is positioned on the current line. The
	    //         value should be LEFT, RIGHT, or CENTER. The default
	    //         value is CENTER.
	    //
	    //     selectable
	    //         An integer that can be set to TRUE when you only want
	    //         the text to appear on cells listed in namemap, which
	    //         right now also means the cells that are picked when
	    //         the JChoice at the bottom middle of the main screen is
	    //         used. In many charts there won't be a distinction and
	    //         every chart cell is also in namemap, so this is a very
	    //         obscure field that you shouldn't worry about much. The
	    //         default value is FALSE.
	    //
	    //     floater
	    //         An integer that can be set to TRUE when the label is
	    //         supposed to "float" around in the cell in a way that
	    //         tries to make it visible when part of the cell moves
	    //         off the screen. Right now this only works well with
	    //         labels that are LEFT or CENTER justified and are the
	    //         only labels on the line.
	    //
	    //     GetMinimumSize()
	    //         A function that's supposed to return a rectangle that
	    //         can cover the text associated with this dictionary that
	    //         appears in any cell. The font used on this line always
	    //         decides the minimum height for the line, so the height
	    //         in the rectangle that this function returns can only
	    //         increase that number. Returning a NULL rectangle means
	    //         this dictionary doesn't contribute to the width that's
	    //         eventually assigned to chart cells. The default value
	    //         is a function that returns NULL.
	    //
	    //         This function is always called in the context of the
	    //         layout dictionary that we're describing here, so you
	    //         can make additional data avaiable to it by adding
	    //         fields to this dictionary.
	    //
	    //         When every GetMinimumSize() returns NULL we can still
	    //         pick a cell size (which is what this function is used
	    //         for) that's often reasonable using the height of each
	    //         font and the cell aspect ratio. In other words, it's
	    //         not unusual to omit this function when you start to
	    //         build a new chart.
	    //
	    //     GetText(Dictionary cell)
	    //         A function that returns the text associated with this
	    //         dictionary for the cell that's passed as the argument.
	    //
	    //         This function is always called in the context of the
	    //         layout dictionary that we're describing here, so you
	    //         can make additional data avaiable to it by adding
	    //         fields to this dictionary.
	    //
	    //     GetTipText(Dictionary cell)
	    //         A function that returns a string that can be displayed
	    //         by a JLabel when the cursor passes over the text that's
	    //         actually displayed in the cell. The default value is a
	    //         function that returns NULL.
	    //
	    //         This function is always called in the context of the
	    //         layout dictionary that we're describing here, so you
	    //         can make additional data avaiable to it by adding
	    //         fields to this dictionary.
	    //
	    // The array that we return is used by ValidateCellLabelGenerators() to
	    // build the data structures that we actually use to generate the labels
	    // in GenerateCellLabels(). Fields not recognized are silently ignored
	    // when the real data structures are built.
	    //
	    // The following simple example
	    //
	    //     generators = new Array {
	    //         new Dictionary {
	    //             Font font = GetSmallCellFont();
	    //             int  baseline = TOP;
	    //
	    //             Array layout = {
	    //                 new Dictionary {
	    //                     int alignment = LEFT;
	    //                     GetText(Dictionary cell) = "Top";
	    //                 },
	    //             };
	    //         },
	    //         new Dictionary {
	    //             Font font = GetSmallCellFont();
	    //             int  baseline = BOTTOM;
	    //
	    //             Array layout = {
	    //                 new Dictionary {
	    //                     int alignment = RIGHT;
	    //                     GetText(Dictionary cell) = "Bottom";
	    //                 },
	    //             };
	    //         },
	    //         new Dictionary {
	    //             Font font = GetLargeCellFont();
	    //             int  baseline = CENTER;
	    //
	    //             Array layout = {
	    //                 new Dictionary {
	    //                     int alignment = CENTER;
	    //                     GetText(Dictionary cell) = "X";
	    //                 },
	    //             };
	    //         },
	    //     };
	    //
	    // arranges to paint "Top", "Bottom" and "X" at the upper left, lower
	    // right, and center of every cell. The size of the fonts we assigned to
	    // each font field controls the relative size of the labels. Notice that
	    // we omitted GetMinimumSize(), but everything seems to work because as
	    // we mentioned earlier, the font is used to measure the height of each
	    // line and the aspect ratio can then be used to pick a cell width when
	    // GetMinimumSize() doesn't provide any information.
	    //

	    return(generators);
	}

	GetChartLabelGenerators() {
	    Array generators = NULL;

	    //
	    // Builds an array of objects called "generators" that can be used to
	    // place text strings in the chart, which are often used to label the
	    // chart's rows and columns. Each element in the array that we return
	    // must be a dictionary that contains fields that are used to generate,
	    // size, and position one or more text strings.
	    //
	    // The two functions named GetText() and NextCellLocation() are called
	    // repeatedly to get labels and their approximate location in the chart
	    // (as an array containing the row and column). The process continues
	    // until NextCellLocation() returns a NULL array. The other fields in
	    // the generator deal with the precise placement and appearance of the
	    // individual labels. All fields are optional and are given reasonable
	    // defaults when they're omitted.
	    //
	    // Fields that aren't named below can be added to the dictionaries when
	    // functions like GetText() or NextCellLocation() need additional data.
	    // Each function is called in the context of its generator dictionary,
	    // so fields defined in the chart (e.g., columnends or rowends) will
	    // only be available to the function if they're added to the generator
	    // dictionary when it's created. This subtle point is a consequence of
	    // the way Yoix functions are implemented.
	    //
	    // The fields recognized in the "generator" dictionaries are:
	    //
	    //     alignment
	    //         An integer that controls the horizontal position of
	    //         each text string relative to the cell selected by the
	    //         NextCellLocation() function. The value must be LEFT,
	    //         RIGHT, or CENTER. The default value is CENTER.
	    //
	    //     baseline
	    //         An integer that controls where the baseline of each
	    //         text string goes relative to the cell selected by
	    //         NextCellLocation(). The value must be TOP, BOTTOM,
	    //         or CENTER. The default value is CENTER.
	    //
	    //     font
	    //         The font used for all text in this group of labels.
	    //         The size of the font is adjusted based on the size
	    //         of each cell in the chart and the value assigned to
	    //         fontscaling. The default is the font returned by
	    //         GetChartFont().
	    //
	    //     fontscaling
	    //         A double that's multiplied by the height of a cell
	    //         to get the final height of font. The default value
	    //         is 0.15.
	    //
	    //     foreground
	    //         The color that's used to paint the text strings in
	    //         this group. A NULL color means the forground color
	    //         of the chart is used, which works well with reverse
	    //         video mode. The default value is NULL.
	    //
	    //     group
	    //         A string that identifies a set of labels so they can
	    //         be manipulated as a group. Right now ROW_LABELS and
	    //         COLUMN_LABELS are the only supported groups and the
	    //         only "group action" are menubar items that can show
	    //         or hide the row or column labels. More may be added
	    //         in the future. The default value is NULL.
	    //
	    //     xoffset
	    //         A double that's multiplied by the width of a cell to
	    //         obtain an adjustment that's added to the x coordinate
	    //         of the point selected by baseline and alignment. The
	    //         default value is 0.0.
	    //
	    //     yoffset
	    //         A double that's multiplied by the height of a cell to
	    //         obtain an adjustment that's added to the y coordinate
	    //         of the point selected by baseline and alignment. The
	    //         default value is 0.0.
	    //
	    //     GetText(Array location)
	    //         A function that returns the text that's supposed to
	    //         be printed at the row and column specified by the
	    //         two numbers stored in location, which is an array
	    //         returned by NextCellLocation(), so location[0] is
	    //         the row and location[1] is the column. The precise
	    //         placement and sizing of the string that we return
	    //         is controlled by field like baseline and alignment
	    //         that are described above. A NULL return value means
	    //         there's no text at that location. The default value
	    //         is a function that returns NULL.
	    //
	    //         This function is always called in the context of the
	    //         generator dictionary that we're describing here, so
	    //         you can make additional data avaiable to it by adding
	    //         fields to this dictionary.
	    //
	    //     NextCellLocation(Array location)
	    //         A function that returns an array containing the row
	    //         and column where the next text string should go. A
	    //         NULL return means there aren't anymore labels in
	    //         this group. The first call is made with a location
	    //         argument that's NULL, but subsequent calls get the
	    //         array that was returned by the previous call, which
	    //         they can use to decide where the next string goes.
	    //         The row goes in location[0] and the column goes in
	    //         location[1]. The default value is a function that
	    //         returns NULL.
	    //
	    //         This function is always called in the context of the
	    //         generator dictionary that we're describing here, so
	    //         you can make additional data avaiable to it by adding
	    //         fields to this dictionary. Two common pieces of data
	    //         that are often added are rowends[] and columnends[],
	    //         which are arrays that are built when the chart is
	    //         initialized.
	    //
	    //         You use rowends[] to find the first and last columns
	    //         associated with a row and columnends[] to find the
	    //         first and last rows associated with a column. Either
	    //         way the row or column used as an index must actually
	    //         lie in the chart even though the row and column that
	    //         we return can take on any value. The value stored at
	    //         a particular index in rowends or columnends is NULL
	    //         when there aren't any cells in that row or column,
	    //         otherwise it's an array of two numbers that are the
	    //         minimum and maximum indices of columns in a row (for
	    //         rowends) or rows in a column (for columnends).
	    //
	    // The array that we return is used by ValidateChartLabelGenerators()
	    // to build the data structures that we actually use to generate the
	    // labels in GenerateChartLabels(). Fields not recognized are silently
	    // ignored when the real data structures are built.
	    //
	    // The following simple example
	    //
	    //     generators = new Array {
	    //         new Dictionary {
	    //             String group = COLUMN_LABELS;
	    //             Color  foreground = Color.red;
	    //
	    //             GetText(Array location) = toString(location[1]+1);
	    //
	    //             NextCellLocation(Array location) {
	    //                 if (location != NULL) {
	    //                     if (location[1] < 4)
	    //                         location[1]++;
	    //                     else location = NULL;
	    //                 } else location = new Array {-1, 0};
	    //                 return(location);
	    //             }
	    //         },
	    //         new Dictionary {
	    //             GetText(Array location) = toString(location[0]+1);
	    //
	    //             NextCellLocation(Array location) {
	    //                 if (location != NULL) {
	    //                     if (location[0] < 4)
	    //                         location[0]++;
	    //                     else location = NULL;
	    //                 } else location = new Array {0, -1};
	    //                 return(location);
	    //             }
	    //         },
	    //     };
	    //
	    // places red column numbers in the first five columns of row -1, which
	    // is the row that lies just above the first official row of the chart,
	    // and white (or black) row numbers in the first five rows of column -1,
	    // which is the column just to the left of the first column. Additional
	    // labels can be handled by adding more dictionaries to the array.
	    //
	    // NOTE - don't forget that you can always use fprintf(), perhaps with
	    // the "%O" conversion specification, to find out what's happening when
	    // these functions are called. For example, add
	    //
	    //     fprintf(stderr, "%.2O\n", rowends);
	    //
	    // to NextCellLocation() and you get a complete dump of rowends.
	    //

	    return(generators);
	}

	GetChartMenuData() {
	    Array data = NULL;

	    //
	    // This function is only needed if your application displays several
	    // different charts, as we do in our Periodic Table example, so most
	    // applications won't implement GetChartMenuData() and instead just
	    // let this function return NULL. However, if you want more than one
	    // chart then use this function to have them listed in the menubar,
	    // and in that case this function returns an array of dictionaries
	    // (and optional NULLs for separators) that describe the items that
	    // are supposed to appear in the chart selection menu.
	    //
	    // The fields recognized in the dictionaries that we return are:
	    //
	    //     command
	    //         This is an optional string field that, if defined, is
	    //         the string that's handed around internally instead of
	    //         text. Users still see text in their menus and labels,
	    //         but this is the what's assigned to chartmodel. If this
	    //         field is omitted text is used.
	    //
	    //     preload
	    //         An optional integer field that when TRUE recommends
	    //         this chart for preloading. This is only a suggestion
	    //         and right now preloading is only enabled when you use
	    //         the +p command line option. The default value is FALSE.
	    //
	    //     state
	    //         An integer field that identifies the menu item that's
	    //         selected when the program starts. The last dictionary
	    //         that has state set to TRUE wins, but if there isn't
	    //         one then the first non NULL dictionary in the array
	    //         is used. This is an optional field that's FALSE by
	    //         default.
	    //
	    //     text
	    //         This is the string users see in menus and labels. If
	    //         there's no "command" field then text is also handed
	    //         to ConstructChart() as the model argument when a new
	    //         chart is built, which means it's saved in chartmodel
	    //         and available to other functions that may need it.
	    //         This is the only required field.
	    //
	    // NULL values are allowed in the array and each one turns into a
	    // "separator" when the menu is built.
	    //
	    // The following simple example
	    //
	    //     data = new Array {
	    //         new Dictionary {
	    //             String text = "Chart One";
	    //             String command = "one";
	    //         },
	    //         NULL,
	    //         new Dictionary {
	    //             String text = "Chart Two";
	    //             String command = "two";
	    //             int    state = TRUE;
	    //         },
	    //     };
	    //
	    // displays "Chart One" and "Chart Two" in the chart selection menu
	    // with a separator between them and starts by displaying "Chart Two".
	    // The command string is the model that's passed to ConstructChart(),
	    // which ends up being saved in chartmodel where it's available to
	    // your implementations of functions like LoadChart().
	    //

	    return(data);
	}

	GetColorMenuData() {
	    Array data = NULL;

	    //
	    // This function lets you add items to the menubar that are used to
	    // control the background color assigned to individual cells. A NULL
	    // return, which you get by default, means no items are added to the
	    // menubar so there's no custom control over cell colors. However, if
	    // you want users to decide then this function should return an array
	    // of dictionaries (and optional NULLs for separators) that describe
	    // the items that are supposed to appear in the color selection menu.
	    //
	    // Background color selection for individual cells is handled by the
	    // GetCellBackground() function which is called with the cell and the
	    // dictionary (that we create here) that corresponds to the currently
	    // selected menu item as its arguments. GetColorTipText() is called
	    // with the same two arguments, so this function often needs to be
	    // coordinated with GetCellBackground() and GetColorTipText().
	    //
	    // The fields recognized in the dictionaries that we return are:
	    //
	    //    command
	    //         This is the name of the field that's often defined
	    //         in menus (and elsewhere too) to identify a selection
	    //         in a way that doesn't use the text that's shown to
	    //         users. We list this field here, even though in this
	    //         case you could use any name - as long as the three
	    //         functions mentioned above all agree. In other words,
	    //         GetCellBackground() and GetColorTipText() are the
	    //         only functions that might use the command field and
	    //         they're called with the dictionary as an argument.
	    //
	    //     state
	    //         An integer field that identifies the menu item that's
	    //         selected when the program starts. The last dictionary
	    //         that has state set to TRUE wins, but if there isn't
	    //         one then the first non NULL dictionary in the array
	    //         is used. This is an optional field that's FALSE by
	    //         default.
	    //
	    //     text
	    //         This is the string users see in the color selection
	    //         menus and it's the only required field.
	    //
	    // NULL values are allowed in the array and each one turns into a
	    // "separator" when the menu is built.
	    //
	    // The following simple example
	    //
	    //     data = new Array {
	    //         new Dictionary {
	    //             String text = "Red Color";
	    //             String command = "red";
	    //         },
	    //         NULL,
	    //         new Dictionary {
	    //             String text = "Blue Color";
	    //             String command = "blue";
	    //             int    state = TRUE;
	    //         },
	    //     };
	    //
	    // displays "Red Color" and "Blue Color" in the color selection menu
	    // with a separator between them and "Blue Color" initially selected
	    // in that menu. Whether anything happens when change the selection
	    // depends on what's done in your GetCellBackground() function - all
	    // this build the color menu and make sure GetCellBackground() is
	    // called when the selection changes.
	    //

	    return(data);
	}

	GetColorTipText(Dictionary cell, Dictionary dict) {
	    String text = NULL;

	    //
	    // Returns a string that's a short description of color used to paint
	    // the background of cell. The string is usually displayed in a JLabel
	    // that's located near the lower right corner of the chart. The dict
	    // argument, if it's not NULL, is the dictionary that was created by
	    // GetColorMenuData() that corresponds to the color currently selected
	    // in the color menu.
	    //
	    // The following simple example
	    //
	    //     if (defined("command", dict)) {	// check for NULL is normally sufficient
	    //         switch (dict.command) {
	    //             case "red":
	    //                 text = "Wavelength = 650nm";
	    //                 break;
	    //
	    //             case "blue":
	    //                 text = "Wavelength = 475nm"
	    //                 break;
	    //         }
	    //     }
	    //
	    // works with the example code in GetColorMenuData() and shows how
	    // dict is used to help select the appropriate text. More realistic
	    // examples would also use fields in the cell dictionary to build the
	    // text.
	    //

	    return(text);
	}

	GetExternalSiteData() {
	    Array data = NULL;

	    //
	    // Returns an array of strings, organized in pairs, that initializes
	    // the JChoice that lets users pick the external site that's used to
	    // provide more information about the cells in the chart. The first
	    // element of each pair is the string displayed in the JChoice while
	    // the second string is the value that's used internally, which means
	    // it's the string handed to GetExternalSiteURL() as the site argument.
	    // In other words, this function and GetExternalSiteURL() often need
	    // to be coordinated.
	    //
	    // Returning NULL, the way we do by default, means hide the "external
	    // site" panel, while returning an array that has zero length means
	    // disable the "external site" panel but don't hide it. So
	    //
	    //     return(NULL);
	    //
	    // hides the "external panel", while
	    //
	    //     return(new Array[0]);
	    //
	    // would disable it. In most cases we prefer to hide it, but you might
	    // be displaying several charts that don't all support external sites.
	    // Hiding and showing the "external site" panel as the user switches
	    // charts means the space available to the chart will grow and shrink
	    // and that can be distracting.
	    //
	    // The following simple example,
	    //
	    //     data = new Array {
	    //         "AT&T Research", "att",
	    //         "Yoix", "yoix",
	    //     };
	    //
	    // displays "AT&T Research" and "Yoix" in the site selection JChoice at
	    // the top of the main screen. The second string in each "pair" is the
	    // string that's handed to GetExternalSiteURL() as the site argument.
	    //

	    return(data);
	}

	GetExternalSiteURL(Dictionary cell, String site) {
	    String url = NULL;

	    //
	    // Returns a string that's the URL where more information about cell
	    // can be found on site, which is the string that identifies the item
	    // that's currently selected in the JChoice that GetExternalSiteData()
	    // was used to initialize.
	    //
	    // The following simple example,
	    //
	    //     if (cell != NULL) {
	    //         switch (site) {
	    //             case "att":
	    //                 url = "http://www.research.att.com/sw/tools/yoix/";
	    //                 break;
	    //
	    //             case "yoix":
	    //                 url = "http://www.yoix.org/";
	    //                 break;
	    //         }
	    //     }
	    //
	    // works with the example in GetExternalSiteData() and returns strings
	    // that take you to the official Yoix web site, regardless of what's in
	    // the cell. More realistic examples would also use fields in the cell
	    // dictionary to build the url.
	    //

	    return(url);
	}

	GetFilterMenuData() {
	    Array data = NULL;

	    //
	    // This function lets you add items to the menubar that are used to
	    // control which cells are visible. A NULL return, which you get by
	    // default, means the "Filters" menu will not appear in the menubar.
	    // The return value should be an array of objects that offer a bit
	    // more control than is currently avaiable in most of the other menu
	    // building functions. An object in the array should be dictionary
	    // that creates a single JCheckBoxMenuItem, a String followed by an
	    // array of dictionaries that creates a submenu with the string as
	    // the label that contains the JCheckBoxMenuItems described by the
	    // dictionaries in the array, or NULL whenever you want a separator 
	    // added to the menu. The submenus can be nested as deep as you want,
	    // but one level will usually be sufficient. Dictionaries created by
	    // this function must be coordinated with GetFilterValue(), which is
	    // defined below.
	    // 
	    // The fields recognized in the dictionaries that we return are:
	    //
	    //    key
	    //         A string that's used by GetFilterValue() to select the
	    //         appropriate value from a cell. Dictionaries that have
	    //         the same key are grouped together and can be thought
	    //         as a single filter because GetFilterValue() uses this
	    //         string to decide how to extract information a cell.
	    //
	    //     text
	    //         This is the string users see in the filter selection
	    //         menus. ALL_ON and ALL_OFF are two special names that
	    //         end up creating menu items that can be used to change
	    //         the flag bit in all cells that are associated with
	    //         the key that's also defined on this dictionary.
	    //
	    //     value
	    //         A string that's supposed to match a value returned by
	    //         GetFilterValue() and is used to pick the collection of
	    //         cells (i.e., the "bucket") that will be affected by the
	    //         operation. If this string is not supplied text will be
	    //         used. This field is not used when text is ALL_ON or
	    //         ALL_OFF because both of them target all cells.
	    //

	    return(data);
	}

	GetFilterValue(Dictionary cell, String key) {
	    Object value;

	    //
	    // This function is called when the internal representation of the
	    // filter is built and is supposed to return a string or sometimes
	    // an array of strings that identify the "bucket" or "buckets" that
	    // are selected by this cell. In most cases the string or strings
	    // should match one of the value fields defined in the dictionaries
	    // that were created by LoadFilterMenuData() for the string passed
	    // in as the key argument.
	    //

	    return(value);
	}

	GetInitialBounds() {
	    Rectangle bounds = NULL;

	    //
	    // This function is called right before the chart is displayed for the
	    // first time. A NULL return means the entire chart will be scaled to
	    // fit into the space available for the chart, otherwise this function
	    // should return a Rectangle that will be scaled to fit into the space.
	    // The location of the rectangle should be given in "cell coordinates",
	    // where the corner a cell at (row, column) is given by:
	    //
	    //     x = GetXForChartColumn(column);
	    //     y = GetYForChartRow(row);
	    //
	    // GetRectangleCovering() is a convenient function that takes the row
	    // and column coordinates for two different cells and translates them
	    // into a rectangle that we can use that completely covers both cells.
	    // For example,
	    //
	    //     bounds = GetRectangleCovering(2, 3, 4, 10);
	    //
	    // returns the rectangle that covers the cells at row 2, column 3 and
	    // at row 4, column 10.
	    //

	    return(bounds);
	}

	GetNextMatchingCell(Dictionary cell, String pattern, int type, int ignorecase, int direction) {
	    Dictionary nextcell;
	    String     key;
	    int        length;
	    int        checked;
	    int        index;
	    int        incr;
	    int        n;

	    //
	    // This function is supposed to return the next cell matching pattern
	    // that follows (if direction is positive) or precedes (if direction
	    // is negative) the cell that's passed in as the first argument. All
	    // most applications have to do is build a findmap dictionary in their
	    // implementation of LoadChart() that maps every name in the allnames
	    // array to the string that's supposed to be matched against pattern.
	    // When findmap is null pattern is matched against strings in allnames.
	    // There's always a chance you'll need your own implementation of this
	    // function, so it's classified as one of the "Application Functions".
	    //
	    // NOTE - we assume, in the interest of efficiency, that when findmap
	    // is not NULL it includes a definition for every name listed in the
	    // allnames array. The assumption means we can skip a defined() test
	    // that might otherwise be needed before strings were retrieved from
	    // findmap. When ValidateChart() decides to do a full check it also
	    // makes sure every name is defined in findmap (when it's not NULL).
	    //
	    // NOTE - we don't currently use type, but eventually it may be used
	    // to tell us match using regular expressions.
	    // 

	    if (!isYchartUsable()) {
		if (pattern@sizeof > 0) {
		    pattern = ignorecase ? toUpperCase(pattern) : pattern;
		    incr = (direction >= 0) ? 1 : -1;
		    length = allnames@sizeof;
		    index = indexOfObject(allnames, cell ? cell.name : NULL);		// OK if it's -1
		    for (n = index + incr, checked = 0; checked < length; n += incr, checked++) {
			if (n >= length)		// incr must be positive
			    n = 0;
			else if (n < 0)			// incr must be negative
			    n = length - 1;
			if (key = findmap ? findmap[allnames[n]] : allnames[n]) {
			    if (ignorecase)
				key = toUpperCase(key);
			    if (indexOf(key, pattern) >= 0) {
				nextcell = GetSelectableCellNamed(allnames[n]);
				break;
			    }
			}
		    }
		}
	    } else nextcell = getNextMatchingCell(cell, pattern, type, ignorecase, direction);

	    return(nextcell);
	}

	GetSelectionAsCell(Array values, int index, ...) {
	    Dictionary cell;
	    String     value;
	    Array      cells;

	    //
	    // This function is supposed to return the cell that matches the string
	    // arguments, which are the strings displayed by each of selectors. A
	    // string that's NULL means the selector isn't showing and shouldn't be
	    // used to locate the cell.
	    //
	    // The default implementation only uses the first selector's string and
	    // assumes the items displayed by that selector are mapped to cells by
	    // the namemap dictionary. It's an approach that's usually works when
	    // the allnames array is used to load the first selector, which means
	    // this function and GetSelectorData() need to be coordinated. In fact
	    // charts that don't have to worry about different cells sharing a name
	    // can just do
	    //
	    //     return(defined(value, namemap) ? namemap[value] : NULL);
	    //
	    // because there won't be any arrays in namemap.
	    //

	    if (values) {
		value = values[index];
		if (defined(value, namemap)) {
		    if (namemap[value] instanceof Array) {
			cells = namemap[value];
			for (ptr in cells) {
			    if (ptr[0].selectable) {
				cell = ptr[0];
				break;
			    }
			}
			if (cell == NULL)
			    cell = cells[0];
		    } else cell = namemap[value];
		}
	    }
	    return(cell);
	}

	GetSelectionAsPoint(Array values, int index, ...) {
	    Dictionary cell;
	    Point      point = NULL;

	    //
	    // This is an obscure function that's supposed to translate the arguments
	    // into a "chart space" point, which by default is the upper left corner
	    // of the cell that's selected by those arguments. Almost all applications
	    // can just use the default. In fact it's currently only called under very
	    // special contitions - more later.
	    //

	    if ((cell = GetSelectionAsCell(unroll(&values))) != NULL) {
		point = new Point {
		    double x = cell.bounds.x;
		    double y = cell.bounds.y;
		};
	    }
	    return(point);
	}

	GetSelectionAsVisibleCell(Array values, int index, ...) {
	    Dictionary cell;
	    int        index = 0;

	    //
	    // This is just a convenience function, so it's unlikely you will have
	    // to implement your own custom version.
	    //

	    return((cell = GetSelectionAsCell(unroll(&values))) != NULL && (cell.flags&CELL_VISIBLE) ? cell : NULL);
	}

	GetSelectionForCell(Dictionary cell, Array values, int index, ...) {
	    Array selection[0, ...];

	    //
	    // This function returns the selection (i.e., array of integers) that's
	    // supposed to be used for cell.
	    //

	    for (ptr in &values by 2) {
		if (ptr@sizeof >= 2) {
		    if (ptr[0] != NULL) {
			if (selection@sizeof == 0)
			    selection[selection@sizeof] = (cell != NULL) ? indexOfObject(ptr[0], cell.name) : 0;
			else selection[selection@sizeof] = ptr[1];
		    } else selection[selection@sizeof] = ptr[1];
		}
	    }
	    return(selection);
	}

	GetSelectionForRotation(Array values, int index, int direction, ...) {
	    //
	    // This function returns the selection obtained when the selector with
	    // the nonzero direction argument is changed in a way that corresponds
	    // to the sign of that direction field.
	    //

	    for (ptr in &values by 3) {
		if (ptr@sizeof >= 3) {
		    if (ptr[0] != NULL && ptr[2] != 0) {
			if (ptr[2] < 0)
			    ptr[1] = (--ptr[1] >= 0) ? ptr[1] : ptr[0]@sizeof - 1;
			else ptr[1] = (++ptr[1] < ptr[0]@sizeof) ? ptr[1] : 0;
		    }
		}
	    }
	    return(GetSelectionForStateChanged(unroll(&values)));
	}

	GetSelectionForStateChanged(Array values, int index, int changed, ...) {
	    Array selection[0, ...];

	    //
	    // This function can be used to validate a selection assuming the one
	    // accompanied by a nonzero changed argument is the one that changed.
	    // Each selector (i.e., JChoice) is described by three arguments, so
	    // since we currently support three selectors you should expect nine
	    // arguments. A negative index or NULL values means the selector can
	    // be ignored (it's probably not visible). Otherwise values[index] is
	    // the string that represents the selector's current selection. Only
	    // one of the triples should have a non-zero changed argument, which
	    // marks it a slightly more important than the others because it's
	    // probably the one the user changed.
	    //
	    // The return value should be an array with valid indices for each of
	    // selectors, which currently means an array with three indices that
	    // correspond to the three selectors described by the nine arguments.
	    // An array that contains the indices that were passed as arguments,
	    // which is what we do by default, means the original selection was
	    // valid.
	    //

	    for (ptr in &values by 3)
		selection[selection@sizeof] = ptr[1];
	    return(selection);
	}

	GetSelectorData(int selector, String sortby) {
	    Array data;
	    int   sorted = FALSE;

	    //
	    // This function returns the array of strings that are supposed to be
	    // displayed by the JChoice identified by selector, which will be an
	    // integer between 0 and 3 (i.e., there are four possible selectors).
	    // The strings in the array that's returned are supposed to be sorted
	    // according to the sortby argument.
	    //
	    // Eventually will implement a color sort. Not difficult, but we need
	    // to make sure sorting happens whenever coloring changes.
	    //

	    switch (selector) {
		case 0:
		    data = new Array[] allnames;
		    sorted = (sortby === SORTBY_INPUT_ORDER);
		    break;

		default:
		    data = NULL;
		    break;
	    }

	    if (data != NULL && !sorted) {
		switch (sortby ? sortby : GetDefaultSortby(selector)) {
		    case SORTBY_INPUT_ORDER:
			SortByInputOrder(selector, data);
			break;

		    case SORTBY_NAME:
			SortByName(selector, data);
			break;

		    case SORTBY_ROWS:
			SortByRows(selector, data);
			break;
		}
	    }
	    return(data);
	}

	GetSelectorMenuData(int selector) {
	    Array data;

	    //
	    // This function returns an array of dictionaries (and optional NULLs
	    // for separators) that describe the items that are supposed to appear
	    // in a popup menu that's used to sort the items in the cell selection
	    // JChoice. The value assigned to "command" in the dictionaries that we
	    // return is the string handed to GetSelectorData() as sortby, so this
	    // function and GetSelectorData() often need to be coordinated.
	    //
	    // The fields recognized in the dictionaries that we return are:
	    //
	    //     command
	    //         This is an optional string field that, if defined, is
	    //         the string that's handed around internally instead of
	    //         text. If this field is omitted text is used.
	    //
	    //     state
	    //         An integer field that identifies the menu item that's
	    //         used for the initial sorting. The last dictionary that
	    //         has state set to TRUE wins, but if there isn't one then
	    //         the first non NULL dictionary in the array wins. This
	    //         is an optional field that's FALSE by default.
	    //
	    //     text
	    //         This is the string users see in the popup menu. If
	    //         there's no "command" field then text is also handed
	    //         around internally.
	    //
	    // NULL values are allowed in the array and are how separators are
	    // added to menus.
	    //
	    // By default we return an array that describes a menu that lets the
	    // user sort by name or input order, which should be sufficient for
	    // many applications, and initially sorts by input order.
	    //

	    switch (selector) {
		case 0:
		    data = new Array {
			new Dictionary {
			    String text = SORTBY_NAME;
			    int    state = FALSE;
			},
			new Dictionary {
			    String text = SORTBY_INPUT_ORDER;
			    int    state = TRUE;
			},
		    };
		    break;

		default:
		    data = NULL;
		    break;
	    }
	    return(data);
	}

	GetVersion() {
	    String version = NULL;

	    //
	    // Returns a short string containing one or more lines that appear in
	    // the dialog that describes this program.
	    //

	    return(version);
	}

	LoadChart() {
	    //
	    // This function is responsible for building the chart, which means
	    // initializing rows and columns, creating an array named chartcells
	    // with exactly rows*columns elements, and adding one or more cells
	    // to the chart using the NewChartCell() function, which is defined
	    // below. It's the only required application specific function, so
	    // if no LoadChart() function is defined in the chartdata dictionary
	    // that you passed to ConstrucChart() then this is the function that
	    // Initialize() calls and that means your script will die.
	    //
	    // Creating a chart is easy, although getting it to look and behave
	    // the way you want can be challenging. As a simple example, suppose
	    // your LoadChart() function did
	    //
	    //     int n;
	    //
	    //     rows = 10;
	    //     columns = 10;
	    //     chartcells = new Array[rows*columns];
	    //
	    //     for (n = 0; n < rows; n++)
	    //         NewChartCell(NULL, n, n, 1, 1, NULL, NULL);
	    //
	    // then you're chart would have 100 cells but only 10 cells along the
	    // diagonal would be occupied.
	    //
	    // The tabelcells array is one dimensional so
	    //
	    //     row*columns + column
	    //
	    // is how you calculate the chartcells index for the cell at row and
	    // column in your chart - if you ever need to.
	    //

	    Die("No %s function was defined in chartdata", argv[0]);
	}

	////////////////////////////
	//
	// Initialization Functions
	//
	////////////////////////////

	CountCellLabels() {
	    Dictionary generator;
	    Array      generators;
	    int        count = 0;

	    //
	    // This must be called before LoadChart() because labelspercell is
	    // used by NewChartCell(). Older versions of that function stored
	    // information about each label in a growable array, which meant we
	    // didn't need an accurate count, but the current version now uses
	    // a fixed size array so we need a reasonable upper bound.
	    //

	    if ((generators = GetCachedCellLabelGenerators()) != NULL) {
		for (ptr in generators) {
		    if (defined(ptr)) {
			if ((generator = *ptr) != NULL) {
			    for (ptr in generator.layout) {
				if (defined(ptr)) {
				    if (*ptr != NULL)
					count++;
				}
			    }
			}
		    }
		}
	    }
	    labelspercell = count;
	}

	GetChartStatus() {
	    return(chartstatus);
	}

	Initialize() {
	    String model;

	    //
	    // We current allow ConstructChart() calls with a NULL model, but we
	    // skip all initialization, which means the chart really should only
	    // be used to call GetChartMenuData() when the script first starts.
	    //

	    if (chartmodel != NULL) {
		if (!initialized) {
		    model = chartmodel@sizeof > 0 ? chartmodel : "chart";
		    movedcells.next = this.movedcells;
		    movedcells.prev = this.movedcells;
		    ValidateYchartModule();
		    CountCellLabels();			// must precede LoadChart()
		    UpdateChartStatus(FALSE, "Loading %s", model);
		    LoadChart();
		    UpdateChartStatus(FALSE, "Validating %s", model);
		    ValidateChart();
		    ValidateCellLabelGenerators();
		    ValidateChartLabelGenerators();
		    SaveChartProperties();
		    SyncSimpleCellModel();
		    UpdateChartStatus(FALSE, "Preparing %s for display", model);
		    PrepareChartCells();
		    SyncMulticellChart();
		    PrepareMulticellData();
		    LayoutChartLabels(NULL);
		    LayoutCellLabels();
		    initialized = TRUE;
		} else Die("%s: the chart has already been initialized", argv[0]);
	    }
	}

	LayoutCellLabels() {
	    if (scatterrects && scatter) {
		GenerateCellLabels();
		ScatterAllCells(NULL);
	    } else if (updatestatus != NULL)
		labelthread.queue(&GenerateCellLabels);
	    else GenerateCellLabels(NULL);
	}

	LayoutChartLabels(Dictionary selected) {
	    GenerateChartLabels(selected);
	    UpdateBoundingBox();
	}

	NewChartCell(String name, double row, double column, double width, double height, Object data, Object etc) {
	    Object element;
	    int    index = ((int)row)*columns + column;

	    Dictionary cell = {
		//
		// We save the corner and size of this cell in bounds. Most of
		// the time cells are aligned to the grid, which means all four
		// numbers will usually be integers. The numbers are converted
		// to actual coordinates by PrepareChartCells() and those values
		// (actually just x and y) are updated whenever a cell is moved.
		//
		// NOTE - the original location of the cell is saved in the home
		// field, which is defined later (because it's not used much).
		//
		// NOTE - when name is NULL we make one up as a convenience, but
		// our choice undoubtedly won't make anyone happy, so it's really
		// the caller's responsibility to supply an appropriate name. We
		// only do it to help during early development. Old versions used
		// row and column to make one up but several cells can occupy the
		// chartcells slot so that's no longer a particularly good choice
		// and we don't want to work harder just for a temporary name.
		//

		Rectangle bounds = {
		    double x = column;
		    double y = row;
		    double width = width;
		    double height = height;
		};

		String name = name ? name : toString(cellcount);

		Object data = data;
		Object etc = etc;
		Object background;			// initialized to NULL
		Object foreground;			// initialized to NULL
		Object selectedforeground;		// initialized to NULL
		Array  labels[labelspercell];		// array with labelspercell uninitialized slots
		Array  marks;				// initialized to NULL
		int    flags = CELL_VISIBLE;
		int    index = index;
		int    layer = -1;
		int    selectable;			// initialized to 0 (i.e., FALSE)
		int    state;				// initialized to 0
		int    nextlabel;			// initialized to 0

		//
		// These are used when cells are dragged out of the chart and
		// saved in the movedcells linked list, so we could delay their
		// creation if we really wanted.
		//

		Dictionary next;			// initialized to NULL
		Dictionary prev;			// initialized to NULL

		//
		// This is when the upper left corner of the cell belongs when
		// it's in the chart (i.e., not moved).
		//

		Point home = {
		    double x = column;
		    double y = row;
		};

		//
		// These fields aren't used much so we add them last because we're
		// less concerned about hashing collisions.
		// 

		String tip;				// initialized to NULL
		int    id = cellcount++;
		int    row = row;			// automatically casts row to int
		int    column = column;			// automatically casts column to int
	    };

	    if (simplecellmodel) {
		chartcells[index] = cell;
	    } else {
		if (defined(index, chartcells) && (element = chartcells[index]) != NULL) {
		    if (element instanceof Array) {
			cell.layer = element@sizeof;
			element[cell.layer] = cell;
		    } else {
			element.layer = 0;
			cell.layer = 1;
			chartcells[index] = new Array[2, ...] {element, cell};
		    }
		    if (cell.layer > lastcelllayer)
			lastcelllayer = cell.layer;
		} else chartcells[index] = new Object cell;
	    }

	    return(cell);
	}

	PickCellSize() {
	    Dictionary generator;
	    Dictionary label;
	    Dimension  minsize;
	    Rectangle  bounds;
	    Array      generators;
	    double     linewidth;
	    double     lineheight;

	    //
	    // The width required by each generator is obtained by calling the
	    // GetMinimumSize() function for each element in that generator's
	    // layout array. The width of the entire line is obtained by adding
	    // the width of each element in the layout array, which means we're
	    // assuming they don't overlap. The height of the font used on the
	    // line or the maximum height returned by GetMinimumSize() is used,
	    // along with the leading defined in each generator, to select the
	    // height of each line, which are added to get the minimum height
	    // of a cell.
	    //
	    // When no width information is provided by GetMinimumSize() we can
	    // still return an answer, based on the font bounds and cell aspect
	    // ratio, that's often reasonable, particularly when LoadChart() is
	    // where the aspect ratio is set.
	    //

	    if ((generators = GetCachedCellLabelGenerators()) != NULL) {
		for (ptr in generators) {
		    if (generator = *ptr) {
			if (generator.visible) {
			    linewidth = 0;
			    lineheight = generator.fontbbox.height;
			    for (ptr in generator.layout) {
				if (label = *ptr) {
				    if ((bounds = label.GetMinimumSize()) != NULL) {
					bounds = GetScaledBounds(bounds, generator.font);
					linewidth += bounds.width;
					if (lineheight < bounds.height)
					    lineheight = bounds.height;
				    }
				}
			    }
			    if (minsize.width < linewidth)
				minsize.width = linewidth;
			    minsize.height += (1 + generator.leading)*lineheight;
			}
		    }
		}
	    }
	    if (minsize.width > 0 && minsize.height > 0) {
		minsize.width += 2*cellinset;
		minsize.height += 2*cellinset;
		if (cellaspect > 0) {
		    if (minsize.width < cellaspect*minsize.height)
			minsize.width = cellaspect*minsize.height;
		    else minsize.height = minsize.width/cellaspect;
		}
	    } else {
		if (minsize.height > 0)
		    minsize.height += 2*cellinset;
		else minsize.height = 72;
		minsize.width = (cellaspect > 0) ? cellaspect*minsize.height : minsize.height;
	    }
	    return(minsize);
	}

	PrepareChartCells() {
	    Dictionary cell;
	    Dictionary dict;
	    Rectangle  bounds = NULL;
	    double     x0;
	    double     x1;
	    double     y0;
	    double     y1;
	    Color      foreground = CellColors.BLACK;
	    Color      selectedforeground = CellColors.WHITE;
	    Array      data;
	    int        layer;

	    //
	    // The generality introduced by using the GetNextChartCell() function
	    // has introduce some overhead, but this function is only called once
	    // per chart and most of the time it's handled by a ychart builtin, so
	    // we haven't tried to improve the preformance.
	    //
	    // NOTE - the method we use to initialize fields in bounds is designed
	    // to cope with arbitrary placement and dimensions of cells. You might
	    // be tempted to initialize them using
	    //
	    //     bounds.x = chartbounds.x + bounds.x*columnwidth;
	    //     bounds.y = chartbounds.y + bounds.y*rowheight;
	    //     bounds.width *= columnwidth;
	    //     bounds.height *= rowheight;
	    //
	    // but small floating point errors can creep in and occasionally cause
	    // subtle problems, most notably in PrepareMultiCellChart().
	    //

	    if (!prepareChartCells()) {
		multicellchart = FALSE;
		data = PickColorData(GetColorMenuData(), NULL);
		dict = defined(0, data) ? data[0] : NULL;
		for (ptr in chartcells) {
		    for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(ptr@offset, &layer, 1)); ) {
			bounds = cell.bounds;
			if (((int)bounds.x + 1 < bounds.x + bounds.width) || ((int)bounds.y + 1 < bounds.y + bounds.height)) {
			    cell.flags |= CELL_MULTICELL;
			    multicellchart = TRUE;
			}
			x0 = chartbounds.x + bounds.x*columnwidth;
			y0 = chartbounds.y + bounds.y*rowheight;
			x1 = chartbounds.x + (bounds.x + bounds.width)*columnwidth;
			y1 = chartbounds.y + (bounds.y + bounds.height)*rowheight;
			bounds.x = x0;
			bounds.y = y0;
			bounds.width = x1 - x0;
			bounds.height = y1 - y0;
			cell.home.x = bounds.x;
			cell.home.y = bounds.y;
			cell.foreground = foreground;
			cell.selectedforeground = selectedforeground;
			cell.background = GetCellBackground(cell, dict);
		    }
		}
	    }
	}

	PrepareMulticellData() {
	    Dictionary cell;
	    double     x0;
	    double     y0;
	    double     x1;
	    double     y1;
	    Array      data;
	    int        row;
	    int        column;
	    int        index;
	    int        layer;

	    if (multicellchart) {
		if (!prepareMulticellData()) {
		    data = new Array[chartcells@sizeof];
		    x0 = chartbounds.x;
		    x1 = chartbounds.y;
		    for (ptr in chartcells) {
			if (!defined(ptr@offset, data))
			    data[ptr@offset] = NULL;
			for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(ptr@offset, &layer, 1)); ) {
			    if (cell.flags & CELL_MULTICELL) {
				x1 = cell.bounds.x + cell.bounds.width;
				y1 = cell.bounds.y + cell.bounds.height;
				for (row = cell.row; row < rows && y0 + row*rowheight < y1; row++) {
				    for (column = cell.column; column < columns && x0 + column*columnwidth < x1; column++) {
					index = row*columns + column;
					if (cell.index != index) {
					    if (defined(index, data)) {
						if (data[index] != NULL) {
						    if (column < data[index][1])
							data[index][1] = column;
						} else data[index] = new Array {cell.row, cell.column};
					    } else data[index] = new Array {cell.row, cell.column};
					}
				    }
				}
			    }
			}
		    }
		    multicelldata = data;
		}
	    } else multicelldata = NULL;		// should be unnecessary
	}

	//
	// The next four functions can be used as default values when we need to
	// add missing functions to data structures that we're validating. Right
	// now they're only by the code that validates cell label generators.
	//

	ReturnBlack(...) = Color.black;
	ReturnEmptyString(...) = "";
	ReturnNull(...) = NULL;
	ReturnWhite(...) = Color.white;

	SaveChartProperties() {
	    Rectangle rect;
	    double    separation;
	    double    weight;
	    double    total;

	    //
	    // Initializes the chart variables that store layout based size and
	    // location information.
	    //

	    visiblecellcount = cellcount;

	    columnwidth_old = columnwidth;
	    rowheight_old = rowheight;
	    chartgrid_old = chartgrid;

	    cellaspect = (CELL_ASPECT_RATIO >= 0) ? CELL_ASPECT_RATIO : max(cellaspect, 0);
	    cellseparation = (CELL_SEPARATION >= 0) ? CELL_SEPARATION : max(cellseparation, 0);
	    cellborder = (CELL_BORDER >= 0) ? CELL_BORDER : (cellborder >= 0 ? cellborder : 2*VM.screen.pixelwidth);
	    cellmargin = (CELL_MARGIN >= 0) ? CELL_MARGIN : (cellmargin >= 0 ? cellmargin : 1.0);
	    cellinset = cellborder + cellmargin;

	    cellsize = PickCellSize();
	    separation = cellseparation*min(cellsize.width, cellsize.height);
	    columnwidth = cellsize.width + separation;
	    rowheight = cellsize.height + separation;
	    celldiagonal = sqrt(columnwidth*columnwidth + rowheight*rowheight);

	    chartbounds = new Rectangle {
		double x = 0;
		double y = 0;
		double width = columns*columnwidth - separation;
		double height = rows*rowheight - separation;
	    };

	    chartgrid = new Rectangle {
		double x = chartbounds.x - 0.5*separation;
		double y = chartbounds.y - 0.5*separation;
		double width = chartbounds.width + separation;
		double height = chartbounds.height + separation;
	    };

	    //
	    // If scatterrects isn't NULL and we're not initialized then we need
	    // to convert rectangles from "chart space" (i.e., rows and columns)
	    // to user space. Right now this function is only called once, so the
	    // initialized check isn't needed.
	    //

	    if (scatterrects && !initialized) {
		total = 0;
		scatterweights = new Array[0, ...];
		for (ptr in scatterrects) {
		    if (rect = ptr[0]) {
			rect.x *= columnwidth;
			rect.y *= rowheight;
			rect.width = max(0, rect.width*columnwidth);
			rect.height = max(0, rect.height*rowheight);
			weight = rect.width*rect.height;
		    } else weight = 0;
		    scatterweights[scatterweights@sizeof] = weight;
		    total += weight;
		}
		if (total > 0) {
		    weight = 0;
		    for (ptr in scatterweights) {
			weight += ptr[0]/total;
			ptr[0] = weight;
		    }
		}

		//
		// This describes the mark that's used when we want to indicate
		// that there's something wrong with the cell, which right now
		// only happens when a cell is placed in the wrong cell location
		// and the chart is supposed to be a "puzzle". Data in the array
		// is interpreted by PaintCellMarks() and in this case it covers
		// the cell with a big red X.
		//

		badcell_mark = new Array {
		    NULL, Color.red,
		    NULL, 3*LINEWIDTH,
		    0, 0,
		    cellsize.width - 2*cellinset, cellsize.height - 2*cellinset,
		    NULL, NULL,
		    cellsize.width - 2*cellinset, 0,
		    0, cellsize.height - 2*cellinset
		};
	    }

	    UpdateBoundingBox();
	}

	SyncSimpleCellModel() {
	    //
	    // This currently can't choose PaintChartCells() because the algorithm
	    // used by the fast version doesn't work properly when cells overlap.
	    //
	    if (lastcelllayer == 0) {
		simplecellmodel = TRUE;
		GetNextChartCell = GetNextChartCell_Simple;
	    }
	}

	SyncMulticellChart() {
	    //
	    // The algorithm currently used by PaintChartCells_Simple() doesn't work
	    // properly when cells overlap so can only choose the PaintChartCells()
	    // after lastcelllayer and multicellchart are initialized.
	    //

	    if (lastcelllayer == 0 && !multicellchart && !floatinglabels)
		PaintChartCells = PaintChartCells_Simple;
	}

	UpdateBoundingBox() {
	    Dictionary dict;
	    Rectangle  rect;
	    Rectangle  bbox = chartbounds;

	    //
	    // Builds a rectangle that covers all the space the chart currently
	    // needs. It's a rectangle that can change because chartlabels can
	    // (i.e., the user can hide them), so this function isn't only called
	    // when we first build the chart.
	    //
	    // NOTE - in case you're wondering, the for loops that look through
	    // chartlabels and scatterrects behave properly when they're NULL.
	    //

	    for (ptr in chartlabels) {
		if ((dict = *ptr) != NULL) {
		    if (defined("bounds", dict))
			bbox = rectUnionRect(bbox, dict.bounds);
		}
	    }

	    for (ptr in scatterrects) {
		if ((rect = *ptr) != NULL)
		    bbox = rectUnionRect(bbox, rect);
	    }

	    if (chartmargin) {
		boundingbox = new Rectangle {
		    double x = bbox.x - chartmargin;
		    double y = bbox.y - chartmargin;
		    double width = bbox.width + 2*chartmargin;
		    double height = bbox.height + 2*chartmargin;
		};
	    } else boundingbox = bbox;
	}

	UpdateChartStatus(int repaint, String format, ...) {
	    if (updatestatus != NULL) {
		if (*updatestatus instanceof Callable) {
		    if (format@sizeof > 0)
			chartstatus = strfmt(unroll(&format));
		    else chartstatus = NULL;
		    (*updatestatus)(this, repaint);
		}
	    }
	}

	ValidateCellLabelGenerators() {
	    Dictionary generator;
	    Dictionary dict;
	    Array      generators;
	    Array      layout;

	    //
	    // Rebuilds the data structures used to generate cell labels, which
	    // means making sure all required fields have reasonable defaults if
	    // they weren't originally defined.
	    //
	    // NOTE - the dictionaries that we build here are made considerably
	    // larger than required. It's an unusual attempt at squeezing a bit
	    // of performance out of the data structures by trying to reduce the
	    // chance of hashing collisions in the low level representation of
	    // the dictionaries. As we mentioned, it's not something we normally
	    // do and the savings per lookup, if there is any, will be tiny, but
	    // really big charts with many labels per cell do lots of lookups in
	    // these dictionaries and the cumulative effect could be measurable.
	    //
	    // NOTE - comparing ptr@sizeof to 1, as we do in at least one place,
	    // is an easy way to ask if we're working on the last element in the
	    // generators array.
	    //

	    floatinglabels = FALSE;

	    if ((generators = GetCachedCellLabelGenerators()) != NULL) {
		for (ptr in generators) {
		    if (defined(ptr)) {
			if (ptr[0] != NULL) {
			    if (!defined("layout", ptr[0]) || ptr[0].layout == NULL) {
				layout = new Array {
				    new Dictionary {
					Function GetText = ReturnEmptyString;
				    }
				};
			    } else layout = ptr[0].layout;

			    generator = new Dictionary[19, ...] {unroll(ptr[0])};
			    generator.GetBackground = defined("GetBackground", generator) ? generator.GetBackground : ReturnNull;
			    generator.GetForeground = defined("GetForeground", generator) ? generator.GetForeground : ReturnBlack;
			    generator.baseline = defined("baseline", generator) ? generator.baseline : TOP;
			    generator.leading = defined("leading", generator) ? generator.leading : 0.1;
			    generator.layout = layout;
			    generator.font = defined("font", generator) ? generator.font : GetNormalCellFont();
			    generator.selected = defined("selected", generator) ? generator.selected : (ptr@sizeof == 1);
			    generator.visible = defined("visible", generator) ? generator.visible : TRUE;
			    generator.preloaded = FALSE;
			    generator.fontbbox = GetFontBounds(defined("font", generator) ? generator.font : GetNormalCellFont(), FALSE);

			    for (ptr in layout) {
				if (defined(ptr)) {
				    if (ptr[0] != NULL) {
					dict = new Dictionary[19, ...] {unroll(ptr[0])};
					dict.GetText = defined("GetText", dict) ? dict.GetText : ReturnNull;
					dict.GetTipText = defined("GetTipText", dict) ? dict.GetTipText : ReturnNull;
					dict.GetMinimumSize = defined("GetMinimumSize", dict) ? dict.GetMinimumSize : ReturnNull;
					dict.alignment = defined("alignment", dict) ? dict.alignment : CENTER;
					dict.selectable = defined("selectable", dict) ? dict.selectable : FALSE;
					dict.floater = defined("floater", dict) ? dict.floater : FALSE;
					if (dict.floater)
					    floatinglabels = TRUE;
					ptr[0] = dict;
				    }
				}
			    }

			    ptr[0] = generator;
			}
		    }
		}
	    }
	}

	ValidateChart() {
	    Dictionary cell;
	    Dictionary map;
	    String     name;
	    Array      names;
	    Array      cells;
	    int        row;
	    int        column;
	    int        nextname;
	    int        nextcell;
	    int        layer;

	    //
	    // Runs some simple checks to make sure LoadChart() behaved properly
	    // and if so it fills in any missing pieces, which currently include
	    // rowends, columnends, and namemap. Sophisticated applications that
	    // need to reduce load time can build rowends, columnends, namemap,
	    // and allnames on their own, but it normally only makes sense when
	    // for really big charts and only if you really undestand the data
	    // structures.
	    //

	    if (chartcells != NULL) {
		if (chartcells@sizeof > 0) {
		    if (rows > 0) {
			if (columns > 0) {
			    if (chartcells@sizeof >= rows*columns) {
				//
				// If your LoadChart() builds one of these then it
				// should build them all, because we rebuild the
				// entire collection if any one is NULL. Building
				// your own only makes sense if you're trying to
				// speed loading up some, usually for really big
				// charts.
				//
				if (rowends == NULL || columnends == NULL || namemap == NULL || allnames == NULL || allcells == NULL) {
				    rowends = new Array[rows];
				    for (ptr in rowends)
					*ptr = NULL;
				    columnends = new Array[columns];
				    for (ptr in columnends)
					*ptr = NULL;
				    //
				    // Building namemap is a little tricky because we
				    // don't know its precise size (several cells can
				    // share a name), so we build it in a temporary
				    // dictionary and when we're done we unroll() our
				    // dictionary into the initializer that builds the
				    // official namemap dictionary.
				    //
				    // NOTE - old version used rows*columns as the size
				    // of map and name, but that's no longer appropriate 
				    // because "grid cells" can now be occupied by more
				    // than one cell.
				    //
				    // NOTE - making map bigger than necessary reduces
				    // hashing collsions which makes this function run
				    // a bit faster. See the NOTE below about why we
				    // currently don't just use the larger dictionary
				    // as namemap.
				    //

				    map = new Dictionary[2*cellcount];
				    names = new Array[cellcount];
				    cells = new Array[cellcount];
				    nextname = 0;
				    nextcell = 0;
				    for (ptr in chartcells) {
					if (defined(ptr)) {			// is it initialized?
					    for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(ptr@offset, &layer, 1)); ) {
						name = cell.name;
						row = cell.index/columns;
						column = cell.index%columns;
						if (rowends[row]) {
						    if (column > rowends[row][1])
							rowends[row][1] = column;
						    else if (column < rowends[row][0])
							rowends[row][0] = column;
						} else rowends[row] = new Array {column, column};
						if (columnends[column]) {
						    if (row > columnends[column][1])
							columnends[column][1] = row;
						    else if (row < columnends[column][0])
							columnends[column][0] = row;
						} else columnends[column] = new Array {row, row};
						if (map) {
						    if (!defined(name, map)) {
							map[name] = new Object cell;		// Object, so type can change
							names[nextname++] = cell.name;
						    } else if (map[name] instanceof Array)
							map[name][map[name]@sizeof] = cell;
						    else map[name] = new Array[2, ...] {map[name], cell};
						}
						cells[nextcell++] = cell;
						//
						// If findmap is defined it must include
						// a definition for every name. Assumption
						// is made in GetNextMatchingCell() and is
						// only for speed - it eliminates several
						// tests.
						//
						if (findmap) {
						    if (!defined(name, findmap))
							findmap[name] = NULL;
						}
					    }
					} else ptr[0] = NULL;
				    }
				    //
				    // Using unroll() in the initializer eliminates all
				    // of map's uninitialized elements. In other words
				    // namemap will be exactly the right size.
				    //
				    // NOTE - the main reason why we want to eliminate
				    // the uninitialized elements is that our current
				    // implementation of qsort() doesn't do the best job
				    // when it tries to sort an object (e.g., array) and
				    // there are lots of uninitialized elements. Probably
				    // not a difficult Java code fix, but we're not going
				    // to tackle it right now.
				    //
				    if (nextname != names@sizeof)		// shouldn't happen
					allnames = new Array {unroll(names)};
				    else allnames = names;
				    if (nextcell != cells@sizeof)		// shouldn't happen
					allcells = new Array {unroll(cells)};
				    else allcells = cells;
				    namemap = new Dictionary {unroll(map)};
				} else {
				    if (rowends@sizeof == rows) {
					if (columnends@sizeof == columns) {
					    if (namemap@sizeof > 0) {
						if (validatecells) {
						    for (ptr in chartcells) {
							if (!defined(ptr))
							    ptr[0] = NULL;
						    }
						}
					    } else Die("%s: namemap must contain at least one entry", argv[0]);
					} else Die("%s: the size of columnends doesn't match columns", argv[0]);
				    } else Die("%s: the size of rowends doesn't match rows", argv[0]);
				}
			    } else Die("%s: rows and columns aren't compatible with chartcells", argv[0]);
			} else Die("%s: columns isn't initialized", argv[0]);
		    } else Die("%s: rows isn't initialized", argv[0]);
		} else Die("%s: chartcells array is empty", argv[0]);
	    } else Die("%s: chartcells array isn't initialized", argv[0]);
	}

	ValidateChartLabelGenerators() {
	    Dictionary generator;
	    Array      generators;

	    //
	    // Rebuilds the data structures used to generate chart labels, which
	    // means making sure all required fields have reasonable defaults if
	    // they weren't originally defined.
	    //

	    if ((generators = GetCachedChartLabelGenerators()) != NULL) {
		for (ptr in generators) {
		    if (defined(ptr)) {
			if (ptr[0] != NULL) {
			    generator = new Dictionary[0, ...] {unroll(ptr[0])};
			    generator.group = defined("group", generator) ? generator.group : NULL;
			    generator.xoffset = defined("xoffset", generator) ? generator.xoffset : 0.0;
			    generator.yoffset = defined("yoffset", generator) ? generator.yoffset : 0.0;
			    generator.fontscaling = defined("fontscaling", generator) ? generator.fontscaling : 0.15;
			    generator.foreground = defined("foreground", generator) ? generator.foreground : NULL;
			    generator.font = defined("font", generator) ? generator.font : GetChartFont();
			    generator.baseline = defined("baseline", generator) ? generator.baseline : CENTER;
			    generator.alignment = defined("alignment", generator) ? generator.alignment : CENTER;
			    generator.minscaling = defined("minscaling", generator) ? generator.minscaling : 1.0;
			    generator.GetText = defined("GetText", generator) ? generator.GetText : ReturnNull;
			    generator.NextCellLocation = defined("NextCellLocation", generator) ? generator.NextCellLocation : ReturnNull;
			    ptr[0] = generator;
			}
		    }
		}
	    }
	}

	ValidateYchartModule() {
	    String message;
	    Array  badnames;

	    if (VALIDATEYCHART) {
		if (USEYCHART) {
		    if (defined("checkYchartNames", yoix.ychart)) {
			if ((badnames = checkYchartNames()) != NULL) {
			    message = "Your yoix.ychart module can't be used run this script. The following\n";
			    message += "names appear to be either missing or invalid:\n\n";
			    for (ptr in badnames)
				message += "            " + ptr[0] + "\n";
			    message += "\nThe script probably will still run, but performance will be degraded.\n";
			    message += "Vist http://www.yoix.org/ for software updates.";
			}
		    } else {
			message = "The yoix.ychart module isn't available. This script probably will still run,\n";
			message += "but performance will be degraded. Vist http://www.yoix.org/ for software\n";
			message += "updates.";
		    }
		} else {
		    message = "You've asked to run without the yoix.ychart module, which will result\n";
		    message += "in degraded performance.";
		}
		if (YCHARTWARNING)
		    Warn(message);
		VALIDATEYCHART = FALSE;
	    }
	}

	////////////////////////////
	//
	// Color Functions
	//
	////////////////////////////

	ColorChartCells(Array data) {
	    Dictionary cell;
	    Dictionary dict;
	    Color      foreground = CellColors.BLACK;
	    Color      selectedforeground = CellColors.WHITE;

	    if (!colorChartCells(data)) {
		dict = defined(0, data) ? data[0] : NULL;
		for (ptr in allcells) {
		    cell = ptr[0];
		    cell.foreground = foreground;
		    cell.selectedforeground = selectedforeground;
		    cell.background = GetCellBackground(cell, dict);
		}
	    }
	}

	PickColorData(Array data, String text) {
	    int n;

	    data = (data == NULL) ? GetColorMenuData() : data;
	    for (n = -data@offset; n < data@sizeof; n++) {
		if (data[n]) {
		    if (text === data[n].text || (text == NULL && defined("state", data[n]) && data[n].state)) {
			data += n;
			break;
		    }
		}
	    }
	    return(data);
	}

	////////////////////////////
	//
	// Sorting Functions
	//
	////////////////////////////

	GetDefaultSortby(int selector) {
	    String sortby = NULL;
	    Array  data;

	    if ((data = GetSelectorMenuData(selector)) != NULL) {
		for (ptr in data) {
		    if (ptr[0]) {
			if (defined("state", ptr[0]) && ptr[0].state) {
			    sortby = defined("command", ptr[0]) ? ptr[0].command : ptr[0].text;
			    break;
			}
		    }
		}
		if (sortby == NULL)
		    sortby = defined("command", data[0]) ? data[0].command : data[0].text;
	    }
	    return(sortby);
	}

	SortByInputOrder(int selector, Array names) {
	    Array indices[names@sizeof];
	    int   index;

	    Compare(Object left, Object right) = (left < right) ? -1 : (left > right ? 1 : 0);

	    for (ptr in names) {
		if (defined(ptr) && defined(*ptr, namemap)) {
		    if (namemap[*ptr] instanceof Array)
			indices[index++] = namemap[*ptr][0].id;
		    else indices[index++] = namemap[*ptr].id;
		} else indices[index++] = NULL;
	    }
	    qsort(indices, &Compare, names);
	}

	SortByRows(int selector, Array names) {
	    Array indices[names@sizeof];
	    int   index;

	    Compare(Object left, Object right) = (left < right) ? -1 : (left > right ? 1 : 0);

	    //
	    // This is easy because charts are arranged in row major order, so we
	    // just compare each cells index.
	    //

	    for (ptr in names) {
		if (defined(ptr) && defined(*ptr, namemap)) {
		    if (namemap[*ptr] instanceof Array)
			indices[index++] = namemap[*ptr][0].index;
		    else indices[index++] = namemap[*ptr].index;
		} else indices[index++] = NULL;
	    }
	    qsort(indices, &Compare, names);
	}

	SortByName(int selector, Array names) {
	    qsort(names);
	}

	////////////////////////////
	//
	// Label Functions
	//
	////////////////////////////

	GenerateCellLabels() {
	    Dictionary cell;
	    Dictionary generator;
	    Dictionary label;
	    Object     currentlinebounds;
	    Object     linebounds;
	    Object     linebackground;
	    Object     lineforeground;
	    Object     textbounds;
	    String     text;
	    double     baseline;
	    double     cellwidth;
	    double     interiorwidth;
	    double     x;
	    Array      generators;
	    Array      ends;
	    Font       font;
	    int        nextindex;
	    int        lastindex;
	    int        index;
	    int        length;
	    int        step;
	    int        layer;

	    //
	    // We walk though the generators one entry at a time, building
	    // the labels described by that generator and adding each one
	    // to every chart cell. It's an approach that means no cell has
	    // a complete set of labels until we're on the last generator,
	    // but cells with a partially complete set of labels can still
	    // be rendered. So our goal probably should be to start at the
	    // generator that has the most visible label and just go from
	    // there. For now we start on the last generator, which works
	    // nicely for our current labels, but we eventually might want
	    // a more general approach.
	    //

	    if (!generateCellLabels()) {
		if ((generators = GetCachedCellLabelGenerators()) != NULL) {
		    PreloadCellLabelData();
		    cellwidth = cellsize.width;
		    interiorwidth = cellwidth - 2*cellinset;
		    length = generators@sizeof;
		    for (index = length - 1, step = 1; step <= length; index = (index + 1)%length, step++) {
			UpdateChartStatus(step > 1, "Building Cell Labels: Step %d of %d", step, length);
			if (generator = generators[index]) {
			    if (generator.visible) {
				baseline = generator.baseline;
				font = generator.font;
				currentlinebounds = new Rectangle {
				    double x = 0;
				    double y = baseline + generator.fontbbox.y;
				    double width = interiorwidth;
				    double height = generator.fontbbox.height;
				};
				for (ptr in rowends) {
				    if (ends = *ptr) {
					nextindex = (ptr@offset)*columns + ends[0];
					lastindex = (ptr@offset)*columns + ends[1];
					for (; nextindex <= lastindex; nextindex++) {
					    for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(nextindex, &layer, 1)); ) {
						linebackground = generator.GetBackground(cell);
						lineforeground = generator.GetForeground(cell);
						if (cell.bounds.width != cellwidth) {
						    linebounds = new Rectangle {
							double x = currentlinebounds.x;
							double y = currentlinebounds.y;
							double width = cell.bounds.width - 2*cellinset;
							double height = currentlinebounds.height;
						    };
						} else linebounds = currentlinebounds;
						for (ptr in generator.layout) {
						    if (label = *ptr) {
							if (text = label.GetText(cell)) {
							    textbounds = GetStringBounds(text, font);
							    switch (label.alignment) {
								case CENTER:
								    x = (linebounds.width - textbounds.width)/2 - textbounds.x;
								    break;

								case LEFT:
								    x = 0;
								    break;

								case RIGHT:
								    x = linebounds.width - textbounds.width - textbounds.x;
								    break;
							    }
							    textbounds.x += x;
							    textbounds.y += baseline;
							    cell.labels[cell.nextlabel] = new Dictionary {
								Rectangle linebounds = linebounds;
								Rectangle textbounds = textbounds;
								String    text = text;
								Color     background = linebackground;
								Color     foreground = lineforeground;
								Font      font = font;
								int       selected = generator.selected;
								int       selectable = label.selectable;
								int       floater = label.floater;

								Point point = {
								    double x = x;
								    double y = baseline;
								};

								Function GetTipText = label.GetTipText;
							    };
							    linebackground = NULL;
							} else cell.labels[cell.nextlabel] = NULL;
							cell.nextlabel++;
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
		UpdateChartStatus(TRUE, NULL);
	    }
	    cellslabeled = TRUE;
	}

	GenerateChartLabels(Dictionary selected) {
	    Dictionary generator;
	    Dictionary desc;
	    Rectangle  fontbbox;
	    Object     bbox;
	    Object     bounds;
	    String     text;
	    String     group;
	    Point      point;
	    Array      location;
	    Array      newlabels;
	    Array      newchartlabels;
	    Array      generators;
	    double     dx;
	    double     dy;
	    double     x;
	    double     y;
	    double     xorigin;
	    double     yorigin;
	    double     cellwidth;
	    Font       scaledfont;
	    int        tight = FALSE;

	    if ((generators = GetCachedChartLabelGenerators()) != NULL) {
		newchartlabels = new Array[0, ...];
		cellwidth = cellsize.width;
		xorigin = chartbounds.x;
		yorigin = chartbounds.y;
		for (ptr in generators) {
		    if (generator = *ptr) {
			group = generator.group;
			if (selected == NULL || group == NULL || !defined(group, selected) || selected[group]) {
			    newlabels = new Array[0, ...];
			    scaledfont = GetScaledFont(generator.font, generator.fontscaling*cellsize.height);
			    fontbbox = GetFontBounds(scaledfont, tight);
			    bbox = NULL;
			    dx = generator.xoffset*columnwidth;
			    dy = generator.yoffset*rowheight;
			    switch (generator.baseline) {
				case BOTTOM:
				    dy += cellsize.height - (fontbbox.height + fontbbox.y);
				    break;

				case TOP:
				    dy += -fontbbox.y;
				    break;

				case CENTER:
				    dy += cellsize.height/2 - (fontbbox.y + fontbbox.height/2);
				    break;
			    }
			    while ((location = generator.NextCellLocation(location)) != NULL) {
				if ((text = generator.GetText(location)) != NULL) {
				    x = xorigin + location[1]*columnwidth + dx;
				    y = yorigin + location[0]*rowheight + dy;
				    //
				    // The for loop and the strsplit() call are recent
				    // additions that introduce some overhead, but cell
				    // label generation is really where we need to be
				    // careful, so it's acceptable here.
				    //
				    for (ptr in strsplit(text, "\n")) {
					if ((bounds = GetStringBounds(ptr[0], scaledfont)) != NULL) {
					    switch (generator.alignment) {
						case LEFT:
						    point.x = x;
						    break;

						case RIGHT:
						    point.x = x + cellwidth - (bounds.x + bounds.width);
						    break;

						case CENTER:
						    point.x = x + cellwidth/2 - (bounds.x + bounds.width/2);
						    break;
					    }
					    point.y = y;
					    bounds.x += point.x;
					    bounds.y += point.y;
					    desc = new Dictionary {
						Rectangle bounds = bounds;
						Point     point = {unroll(point)};
						String    text = ptr[0];
						Color     foreground = generator.foreground;
						Font      font = scaledfont;
						double    minscaling = generator.minscaling;
					    };
					    newlabels[newlabels@sizeof] = desc;
					    bbox = rectUnionRect(bbox, desc.bounds);
					    y += fontbbox.height;
					}
				    }
				}
			    }
			    newchartlabels[newchartlabels@sizeof] = new Dictionary {
				Rectangle bounds = bbox;
				String    group = group;
				Array     labels = newlabels;
			    };
			}
		    }
		}
	    }
	    chartlabels = newchartlabels@sizeof ? newchartlabels : NULL;
	}

	GetCachedCellLabelGenerators() {
	    synchronized(this) {
		if (cellgenerators == NULL)
		    cellgenerators = GetCellLabelGenerators();
	    }
	    return(cellgenerators);
	}

	GetCachedChartLabelGenerators() {
	    synchronized(this) {
		if (chartgenerators == NULL)
		    chartgenerators = GetChartLabelGenerators();
	    }
	    return(chartgenerators);
	}

	GetFontBounds(Font font, int tight, ...) {
	    //
	    // Returns a rectangle that can be used when vertical dimensions of
	    // a font are needed.
	    //
	    // NOTE - this isn't called often so there's no point in trying to
	    // cache answers.
	    //

	    return(font.stringbounds((argc > 3 && argv[3]) ? argv[3] : "ABCMNOPgjpy", tight));
	}

	GetScaledBounds(Rectangle bounds, Font font) {
	    Rectangle scaledbounds;
	    double    scaling;

	    //
	    // Returns a copy of bounds that's scaled by the same factor that
	    // would be used to scale font to NormalCellFont.
	    //
	    // NOTE - although not enforced, this really does assume that the
	    // NormalCellFont and the font handed to us as an argument belong
	    // to the same family!!!
	    //

	    if (font != NormalCellFont) {
		scaling = font.pointsize/NormalCellFont.pointsize;
		scaledbounds.x = scaling*bounds.x;
		scaledbounds.y = scaling*bounds.y;
		scaledbounds.width = scaling*bounds.width;
		scaledbounds.height = scaling*bounds.height;
	    } else scaledbounds = new Rectangle {unroll(bounds)};
	    return(scaledbounds);
	}

	GetScaledFont(Font font, double height) {
	    Rectangle bounds;
	    double    scaling;

	    bounds = GetFontBounds(font, TRUE);
	    return(font.scalefont(height/bounds.height));
	}

	GetStringBounds(String label, Font font) {
	    double scaling;
	    Object bounds;

	    bounds = NormalCellFont.stringbounds(label, TRUE);
	    if (font != NULL && font != NormalCellFont) {
		scaling = font.pointsize/NormalCellFont.pointsize;
		bounds.x *= scaling;
		bounds.y *= scaling;
		bounds.width *= scaling;
		bounds.height *= scaling;
	    }
	    return(bounds);
	}

	PreloadCellLabelData() {
	    Dictionary generator;
	    Array      generators;
	    double     topy = 0;
	    double     bottomy;
	    int        atbottom;

	    //
	    // This function is called right before we generate the labels for
	    // each cell to figure out where to put the baseline of every line
	    // described by an element in the cell label generator array.
	    //
	    // NOTE - the preloaded field really isn't needed, but it will make
	    // sure we don't change the careful calculations that end up saved
	    // baseline, which overwrites the original value, if we're called
	    // again. Would be just as easy, and clearer too, if we got rid of
	    // preloaded and saved the answer in a different (new) field!!!
	    //

	    if ((generators = GetCachedCellLabelGenerators()) != NULL) {
		if (cellsize != NULL) {
		    topy = 0;
		    bottomy = cellsize.height - 2*cellinset;
		    atbottom = TRUE;
		    for (ptr in generators) {
			if ((generator = *ptr) != NULL) {
			    generator {
				if (!preloaded && visible) {
				    switch (baseline) {
					case BOTTOM:
					    if (!atbottom)
						bottomy -= leading*fontbbox.height;
					    baseline = bottomy - (fontbbox.height + fontbbox.y);
					    bottomy -= fontbbox.height;
					    atbottom = FALSE;
					    break;

					case CENTER:
					    baseline = topy + (bottomy - topy)/2 + (-fontbbox.y - fontbbox.height/2);
					    topy = baseline + (fontbbox.height + fontbbox.y) + leading*fontbbox.height;
					    break;

					case TOP:
					default:
					    baseline = topy - fontbbox.y;
					    topy += (1 + leading)*fontbbox.height;
					    break;
				    }
				    preloaded = TRUE;
				}
			    }
			}
		    }
		} else Die("%s: cellsize if NULL", argv[0]);
	    }
	}

	////////////////////////////
	//
	// Matrix Functions
	//
	////////////////////////////

	GetAdjustedMatrix(Dimension size, double scaling, Point lock) {
	    Matrix matrix;
	    Point  anchor;
	    Point  center;

	    //
	    // Scales and translates the default matrix for a drawable that
	    // has size as its current size so that the user space lock point
	    // is mapped to the anchor that's appropriate for the drawable.
	    //

	    if ((matrix = GetDefaultMatrix(size, scaling)) != NULL) {
		switch (screenanchor) {
		    case TOPLEFT:
			anchor.x = 0;
			anchor.y = 0;
			break;

		    case TOP:
			anchor.x = size.width/2;
			anchor.y = 0;
			break;

		    case TOPRIGHT:
			anchor.x = size.width;
			anchor.y = 0;
			break;

		    case LEFT:
			anchor.x = 0;
			anchor.y = size.height/2;
			break;

		    case CENTER:
		    default:
			anchor.x = size.width/2;
			anchor.y = size.height/2;
			break;

		    case RIGHT:
			anchor.x = size.width;
			anchor.y = size.height/2;
			break;

		    case BOTTOMLEFT:
			anchor.x = 0;
			anchor.y = size.height;
			break;

		    case BOTTOM:
			anchor.x = size.width/2;
			anchor.y = size.height;
			break;

		    case BOTTOMRIGHT:
			anchor.x = size.width;
			anchor.y = size.height;
			break;
		}
		anchor = matrix.itransform(VM.screen.defaultmatrix.transform(anchor));
		matrix.translate(anchor.x - lock.x, anchor.y - lock.y);
	    }
	    return(matrix);
	}

	GetCellSize(Matrix matrix) {
	    Dimension size = NULL;

	    //
	    // If matrix is supplied the value returned is supposed to be in
	    // the default Yoix coordinate system. This probably isn't quite
	    // what we want - investigate later.
	    //

	    if (cellsize != NULL) {
		if (matrix != NULL)
		    size = VM.screen.defaultmatrix.idtransform(matrix.dtransform(cellsize));
		else size = new Dimension {unroll(cellsize)};
	    }
	    return(size);
	}

	GetDefaultMatrix(Dimension size, double scaling) {
	    Rectangle bbox;
	    Insets    insets;
	    Matrix    matrix;
	    double    scale;
	    double    dx1;
	    double    dy1;
	    double    dx2;
	    double    dy2;

	    //
	    // Returns a scaled version of a matrix that can be used as the
	    // default matrix when chart is displayed in a drawable object
	    // (e.g., a JCanvas) that has size as its current size.
	    //

	    if ((bbox = boundingbox) != NULL) {
		if (screenanchorinsets)
		    insets = screenanchorinsets;
		switch (screenanchor) {
		    case TOPLEFT:
			scale = scaling*min((size.width - insets.left)/bbox.width, (size.height - insets.top)/bbox.height);
			dx1 = insets.left;
			dy1 = insets.top;
			dx2 = bbox.x;
			dy2 = bbox.y;
			break;

		    case TOP:
			scale = scaling*min(size.width/bbox.width, (size.height - insets.top)/bbox.height);
			dx1 = size.width/2;
			dy1 = insets.top;
			dx2 = -(bbox.x + bbox.width/2);
			dy2 = bbox.y;
			break;

		    case TOPRIGHT:
			scale = scaling*min((size.width - insets.right)/bbox.width, (size.height - insets.top)/bbox.height);
			dx1 = size.width - insets.right;
			dy1 = insets.top;
			dx2 = -bbox.width;
			dy2 = bbox.y;
			break;

		    case LEFT:
			scale = scaling*min((size.width - insets.left)/bbox.width, size.height/bbox.height);
			dx1 = insets.left;
			dy1 = size.height/2;
			dx2 = bbox.x;
			dy2 = -(bbox.y + bbox.height/2);
			break;

		    case CENTER:
		    default:
			scale = scaling*min(size.width/bbox.width, size.height/bbox.height);
			dx1 = size.width/2;
			dy1 = size.height/2;
			dx2 = -(bbox.x + bbox.width/2);
			dy2 = -(bbox.y + bbox.height/2);
			break;

		    case RIGHT:
			scale = scaling*min((size.width - insets.right)/bbox.width, size.height/bbox.height);
			dx1 = size.width - insets.right;
			dy1 = size.height/2;
			dx2 = -bbox.width;
			dy2 = -(bbox.y + bbox.height/2);
			break;

		    case BOTTOMLEFT:
			scale = scaling*min((size.width - insets.left)/bbox.width, (size.height - insets.bottom)/bbox.height);
			dx1 = insets.left;
			dy1 = size.height - insets.top;
			dx2 = bbox.x;
			dy2 = -bbox.height;
			break;

		    case BOTTOM:
			scale = scaling*min(size.width/bbox.width, (size.height - insets.bottom)/bbox.height);
			dx1 = size.width/2;
			dy1 = size.height - insets.top;
			dx2 = -(bbox.x + bbox.width/2);
			dy2 = -bbox.height;
			break;

		    case BOTTOMRIGHT:
			scale = scaling*min((size.width - insets.right)/bbox.width, (size.height - insets.bottom)/bbox.height);
			dx1 = size.width - insets.right;
			dy1 = size.height - insets.top;
			dx2 = -bbox.width;
			dy2 = -bbox.height;
			break;
		}
		if (scale > 0) {
		    matrix.initmatrix();
		    matrix.translate(dx1, dy1);
		    matrix.scale(scale, scale);
		    matrix.translate(dx2, dy2);
		} else matrix = NULL;
	    } else matrix = NULL;
	    return(matrix);
	}

	////////////////////////////
	//
	// Moved Cell Functions
	//
	////////////////////////////

	CheckAllCells(Graphics graphics) {
	    Dictionary cell;
	    Dictionary prev;
	    Array      mark[0, ...];

	    synchronized(movedcells) {
		for (cell = movedcells.prev; cell != movedcells; ) {
		    prev = cell.prev;
		    if (rectIntersectsRect(cell.bounds, chartbounds)) {
			AddBadCellMark(cell);
			PaintRect(cell.bounds, FALSE, graphics);
		    } else ClearBadCellMark(cell);	// should be unnecessary
		    cell = prev;
		}
	    }
	}

	PickClosestMovedCell(Dictionary target, int direction) {
	    Dictionary closest = target;
	    Dictionary cell;
	    int        separation;
	    int        sep;
	    int        id;

	    if (direction != 0 && !puzzle) {
		synchronized(movedcells) {
		    if (movedcells.next != movedcells) {
			id = (target != NULL) ? target.id : 0;
			separation = cellcount;
			for (cell = movedcells.next; cell != movedcells; cell = cell.next) {
			    if ((sep = cell.id - id) != 0) {
				if (direction > 0) {
				    if (sep < 0)
					sep = cellcount - id + cell.id;
				} else {
				    if (sep > 0)
					sep = id + (cellcount - cell.id);
				    else sep = -sep;
				}
				if (sep < separation) {
				    separation = sep;
				    closest = cell;
				}
			    }
			}
		    }
		}
	    }
	    return(closest);
	}

	RaiseCell(Dictionary cell) {
	    //
	    // Moves the selected cell to the end of the movedcells list, which
	    // means it's the last cell painted, and that essentially "raises"
	    // cell above all the others (whenever the next paint happens).
	    //

	    synchronized(movedcells) {
		if (movedcells.prev != cell) {
		    if (cell.next != NULL && cell.prev != NULL) {
			cell.prev.next = cell.next;
			cell.next.prev = cell.prev;
			cell.prev = NULL;
			cell.next = NULL;
			cell.prev = movedcells.prev;
			cell.next = movedcells;
			movedcells.prev.next = cell;
			movedcells.prev = cell;
		    }
		}
	    }
	}

	RemoveCell(Dictionary cell) {
	    //
	    // Appends cell to the movedcells linked list, if it's not already
	    // in the list, and removes it from the chart. Older versions of
	    // this function raised the cell if it already had been moved out
	    // of the chart, but the caller now has that responsibility.
	    //

	    synchronized(movedcells) {
		if (cell.next == NULL && cell.prev == NULL) {
		    cell.prev = movedcells.prev;
		    cell.next = movedcells;
		    movedcells.prev.next = cell;
		    movedcells.prev = cell;

		    if (cell.layer >= 0)
			chartcells[cell.index][cell.layer] = NULL;
		    else chartcells[cell.index] = NULL;
		}
	    }
	}

	ReturnAllCells(int unmark, Graphics graphics) {
	    Dictionary cell;

	    //
	    // Returns all cells in the linked list to their slots in the
	    // chart. Right now we let ReturnCell() handle all the painting
	    // (assuming graphics isn't NULL). Not the fastest approach if
	    // there are lots of moved cells, but slowing this down seems
	    // visually appealing.
	    //

	    synchronized(movedcells) {
		if (movedcells.next != movedcells) {
		    for (cell = movedcells.next; cell != movedcells; cell = movedcells.next)
			ReturnCell(cell, unmark, graphics);
		}
	    }
	}

	ReturnCell(Dictionary cell, int unmark, Graphics graphics) {
	    double dx;
	    double dy;
	    int    visible;
	    int    steps;

	    //
	    // Removes cell from the movedcells linked list, if it's still in
	    // in the list, puts it back in the chart. If graphics isn't NULL
	    // then we're responsible for repainting the old and new locations
	    // of the cell, otherwise it's the caller's job.
	    //

	    synchronized(movedcells) {
		if (cell.next != NULL && cell.prev != NULL) {
		    visible = cell.flags&CELL_VISIBLE;
		    if (unmark)
			ClearBadCellMark(cell);
		    if (graphics && visible) {
			//
			// We first make sure cell is showing completely so
			// it can be moved around on the screen by copying
			// (i.e., via rectmove()).
			//
			RaiseCell(cell);
			PaintCell(cell, graphics);
			dx = cell.home.x - cell.bounds.x;
			dy = cell.home.y - cell.bounds.y;
			steps = min(MAXSTEPS, ceil(sqrt(dx*dx + dy*dy)/celldiagonal));
		        PaintCellAlongLine(cell, cell.home, steps, TRUE, graphics);
		    }
		    cell.prev.next = cell.next;
		    cell.next.prev = cell.prev;
		    cell.prev = NULL;
		    cell.next = NULL;
		    cell.bounds.x = cell.home.x;
		    cell.bounds.y = cell.home.y;

		    if (cell.layer >= 0)
			chartcells[cell.index][cell.layer] = cell;
		    else chartcells[cell.index] = cell;

		    if (graphics && visible)
			PaintRect(cell.bounds, FALSE, graphics);
		}
	    }
	}

	ScatterAllCells(Graphics graphics) {
	    Dictionary cell;
	    Dictionary prev;
	    int        layer;

	    //
	    // Unfortunately this one is tricky, at least it is if we're
	    // really supposed to go through all the moved cells, because
	    // the cell we're working on is automatically moved to the end
	    // of the list when it's "raised" for painting.
	    //

	    if (scatterrects) {
		synchronized(movedcells) {
		    for (cell = movedcells.prev; cell != movedcells; ) {
			prev = cell.prev;
			if (rectIntersectsRect(cell.bounds, chartbounds))
			    ScatterCell(cell, graphics);
			cell = prev;
		    }
		    for (ptr in chartcells) {
			for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(ptr@offset, &layer, 1)); )
			    ScatterCell(cell, graphics);
		    }
		    //
		    // Randomly raise some cells so stacking order of cells that
		    // happen to overlap won't really help.
		    //
		    for (cell = movedcells.prev; cell != movedcells; ) {
			prev = cell.prev;
			if (random() < 0.5) {
			    RaiseCell(cell);
			    if (graphics)
				PaintRect(cell.bounds, FALSE, graphics);
			}
			cell = prev;
		    }
		}
	    }
	}

	ScatterCell(Dictionary cell, Graphics graphics) {
	    Rectangle rect;
	    double    dx;
	    double    dy;
	    double    fraction;
	    Point     point;
	    int       visible;
	    int       steps;
	    int       last;
	    int       n;

	    if ((last = scatterrects@sizeof - 1) >= 0) {
		synchronized(movedcells) {
		    visible = cell.flags&CELL_VISIBLE;
		    RemoveCell(cell);
		    ClearBadCellMark(cell);
		    fraction = random();
		    for (n = 0; n < last && fraction >= scatterweights[n]; n++) ;
		    rect = scatterrects[n];
		    point.x = rect.x + (rect.width - columnwidth)*random();
		    point.y = rect.y + (rect.height - rowheight)*random();
		    if (graphics && visible) {
			//
			// We first make sure cell is showing completely so
			// it can be moved around on the screen by copying
			// (i.e., via rectmove()).
			//
			RaiseCell(cell);
			PaintCell(cell, graphics);
			dx = point.x - cell.bounds.x;
			dy = point.y - cell.bounds.y;
			steps = min(MAXSTEPS, ceil(sqrt(dx*dx + dy*dy)/celldiagonal));
		        PaintCellAlongLine(cell, point, steps, TRUE, graphics);
		    }
		    cell.bounds.x = point.x;
		    cell.bounds.y = point.y;
		    if (graphics && visible)
			PaintRect(cell.bounds, FALSE, graphics);
		}
	    }
	}

	SnapCellToGrid(Dictionary cell, Point point, Graphics graphics) {
	    Point corner;
	    Point center;

	    //
	    // Looks like we need to do a bit more because we probably don't
	    // want to snap the cell to an "occupied" grid. Will get to it
	    // later on - this is sufficient for now.
	    //

	    if (snaptogrid) {
		synchronized(movedcells) {
		    if (cell.next != NULL && cell.prev != NULL) {
			if (pointInRect(point, chartbounds)) {
			    if (IsGridEmptyAt(point)) {
				corner = GetGridPoint(point);
				if (point.x != corner.x || point.y != corner.y) {
				    EraseCell(cell, graphics);
				    cell.bounds.x = corner.x;
				    cell.bounds.y = corner.y;
				    PaintRect(cell.bounds, FALSE, graphics);
				    //
				    // This is required, no matter what the caller
				    // has done, because cells can be separated by
				    // empty space so we may have move the cell to
				    // its home. So we definitely need the check,
				    // but it's likely we could pass NULL as the
				    // graphics to avoid unnecessary painting or
				    // we could adjust the links and chartcells[]
				    // right here.
				    //
				    center.x = cell.bounds.x + cell.bounds.width/2;
				    center.y = cell.bounds.y + cell.bounds.height/2;
				    if (pointInRect(center, GetHomeBoundsForCell(cell)))
					ReturnCell(cell, TRUE, graphics);
				    //
				    // Cell is in the wrong slot if it's still on
				    // the moved cell list.
				    //
				    if (autocheck) {
					if (cell.next != NULL && cell.prev != NULL)
					    AddBadCellMark(cell);
					else ClearBadCellMark(cell);	// should be unnecessary
				    }
				}
			    }
			}
		    }
		}
	    }
	}

	////////////////////////////
	//
	// Filter Functions
	//
	////////////////////////////

	LoadAllFilters() {
	    Dictionary buckets;
	    Dictionary cell;
	    Object     value;
	    Object     count;		// using an Object here is important
	    String     name;
	    String     key;
	    Array      bucket;
	    Array      singleton[1];
	    int        maxcount;
	    int        nextbit;
	    int        bits;
	    int        base;
	    int        mask;

	    //
	    // Getting an array of strings back from GetFilterValue() is unusual
	    // but it's allowed so we decided to force all returns into the array
	    // format.
	    //

	    synchronized(filters) {
		nextbit = CELL_FITLER_STARTBIT;
		filtermask = 0;
		for (ptr in filters) {
		    key = ptr[0]@nameof;
		    buckets = new Dictionary[0, ...];
		    maxcount = 1;
		    for (ptr in allcells) {
			cell = ptr[0];
			value = GetFilterValue(cell, key);
			if (value instanceof String) {
			    singleton[0] = value;
			    value = singleton;
			}
			if (value instanceof Array) {
			    if ((count = value@sizeof) > maxcount)
				maxcount = count;
			    //
			    // We attach cell to every bucket named in value even
			    // if it's already in the list, which guarantees cell
			    // will appear count times so the bits allocated later
			    // as our "counter" will work properly.
			    //
			    for (ptr in value) {
				if (ptr[0] instanceof String) {
				    name = ptr[0];
				    if (defined(name, buckets)) {
					bucket = buckets[name];
					if (bucket[bucket@sizeof-1] != count) {
					    bucket[bucket@sizeof-1] = count;
					    bucket[bucket@sizeof] = cell;
					} else bucket[bucket@sizeof-1] = cell;
					bucket[bucket@sizeof] = count;
				    } else buckets[name] = new Array[0, ...] {count, cell, count};
				}
			    }
			}
		    }
		    if (buckets@sizeof) {
			//
			// If cells can contribute to multiple buckets maxcount will
			// be greater than one and in that case we allocated enough
			// bits count them plus one additional bit that's used to
			// mark the cell as selected or not.
			//
			for (count = maxcount, bits = maxcount > 1 ? 1 : 0; count != 0; count >>>= 1, bits++) ;
			base = (1 << bits) - 1;
			mask = base << nextbit;
			filtermask |= (1 << nextbit);
			if (base == mask >>> nextbit) {
			    filters[key] = new Dictionary {
				Dictionary buckets = buckets;
				int        startbit = nextbit;
				int        mask = mask;
			    };
			    nextbit += bits;
			} else {
			    Warn("ran out of available mask bits while constructing filter %s", key);
			    break;
			}
		    }
		}
	    }
	}

	RegisterFilter(String key) {
	    if (!defined(key, filters))
		filters[key] = NULL;
	}

	SetFilteredBy(String key, String value, int state) {
	    Dictionary cell;
	    Array      bucket;
	    int        repaint = FALSE;
	    int        mask;
	    int        startbit;
	    int        total;
	    int        shift;
	    int        flags;
	    int        deselected;
	    int        count;

	    synchronized(filters) {
		if (key && defined(key, filters) && filters[key] && defined(value, filters[key].buckets)) {
		    if ((mask = filters[key].mask) != 0) {
			startbit = filters[key].startbit;
			bucket = filters[key].buckets[value];
			total = 1;
			shift = 0;
			for (ptr in bucket) {
			    if (ptr[0] instanceof Dictionary) {
				cell = ptr[0];
				flags = (cell.flags&mask) >>> startbit;
				count = flags >>> shift;
				deselected = flags&0x01;
				if (!state) {
				    if (++count <= total) {
					if (count == total) {
					    deselected = 1;
					    if ((cell.flags&filtermask) == 0) {
						if (cell.flags & CELL_VISIBLE) {
						    cell.flags &= ~CELL_VISIBLE;
						    visiblecellcount--;
						    repaint = TRUE;
						}
					    }
					}
					cell.flags = (cell.flags & ~mask) | (((count << shift | deselected) << startbit)&mask);
				    }
				} else {
				    if (count > 0) {
					if (count-- == total)
					    deselected = 0;
					cell.flags = (cell.flags & ~mask) | (((count << shift | deselected) << startbit)&mask);
					if ((cell.flags&filtermask) == 0) {
					    if ((cell.flags & CELL_VISIBLE) == 0) {
						cell.flags |= CELL_VISIBLE;
						visiblecellcount++;
						repaint = TRUE;
					    }
					}
				    }
				}
			    } else {
				total = ptr[0];
				shift = (total == 1) ? 0 : 1;
			    }
			}
		    }
		}
	    }
	    return(repaint);
	}

	SetFilteredByAll(String key, int state) {
	    int repaint = FALSE;

	    synchronized(filters) {
		if (key && defined(key, filters) && filters[key]) {
		    for (ptr in filters[key].buckets) {
			if (ptr[0] instanceof Array) {
			    if (SetFilteredBy(key, ptr[0]@nameof, state))
				repaint = TRUE;
			}
		    }
		}
	    }
	    return(repaint);
	}

	////////////////////////////
	//
	// Paint Functions
	//
	////////////////////////////

	EraseCell(Dictionary cell, Graphics graphics) {
	    int visible = cell.flags&CELL_VISIBLE;

	    //
	    // A little trickier than it probably should be because you might
	    // think you could use recterase() and to erase the cell, but that
	    // wouldn't repaint stuff that lies below or above the cell. You
	    // also might think you could use PaintCell(), but any cell that
	    // doesn't have its CELL_VISIBLE flag set is completely ignored,
	    // which also means it won't be explicily erased.
	    //

	    cell.flags &= ~CELL_VISIBLE;
	    PaintRect(cell.bounds, TRUE, graphics);
	    cell.flags |= visible;
	}

	EraseRect(Rectangle rect, Graphics graphics) {
	    //
	    // A convenience function that we included for completeness, but
	    // it's probably not currently used.
	    //

	    PaintRect(rect, TRUE, graphics);
	}

	Paint(Graphics graphics, int clear) {
	    Dictionary cell;
	    Rectangle  rect;
	    Rectangle  chartrect;
	    Array      corners;
	    Array      ends;
	    int        index;
	    int        last;
	    int        row;
	    int        layer;

	    //
	    // This function assumes the clipping path has been properly set,
	    // so we can use it here, via clippath() and pathbbox(), to get
	    // a user space rectangle that just covers the parts of the chart
	    // that need painting. The individual paint functions can use the
	    // rectangle that we derive here to reduce their work load.
	    //
	    // NOTE - a related function named PaintRect() is defined below
	    // and explicitly sets the clipping path to the rectangle that's
	    // passed as an argument. The difference between these functions
	    // is subtle and might not be immediately obvious. In this case
	    // the clipping path can be an arbitrary shape, not necessarily
	    // a rectangle, and we're not supposed to change it, but we can
	    // measure it.
	    //
	    // NOTE - uses the clipping path to skip cells that don't need
	    // painting when PAINT_USECLIP is TRUE. It can be important when
	    // we're painting long links that aren't horizontal or vertical.
	    // Was added recently and we've seen a few painting issues that
	    // are probably unrelated, which is why it can be disabled using
	    // a command line option.
	    //

	    graphics {
		gsave();
		clippath();
		rect = pathbbox();
		newpath();
		if (clear)
		    erasedrawable();
		PaintChartGrid(rect, graphics);
		PaintChartLabels(rect, graphics);

		if (PAINT_USECLIP) {
		    //
		    // This is the extra work that's supposed to skip cells that
		    // aren't intersected by the clipping path. It pretty much
		    // duplicates what's done at the start of PaintChartCells()
		    // to find candidate cells, but skips the ones that don't
		    // intersect the clipping path.
		    //
		    clippath();
		    if ((chartrect = rectIntersectionRect(rect, chartbounds)) != NULL) {
			if ((corners = PickCellsInRect(chartrect)) != NULL) {
			    for (row = corners[0]; row <= corners[2]; row++) {
				if (ends = rowends[row]) {
				    index = row*columns + max(corners[1], ends[0]);
				    last = row*columns + min(corners[3], ends[1]);
				    for (; index <= last; index++) {
					for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(index, &layer, 1)); ) {
					    if (cell.flags&CELL_VISIBLE) {
						if (intersects(cell.bounds)) {
						    newpath();
						    PaintCell(cell, graphics);
						    clippath();
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		    newpath();
		} else PaintChartCells(rect, graphics);

		PaintMovedCells(rect, NULL, graphics);
		PaintChartLinks(rect, NULL, graphics);
		PaintChartMarks(rect, NULL, graphics);
		grestore();
	    }
	}

	PaintCell(Dictionary cell, Graphics graphics, ...) {
	    Dictionary label;
	    Rectangle  bbox = NULL;
	    Object     bounds;
	    double     tx;
	    double     ty;
	    Color      currentcolor = NULL;
	    Color      color = NULL;
	    Font       currentfont = NULL;
	    int        showselected;
	    int        paintlayers;

	    if (cell != NULL && cell.flags&CELL_VISIBLE) {
		paintlayers = (argc <= 3 || argv[3]);
		showselected = cell.flags&CELL_SELECTED;
		bounds = cell.bounds;
		tx = bounds.x + cellinset;
		ty = bounds.y + cellinset;
		if (showselected && bounds.height <= minselectedsize) {
		    showselected = FALSE;
		    currentcolor = CellColors.LIGHTGRAY;
		} else currentcolor = cell.background;
		graphics.foreground = currentcolor;
		if (cellborder >= minbordersize)
		    graphics.rectbutton(bounds, cellborder, cell.state);
		else graphics.rectfill(bounds);
		if (cellsize.height >= minlabelsize && (showunselectedlabels || showselected)) {
		    for (ptr in cell.labels) {
			if (ptr@offset < cell.nextlabel) {
			    if (label = *ptr) {
				if (!label.selectable || cell.selectable) {
				    //
				    // This test implicitly assumes label.font and the font
				    // declared in the line's generator match because that's
				    // what the fast version of PaintChartCells() checks.
				    //
				    if (label.font.pointsize >= minpointsize) {
					if (!label.floater) {
					    if (label.background) {
						if (label.background != currentcolor) {
						    currentcolor = label.background;
						    graphics.foreground = currentcolor;
						}
						graphics.rectfill(label.linebounds.x + tx, label.linebounds.y + ty, label.linebounds.width, label.linebounds.height);
					    }
					    color = (showselected && label.selected || label.selectable) ? cell.selectedforeground : label.foreground;
					    if (color != currentcolor) {
						currentcolor = color;
						graphics.foreground = currentcolor;
					    }
					    if (label.font != currentfont) {
						currentfont = label.font;
						graphics.font = currentfont;
					    }
					    graphics.moveto(label.point.x + tx, label.point.y + ty);
					    graphics.show(label.text);
					} else {
					    if (bbox == NULL)
						bbox = graphics.drawablebbox();
					    PaintFloatingLabel(cell, label, FALSE, bbox, NULL, graphics);
					    currentfont = NULL;
					    currentcolor = NULL;
					}
				    }
				}
			    }
			} else break;
		    }
		}
		if (cell.marks) {
		    //
		    // The comments below about unnecessary painting also apply to
		    // PaintCellMarks(), which PaintChartCells() also calls, so our
		    // eventual changes should keep this part in mind too.
		    //
		    if (cellsize.height > minmarksize)
			PaintCellMarks(cell, graphics);
		}
		if (paintlayers) {
		    if (cell.next == NULL) {
			//
			// Checking cell.layer and cell.flags is needed to make sure
			// cells that overlap in the chart are painted in the proper
			// order. There's undoubtedly a more efficient approach since
			// this way will paint the cell a second time. We'll leave it
			// be for now because it probably won't happen that much, but
			// we eventually will eliminate the unnecessary painting.
			//
			if (cell.layer >= 0 || cell.flags&CELL_MULTICELL) {
			    graphics.gsave();
			    graphics.rectclip(bounds);
			    PaintChartCells(bounds, graphics);
			    graphics.grestore();
			}
			PaintMovedCells(bounds, NULL, graphics);
		    }
		    PaintChartLinks(bounds, NULL, graphics);
		    PaintChartMarks(bounds, NULL, graphics);
		}
	    }
	}

	PaintCellAlongLine(Dictionary cell, Point point, int steps, int erase, Graphics graphics) {
	    double x0;
	    double y0;
	    double dx;
	    double dy;
	    double dt;
	    double t;
	    double x;
	    double y;
	    int    n;

	    //
	    // Moves the cell from its current location along a straight line
	    // to point. If erase is TRUE we erase the last cell that we drew
	    // (actually copied) and assume the caller will be responsible for
	    // the final step. It's sometimes required if we've zoomed in or
	    // out after moving the cell out of it's slot in the chart because
	    // the dimensions of the rectangle that we're moving around on the
	    // screen might be off by a pixel when compared to the cell that
	    // actually fits in the "scaled" chart.
	    //

	    if (steps > 0) {
		x0 = cell.bounds.x;
		y0 = cell.bounds.y;
		dx = point.x - x0;
		dy = point.y - y0;
		dt = 1.0/steps;
		if (erase)
		    steps--;
		for (n = 1; n < steps; n++) {
		    t = n*dt;
		    x = t*dx + x0;
		    y = t*dy + y0;
		    graphics.rectmove(cell.bounds, x - cell.bounds.x, y - cell.bounds.y);
		}
		if (erase)
		    EraseCell(cell, graphics);
	    }
	}

	PaintCellMarks(Dictionary cell, Graphics graphics) {
	    Object interior;

	    if (cell.marks && cell != movingcell) {
		graphics.gsave();
		interior = GetCellInteriorBounds(cell);
		graphics.rectclip(interior, TRUE);
		graphics.translate(interior.x, interior.y);
		for (mark in cell.marks) {
		    if (mark[0])		// skip marks set to NULL
			PaintMarks(mark[0], graphics);
		}
		graphics.grestore();
	    }
	}

	PaintChartCells(Rectangle rect, Graphics graphics) {
	    Dictionary cell;
	    Dictionary label;
	    Rectangle  bbox = NULL;
	    Object     bounds;
	    double     tx;
	    double     ty;
	    Array      corners;
	    Array      ends;
	    Color      color = NULL;
	    Color      currentcolor = NULL;
	    Font       currentfont = NULL;
	    int        showselected;
	    int        index;
	    int        last;
	    int        row;
	    int        layer;

	    //
	    // This is the default version that should work for all charts, but it
	    // can be (and probably is) replaced by a faster version when there's
	    // only 1 layer of cells. The overhead introduced by GetNextChartCell()
	    // is one reason why this is a slow version, but it's also why it can
	    // handle all charts. In charts where there's only one layer of cells
	    // GetNextChartCell() isn't required and eliminating the loop testing,
	    // function call overhead, and extra work done in GetNextChartCell()
	    // makes a noticeable difference in moderate sized charts (i.e., more
	    // than 1000 cells).
	    //
	    // This implementation currently takes another performance hit because
	    // each cell is finished before the next one is started and that usually
	    // means there are more font and color changes than are really necessary.
	    // The explanation for the performance hit from font and color changes
	    // lies in the way our low level Java code handles graphics objects that
	    // Java uses for rendering text strings. We eventually hope the overhead
	    // will be significanly reduced and that would mean there wouldn't be a
	    // need for two fundamentally different algorithms.
	    //
	    // NOTE - most applications use builtins defined in the ychart module to
	    // handle painting, so these Yoix implementations usually aren't called.
	    //
	    // NOTE - we initially tried to deal with floating labels here, but we
	    // never really got it to work properly. One obvious approach would be
	    // to check for a floating label the needs painting (i.e., it intersects
	    // a rectangle) and then temporarily toss current clipping path using
	    // initclip(), paint the label at the right place, and restore clipping.
	    // Unfortunately automatic panning currently uses paintImmediately(),
	    // which doesn't seem to let us affect clipping. Switching the Java code
	    // to use repaint() resulted in a slight improvement, but the performance
	    // and label repainting was unpredictable and we're really not sure why.
	    // There's a small chance this eventually would work, but we decided to
	    // go with a more complicated implementation that seems to result in a
	    // reasonably responsive repainting of floating labels.
	    // 

	    if ((rect = rectIntersectionRect(rect, chartbounds)) != NULL) {
		if ((corners = PickCellsInRect(rect)) != NULL) {
		    if (!paintChartCells(corners, graphics)) {
			for (row = corners[0]; row <= corners[2]; row++) {
			    if (ends = rowends[row]) {
				index = row*columns + max(corners[1], ends[0]);
				last = row*columns + min(corners[3], ends[1]);
				for (; index <= last; index++) {
				    for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(index, &layer, 1)); ) {
					//
					// The intersection test currently isn't in the ychart
					// module version. If it's added we then we probably
					// should check simplecellmodel before the intersection
					// and that also means rect should be passed in as an
					// argument - we will investigate later.
					//
					if (cell.flags&CELL_VISIBLE && rectIntersectsRect(rect, cell.bounds)) {
					    showselected = cell.flags&CELL_SELECTED;
					    bounds = cell.bounds;
					    tx = bounds.x + cellinset;
					    ty = bounds.y + cellinset;
					    if (showselected && bounds.height <= minselectedsize) {
						showselected = FALSE;
						color = CellColors.LIGHTGRAY;
					    } else color = cell.background;
					    if (color != currentcolor) {
						currentcolor = color;
						graphics.foreground = currentcolor;
					    }
					    if (cellborder >= minbordersize)
						graphics.rectbutton(bounds, cellborder, cell.state);
					    else graphics.rectfill(bounds);
					    if (cellsize.height >= minlabelsize && (showunselectedlabels || showselected)) {
						for (ptr in cell.labels) {
						    if (ptr@offset < cell.nextlabel) {
							if (label = *ptr) {
							    if (!label.selectable || cell.selectable) {
								if (label.font.pointsize >= minpointsize) {
								    if (!label.floater) {
									if (label.background) {
									    if (label.background != currentcolor) {
										currentcolor = label.background;
										graphics.foreground = currentcolor;
									    }
									    graphics.rectfill(label.linebounds.x + tx, label.linebounds.y + ty, label.linebounds.width, label.linebounds.height);
									}
									color = (showselected && label.selected || label.selectable) ? cell.selectedforeground : label.foreground;
									if (color != currentcolor) {
									    currentcolor = color;
									    graphics.foreground = currentcolor;
									}
									if (label.font != currentfont) {
									    currentfont = label.font;
									    graphics.font = currentfont;
									}
									graphics.moveto(label.point.x + tx, label.point.y + ty);
									graphics.show(label.text);
								    } else {
									if (bbox == NULL)
									    bbox = graphics.drawablebbox();
									PaintFloatingLabel(cell, label, FALSE, bbox, NULL, graphics);
									currentfont = NULL;
									currentcolor = NULL;
								    }
								}
							    }
							}
						    } else break;
						}
					    }
					    if (cell.marks) {
						if (cellsize.height > minmarksize)
						    PaintCellMarks(cell, graphics);
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}

	PaintChartCells_Simple(Rectangle rect, Graphics graphics) {
	    Dictionary cell;
	    Dictionary label;
	    Dictionary generator;
	    Object     bounds;
	    double     tx;
	    double     ty;
	    Array      corners;
	    Array      ends;
	    Array      generators;
	    Color      color = NULL;
	    Color      currentcolor = NULL;
	    Font       currentfont = NULL;
	    int        showselected;
	    int        labelindex;
	    int        count;
	    int        index;
	    int        last;
	    int        row;

	    //
	    // This version explicitly assumes there's only one layer of cells, so
	    // each entry in chartcells is NULL or a cell dictionary. That means we
	    // don't have to call GetNextChartCell() in a loop but instead we just
	    // index directly into the chartcells array to get the next call. It's
	    // an approach that saves loop testing, function call overhead, and all
	    // the extra work that GetNextChartCell() does which adds up when you're
	    // dealing with moderatly large charts (i.e., more than 1000 cells).
	    //
	    // In addition this version tries to the reduce font and color changes
	    // that would usually happen if each cell was completely painted before
	    // starting the next one, as is done in default version of this function.
	    // The explanation for the performance hit from font and color changes
	    // lies in the way our low level Java code handles graphics objects that
	    // Java uses for rendering text strings. We eventually hope the overhead
	    // will be significanly reduced and that would mean there wouldn't be a
	    // need for two fundamentally different algorithms.
	    //
	    // NOTE - most applications use builtins defined in the ychart module to
	    // handle painting, so these Yoix implementations usually aren't called.
	    //
	    // NOTE - this algorithm usually doesn't work well when cells overlap, so
	    // it's not "installed" when multicellchart is set to TRUE.
	    //

	    if ((rect = rectIntersectionRect(rect, chartbounds)) != NULL) {
		if ((corners = PickCellsInRect(rect)) != NULL) {
		    if (!paintChartCells(corners, graphics)) {
			for (row = corners[0]; row <= corners[2]; row++) {
			    if (ends = rowends[row]) {
				index = row*columns + max(corners[1], ends[0]);
				last = row*columns + min(corners[3], ends[1]);
				for (; index <= last; index++) {
				    if ((cell = chartcells[index]) && cell.flags&CELL_VISIBLE) {
					showselected = cell.flags&CELL_SELECTED;
					if (showselected && cell.bounds.height <= minselectedsize) {
					    showselected = FALSE;
					    color = CellColors.LIGHTGRAY;
					} else color = cell.background;
					if (color != currentcolor) {
					    currentcolor = color;
					    graphics.foreground = currentcolor;
					}
					if (cellborder >= minbordersize)
					    graphics.rectbutton(cell.bounds, cellborder, cell.state);
					else graphics.rectfill(cell.bounds);
				    }
				}
			    }
			}

			if (cellsize.height >= minlabelsize) {
			    if ((generators = GetCachedCellLabelGenerators()) != NULL) {
				labelindex = 0;
			    	for (ptr in generators) {
				    generator = ptr[0];
				    //
				    // NOTE - this test implicitly assumes that generator.font and
				    // label.font match because PaintCell() only checks label.font
				    // and painting decisions in both places should be the same. If
				    // more than one font can be used on a line then this assumption
				    // will have to be addressed.
				    //
				    if (generator.font.pointsize >= minpointsize) {
					for (count = generator.layout@sizeof; count > 0; count--, labelindex++) {
					    for (row = corners[0]; row <= corners[2]; row++) {
						if (ends = rowends[row]) {
						    index = row*columns + max(corners[1], ends[0]);
						    last = row*columns + min(corners[3], ends[1]);
						    for (; index <= last; index++) {
							if ((cell = chartcells[index]) && cell.flags&CELL_VISIBLE) {
							    if (labelindex < cell.nextlabel && (label = cell.labels[labelindex])) {
								if (!label.selectable || cell.selectable) {
								    showselected = cell.flags&CELL_SELECTED;
								    if (showunselectedlabels || showselected) {
									tx = cell.bounds.x + cellinset;
									ty = cell.bounds.y + cellinset;
									//
									// PaintCell() would compare label.font and
									// minpointsize at this point. We've already
									// checked using generator.font so we skip
									// the test because the two fonts are assumed
									// to be the same.
									//
									if (label.background) {
									    if (label.background != currentcolor) {
										currentcolor = label.background;
										graphics.foreground = currentcolor;
									    }
									    graphics.rectfill(label.linebounds.x + tx, label.linebounds.y + ty, label.linebounds.width, label.linebounds.height);
									}
									color = (showselected && label.selected || label.selectable) ? cell.selectedforeground : label.foreground;
									if (color != currentcolor) {
									    currentcolor = color;
									    graphics.foreground = currentcolor;
									}
									if (label.font != currentfont) {
									    currentfont = label.font;
									    graphics.font = currentfont;
									}
									graphics.moveto(label.point.x + tx, label.point.y + ty);
									graphics.show(label.text);
								    }
								}
							    }
							    if (cell.marks) {
								if (cellsize.height > minmarksize)
								    PaintCellMarks(cell, graphics);
							    }
							}
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}

	PaintChartGrid(Rectangle rect, Graphics graphics) {
	    double x;
	    double y;
	    double width;
	    double height;
	    Array  corners;
	    int    row;
	    int    column;

	    //
	    // The rect argument is the rectangle that needs painting, but it
	    // could cover part of a grid line without physically touching the
	    // line between the points that defines the grid line. Just using
	    // rect to pick the grid lines that need painting can omit part of
	    // a grid line (remember the lines aren't zero width).
	    //
	    // NOTE - we use maptopixel() when drawing the grid lines because
	    // it does a better job matching the placement of the chart cells,
	    // which are drawn with the Graphics rectangle builtins.
	    //

	    if (movingcellhome && movingcellhomecolor) {
		graphics.foreground = movingcellhomecolor;
		graphics.rectfill(movingcellhome);
	    }

	    if (showgrid) {
		//
		// Adjusting rect by the width and height of a cell is more than
		// we really need, but it's not a big deal. GRIDLINEWIDTH/2.0 is
		// probably what you would expect, although GRIDLINEWIDTH would
		// be safer. If you change the adjustment test different values
		// of GRIDLINEWIDTH values and pan very slowly near the outside
		// edges of the grid (or drag a cell around).
		//
		rect = new Rectangle {
		    double x = rect.x - cellsize.width;
		    double y = rect.y - cellsize.height;
		    double width = rect.width + 2*cellsize.width;
		    double height = rect.height + 2*cellsize.height;
		};
	        if ((corners = PickCellsInRect(rect)) != NULL) {
		    corners[2] += 1;
		    corners[3] += 1;
		    x = chartgrid.x;
		    y = chartgrid.y;
		    width = chartgrid.width;
		    height = chartgrid.height;
		    for (row = corners[0]; row <= corners[2]; row++) {
			y = chartgrid.y + row*rowheight;
			graphics.moveto(graphics.maptopixel(x, y));
			graphics.lineto(graphics.maptopixel(x + width, y));
		    }

		    y = chartgrid.y;
		    for (column = corners[1]; column <= corners[3]; column++) {
			x = chartgrid.x + column*columnwidth;
			graphics.moveto(graphics.maptopixel(x, y));
			graphics.lineto(graphics.maptopixel(x, y + height));
		    }
		    graphics.linecap = CAP_SQUARE;
		    graphics.linewidth = GRIDLINEWIDTH;
		    graphics.foreground = Color.gray;
		    graphics.stroke();
		    graphics.linecap = CAP_BUTT;
		}
	    }
	}

	PaintChartLabels(Rectangle rect, Graphics graphics) {
	    Dictionary dict;
	    Dictionary label;
	    Object     color;
	    Color      foreground = graphics.drawable.foreground;
	    Color      currentcolor = NULL;
	    Font       currentfont = NULL;

	    if (!paintChartLabels(rect, graphics)) {
		for (ptr in chartlabels) {
		    if ((dict = *ptr) != NULL) {
			if (rectIntersectsRect(rect, dict.bounds)) {
			    for (ptr in dict.labels) {
				if ((label = *ptr) != NULL) {
				    if (rectIntersectsRect(rect, label.bounds)) {
					if (label.font.pointsize >= label.minscaling*minpointsize) {
					    //
					    // Equality tests here assume label fields
					    // point to the same object.
					    //
					    color = label.foreground ? label.foreground : foreground;
					    if (color != currentcolor) {
						currentcolor = color;
						graphics.foreground = currentcolor;
					    }
					    if (label.font != currentfont) {
						currentfont = label.font;
						graphics.font = currentfont;
					    }
					    graphics.moveto(label.point);
					    graphics.show(label.text);
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}

	PaintChartLinks(Rectangle rect, Rectangle rect_clean, Graphics graphics) {
	    Path path;

	    //
	    // Right now we only handle the single temporary link that's
	    // supposed to be stored in links[0], so this obviously needs
	    // a bunch of work if we're going to support permanent links
	    // between cells.
	    //
	    // NOTE - there's really no reason to use the two rectangle if
	    // we're only handling one link, so we ignore them for now.
	    //

	    if (links) {
		if (links[0]) {
		    graphics.newpath();
		    GetLinkOutline(links[0], FALSE, graphics);
		    graphics.foreground = graphics.drawable.foreground;
		    graphics.linewidth = 100;		// kludge - for obscure Java fill() bug
		    graphics.fill();
		}
	    }
	}

	PaintChartMarks(Rectangle rect, Rectangle rect_clean, Graphics graphics) {
	    Rectangle bbox = NULL;
	    int       clipped = FALSE;

	    //
	    // If we're moving a cell we subtract it out of the current
	    // clipping path. There are subtle reasons for doing this
	    // that only show up when the cell is moved off-screen and
	    // then back on-screen at or near marks. The behavior that
	    // you will see, if you try, is completely correct but ugly.
	    //

	    if (marks) {
		if (movingcell != NULL) {
		    clipped = TRUE;
		    graphics.gsave();
		    graphics.rectclip(movingcell.bounds, TRUE, TRUE);
		}
		for (mark in marks) {
		    if (mark[0]@sizeof > 1) {
			bbox = (mark[0][0] == NULL && (mark[0][1] instanceof Rectangle)) ? mark[0][1] : NULL;
			if (rectIntersectsRect(rect, bbox) && (rect_clean == NULL || !rectContainsRect(rect_clean, bbox)))
			    PaintMarks(mark[0], graphics);
		    }
		}
		if (clipped)
		    graphics.grestore();
	    }
	}

	PaintFloatingLabel(Dictionary cell, Dictionary label, int erase, Rectangle bbox_new, Rectangle bbox_clean, Graphics graphics) {
	    Rectangle  linebounds;
	    Rectangle  intersection;
	    Object     bounds;
	    double     tx;
	    double     ty;
	    double     xmax;
	    Point      point;
	    int        showselected;

	    //
	    // NOTE - the two small kludges that adjust linebounds will eventually
	    // be addressed (hopefully where linebounds calculated).
	    // 

	    if (floatinglabels) {
		if (!paintFloatingLabel(cell, label, erase, bbox_new, bbox_clean, graphics)) {
		    showselected = cell.flags&CELL_SELECTED;
		    bounds = cell.bounds;
		    tx = bounds.x + cellinset;
		    ty = bounds.y + cellinset;
		    linebounds.x = label.linebounds.x + tx;
		    linebounds.y = label.linebounds.y + ty;
		    linebounds.width = label.linebounds.width;
		    linebounds.height = label.linebounds.height;

		    if (rectIntersectsRect(bbox_new, linebounds) && !rectContainsRect(bbox_clean, linebounds)) {
			xmax = bounds.x + bounds.width - cellinset - label.textbounds.width - (label.textbounds.x - label.point.x);
			point.x = label.point.x + tx;
			point.y = label.point.y + ty;
			if (cell != movingcell) {
			    if ((intersection = rectIntersectionRect(bbox_new, linebounds)) != NULL) {
				if (intersection.x > point.x) {
				    //
				    // Subtracting cellmargin is a small kludge
				    // that tries to compensate for textbounds
				    // widths that occasionally are a little too
				    // small (at some zoom scalings).
				    //
				    point.x = min(xmax - cellmargin, intersection.x);
				}
			    }
			}
			//
			// Currently erases the entire line, which isn't
			// right if several labels share the line. Means
			// floating label code only work when there's one 
			// one label per line. We eventually may address
			// this assumption.
			//
			// Adding +2 is a complete kludge - what's really
			// needed is one or two maptopixel() calls, but we
			// wanted to avoid the overhead.
			//
			if (erase) {
			    if (showselected && bounds.height <= minselectedsize)
				graphics.foreground = CellColors.LIGHTGRAY;
			    else graphics.foreground = cell.background;
			    graphics.rectfill(linebounds.x, linebounds.y, linebounds.width, linebounds.height+2);	// the +2 is a complete kludge
			}

			if (label.background) {
			    graphics.foreground = label.background;
			    graphics.rectfill(linebounds);
			}
			graphics.foreground = (showselected && label.selected && bounds.height > minselectedsize || label.selectable) ? cell.selectedforeground : label.foreground;
			graphics.font = label.font;
			graphics.moveto(point.x, point.y);
			graphics.show(label.text);
		    }
		}
	    }
	}

	PaintFloatingLabels(Rectangle bbox_new, Rectangle bbox_clean, Graphics graphics) {
	    Dictionary cell;
	    Dictionary label;
	    Dictionary lastcellpainted;
	    Array      corners;
	    Array      rowstatus;
	    int        rowcount;
	    int        paintedrows;
	    int        index;
	    int        row;
	    int        column;
	    int        firstrow;
	    int        lastrow;
	    int        firstcolumn;
	    int        lastcolumn;
	    int        layer;

	    //
	    // This currently is only used to help the afterPan() callback function
	    // clean up floating labels that were moved around on the screen using
	    // Java's copyArea(). Our current implementation of floating labels is
	    // very restricted right now (see PaintFloatingLabel() for the low level
	    // details) so we only have to worry about floating labels that intersect
	    // the left margin of their canvas.
	    //
	    // NOTE - we currently skip the gsave()/grestore() that you'll find in 
	    // PaintRect() because nobody we call changes the clipping path or CTM.
	    //

	    if (floatinglabels) {
		if (cellsize.height >= minlabelsize) {
		    //
		    // The rectContainsRect() test should really be all we need, but
		    // since our implementation is very restricted right now (we only
		    // handle labels that need to be aligned with the left margin) we
		    // can impose additional restrictions to reduce the work load. All
		    // the restrictions will have to be checked and perhaps removed as
		    // support for other labels and alignments are added.
		    //
		    if (!rectContainsRect(bbox_clean, chartbounds) && (bbox_new.x >= 0 || bbox_clean.x >= 0) && bbox_new.x != bbox_clean.x) {
			if ((bbox_clean = rectIntersectionRect(bbox_new, bbox_clean)) == NULL)
			    bbox_clean = bbox_new;
			if ((corners = PickCellsInRect(bbox_new)) != NULL) {
			    if (!paintFloatingLabels(corners, bbox_new, bbox_clean, &lastcellpainted, graphics)) {
				lastcellpainted = NULL;
				firstrow = corners[0];
				lastrow = corners[2];
				firstcolumn = corners[1];
				if (bbox_clean)
				    lastcolumn = max(firstcolumn, max(GetColumnAt(bbox_new.x), GetColumnAt(bbox_clean.x)));
				else lastcolumn = max(firstcolumn, GetColumnAt(bbox_new.x));
				lastcolumn = min(lastcolumn, columns - 1);
				paintedrows = 0;
				rowstatus = new Array[lastrow - firstrow + 1];
				for (ptr in rowstatus)
				    ptr[0] = FALSE;
				//
				// This is an upper limit that notices blank rows, so
				// it's better than lastrow - firstrow + 1, but it's
				// not guaranteed to be the least upper bound.
				// 
				for (row = firstrow, rowcount = 0; row <= lastrow; row++) {
				    if (rowends[row])
					rowcount++;
				}
				for (column = lastcolumn; column >= firstcolumn && paintedrows < rowcount; column--) {
				    for (row = firstrow; row <= lastrow && paintedrows < rowcount; row++) {
					if (!rowstatus[row - firstrow]) {
					    if ((index = row*columns + column) >= 0 && index < chartcells@sizeof) {
						for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(index, &layer, 1)); ) {
						    if (showunselectedlabels || (cell.flags&CELL_SELECTED)) {
							if (cell.flags&CELL_VISIBLE && rectIntersectsRect(bbox_new, cell.bounds) && !rectContainsRect(bbox_clean, cell.bounds)) {
							    for (ptr in cell.labels) {
								if (ptr@offset < cell.nextlabel) {
								    if (label = *ptr) {
									if (label.floater) {
									    if (!label.selectable || cell.selectable) {
										if (label.font.pointsize >= minpointsize) {
										    PaintFloatingLabel(cell, label, TRUE, bbox_new, bbox_clean, graphics);
										    lastcellpainted = cell;
										}
									    }
									}
								    }
								} else break;
							    }
							    if (!rowstatus[row - firstrow]) {
								rowstatus[row - firstrow] = TRUE;
								paintedrows++;
							    }
							    if (cell.marks && lastcellpainted == cell) {
								if (cellsize.height > minmarksize)
								    PaintCellMarks(cell, graphics);
							    }
							}
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		    if (PaintMovedCells(bbox_new, bbox_clean, graphics) || lastcellpainted != NULL) {
			PaintChartLinks(bbox_new, bbox_clean, graphics);
			PaintChartMarks(bbox_new, bbox_clean, graphics);
		    }
		}
	    }
	}

	PaintMarks(Array marks, Graphics graphics) {
	    int havepath = FALSE;

	    //
	    // Usually processes x and y coordinates, but if we find NULL where we
	    // expected the x coordinate we parse the next entry in marks which can
	    // be used to force a stroke or fill or set the drawing color or line
	    // width. In that case the current subpath, if there is one, is ended.
	    // Although we don't use it here, boundingbox info if often stored in
	    // marks[1], but it in that case marks[0] will always be NULL so this
	    // code won't misbehave.
	    //

	    graphics.foreground = graphics.drawable.foreground;
	    graphics.linewidth = LINEWIDTH;
	    graphics.linecap = CAP_BUTT;
	    graphics.linejoin = JOIN_ROUND;

	    for (ptr in marks by 2) {
		if (ptr@sizeof > 1) {
		    if (ptr[0] != NULL) {
			if (!havepath) {
			    graphics.moveto(ptr[0], ptr[1]);
			    havepath = TRUE;
			} else graphics.lineto(ptr[0], ptr[1]);
		    } else {
			if (ptr[1] instanceof String) {
			    if (ptr[1] === "stroke") {
				if (havepath)
				    graphics.stroke();
			    } else if (ptr[1] === "fill") {
				if (havepath)
				    graphics.fill();
			    }
			} else if (ptr[1] instanceof Color) {
			    if (havepath)
				graphics.stroke();
			    graphics.foreground = ptr[1];
			} else if (ptr[1] instanceof Number) {
			    if (havepath)
				graphics.stroke();
			    graphics.linewidth = ptr[1];
			}
			havepath = FALSE;
		    }
		}
	    }
	    if (havepath)
		graphics.stroke();
	}

	PaintMovedCells(Rectangle rect, Rectangle rect_clean, Graphics graphics) {
	    Dictionary cell;
	    int        painted = FALSE;

	    if (movedcells.next != movedcells) {
		synchronized(movedcells) {
		    for (cell = movedcells.next; cell != movedcells; cell = cell.next) {
			if (rectIntersectsRect(rect, cell.bounds) && (rect_clean == NULL || !rectContainsRect(rect_clean, cell.bounds))) {
			    PaintCell(cell, graphics, FALSE);
			    painted = TRUE;
			}
		    }
		}
	    }
	    return(painted);
	}

	PaintRect(Rectangle rect, int clear, Graphics graphics) {
	    //
	    // This function uses its rect argument to update the clipping
	    // path (a NULL rect means the entire drawable) and if rect was
	    // NULL it's reset from the modified clipping path. Individual
	    // paint functions that we call to render the chart can use the
	    // rectangle argument that we provide to reduce their work load.
	    //

	    if (chartcells != NULL) {
		graphics.gsave();
		graphics.rectclip(rect);
		if (rect == NULL) {
		    graphics.clippath();
		    rect = graphics.pathbbox(0, 1);	// pathbbox arguments are a small kludge!!!
		    graphics.newpath();
		}
		if (clear)
		    graphics.erasedrawable();
		PaintChartGrid(rect, graphics);
		PaintChartLabels(rect, graphics);
		PaintChartCells(rect, graphics);
		PaintMovedCells(rect, NULL, graphics);
		PaintChartLinks(rect, NULL, graphics);
		PaintChartMarks(rect, NULL, graphics);
		graphics.grestore();
	    }
	}

	StartMovingCell(Dictionary cell, Color color, Graphics graphics) {
	    //
	    // Decided to let the caller select the color so highlighting
	    // can be turned off by passing us a NULL color.
	    //

	    RemoveCell(cell);		// make sure it's not in the chart
	    RaiseCell(cell);
	    ClearBadCellMark(cell);
	    movingcell = cell;
	    movingcellhome = GetHomeBoundsForCell(cell);
	    if ((movingcellhomecolor = color) != NULL)
		PaintRect(movingcellhome, TRUE, graphics);
	}

	StopMovingCell(Graphics graphics) {
	    if (movingcellhomecolor != NULL) {
		movingcellhomecolor = graphics.drawable.background;
		PaintRect(movingcellhome, TRUE, graphics);
	    }
	    movingcellhomecolor = NULL;
	    movingcellhome = NULL;
	    movingcell = NULL;
	}

	SyncMinimumSizes(Graphics graphics) {
	    Dimension bounds = graphics.idtransform(1.0, 1.0);

	    //
	    // Rather arbitrary way of picking cutoff points that lets our
	    // cell painting code decide when to change how the parts of a
	    // cell, like labels, are displayed. Unfortunately decisions
	    // based on minselectedsize really also should consult label
	    // point sizes, but we decided against it in the interest of
	    // painting speed. Bottom line is that minselectedsize and
	    // minpointsize could be set to values that would skip any
	    // highlighting of the selected cell.
	    //

	    if (chartcells@sizeof > 2500)	// completely arbitrary!!
		bounds.height *= 1.2;

	    minpointsize = 2.5*bounds.height;
	    minbordersize = 0.25*bounds.height;
	    minlabelsize = 3*minpointsize;
	    minselectedsize = 2.0*minlabelsize;
	    minmarksize = 0;			// so bad cell marks are painted
	}

	////////////////////////////
	//
	// Hit Detection Functions
	//
	////////////////////////////

	AdjustCorners(Array corners) {
	    Object data;
	    int    index;
	    int    column;
	    int    row;
	    int    last;

	    if (multicelldata != NULL) {
		if (corners != NULL) {
		    row = corners[0];
		    column = corners[1];
		    index = row*columns + column;
		    last = ((int)corners[2])*columns + column;		// the cast is required!!!
		    for (; index <= last; index += columns) {
			if ((data = multicelldata[index]) != NULL) {
			    if (corners[1] > data[1])
				corners[1] = data[1];
			}
		    }
		    index = row*columns + column;
		    last = row*columns + corners[3];
		    for (; index <= last; index++) {
			if ((data = multicelldata[index]) != NULL) {
			    if (corners[0] > data[0])
				corners[0] = data[0];
			}
		    }
		}
	    }
	    return(corners);
	}

	GetCellTextAt(Dictionary cell, int tiptext, Point point) {
	    Dictionary label;
	    String     text;

	    if (cell && point) {
		point = new Point {
		    double x = point.x - (cell.bounds.x + cellinset);
		    double y = point.y - (cell.bounds.y + cellinset);
		};
		for (ptr in cell.labels) {
		    if (defined(ptr)) {
			if ((label = *ptr) != NULL) {
			    if (pointInRect(point, label.textbounds)) {
				if (tiptext) {
				    if (label.GetTipText)
					text = label.GetTipText(cell);
				} else text = label.text;
				break;
			    }
			}
		    }
		}
	    }
	    return(text);
	}

	GetColumnAt(double x) = (x - chartgrid.x)/columnwidth;

	GetGridPoint(Point point) {
	    Point corner;

	    corner.x = chartbounds.x + floor(GetColumnAt(point.x))*columnwidth;
	    corner.y = chartbounds.y + floor(GetRowAt(point.y))*rowheight;
	    return(corner);
	}

	GetHomeBoundsForCell(Dictionary cell) {
	    Rectangle rect = NULL;

	    if (cell != NULL) {
		rect = new Rectangle {
		    double x = cell.home.x;
		    double y = cell.home.y;
		    double width = cell.bounds.width;
		    double height = cell.bounds.height;
		};
	    }
	    return(rect);
	}

	GetIndexAt(Point point) = floor(GetRowAt(point.y))*columns + floor(GetColumnAt(point.x));
	GetOldColumnAt(double x) = chartgrid_old ? (x - chartgrid_old.x)/columnwidth_old : 0;
	GetOldRowAt(double y) = chartgrid_old ? (y - chartgrid_old.y)/rowheight_old : 0;

	GetRectangleCovering(double row1, double column1, double row2, double column2) {
	    Rectangle rect;

	    //
	    // Returns a rectangle that covers all cells from (row1, column1) to
	    // (row1, column2).
	    //

	    if (column1 <= column2) {
		rect.x = chartbounds.x + column1*columnwidth;
		rect.width = (column2 - column1 + 1)*columnwidth;
	    } else {
		rect.x = chartbounds.x + column2*columnwidth;
		rect.width = (column1 - column2 + 1)*columnwidth;
	    }
	    if (row1 <= row2) {
		rect.y = chartbounds.y + row1*rowheight;
		rect.height = (row2 - row1 + 1)*rowheight;
	    } else {
		rect.y = chartbounds.y + row2*rowheight;
		rect.height = (row1 - row2 + 1)*rowheight;
	    }
	    return(rect);
	}

	GetRowAt(double y) = (y - chartgrid.y)/rowheight;
	GetXForChartColumn(int column) = chartbounds.y + column*rowheight;
	GetYForChartRow(int row) = chartbounds.x + row*columnwidth;

	IsGridEmptyAt(Point point) {
	    Dictionary cell;
	    Point      corner;
	    int        index;
	    int        result = TRUE;
	    int        layer;

	    //
	    // returns TRUE if it looks like another cell, legitmate or not,
	    // is occupying the chart cell that includes point.
	    //

	    synchronized(movedcells) {
		index = GetIndexAt(point);
		if (index < 0 || index >= chartcells@sizeof || GetNextChartCell(index, &layer, 1) == NULL) {
		    corner = GetGridPoint(point);
		    for (cell = movedcells.next; cell != movedcells; cell = cell.next) {
			if (cell.bounds.x == corner.x && cell.bounds.y == corner.y) {
			    result = FALSE;
			    break;
			}
		    }
		} else result = FALSE;
	    }
	    return(result);
	}

	PickCellAt(Point point) {
	    Dictionary cell;

	    //
	    // Looks through moved cells first, since they're always above the
	    // chart.
	    //

	    if ((cell = PickMovedCellAt(point)) == NULL)
		cell = PickChartCellAt(point);
	    return(cell);
	}

	PickCellsAtPoint(Point point) {
	    Array corners;

	    if (point != NULL) {
		corners = new Array {
		    max(0, min(GetRowAt(point.y), rows-1)),
		    max(0, min(GetColumnAt(point.x), columns-1)),
		    max(0, min(GetRowAt(point.y), rows-1)),
		    max(0, min(GetColumnAt(point.x), columns-1)),
		};
	    }
	    return(AdjustCorners(corners));
	}

	PickCellsInRect(Rectangle rect) {
	    Array corners;

	    //
	    // Returns an array that contains the row and column of the cells
	    // closest to the upper left and lower right corners of rect. We
	    // currently return them as doubles, but ints should be OK - later.
	    //

	    if (rect != NULL) {
		corners = new Array {
		    max(0, min(GetRowAt(rect.y), rows-1)),
		    max(0, min(GetColumnAt(rect.x), columns-1)),
		    max(0, min(GetRowAt(rect.y + rect.height), rows-1)),
		    max(0, min(GetColumnAt(rect.x + rect.width), columns-1)),
		};
	    }
	    return(AdjustCorners(corners));
	}

	PickChartCellAt(Point point) {
	    Dictionary cell;
	    Array      corners;
	    Array      ends;
	    int        index;
	    int        last;
	    int        row;
	    int        layer;

	    //
	    // Works harder than is normally necessary just to make sure we can
	    // handle charts with overlapping cells. In those charts we sometimes
	    // get an array back from PickCellsAtPoint() that includes more than
	    // one cell.
	    //
	    // NOTE - we walk backwards through the possible cells because cells
	    // that have a larger chartcells index are painted last. Cells that
	    // map to the same index in chartcells, if any, are also traversed
	    // backwards (that's what the -1 is for in the GetChartCell() call)
	    // for the same reason.
	    //
	    // NOTE - if a general approach turns out to be an issue, which we
	    // don't expect, then we could always adjust the algorithm based on
	    // the data stored in the chart.
	    //

	    if (chartcells != NULL) {
		if ((corners = PickCellsAtPoint(point)) != NULL) {
		    for (row = corners[2]; row >= (int)corners[0]; row--) {
			if (ends = rowends[row]) {
			    index = row*columns + min(corners[3], ends[1]);
			    last = row*columns + max(corners[1], ends[0]);
			    for (; index >= last; index--) {
				for (layer = 0; cell = GetNextChartCell(index, &layer, -1); ) {
				    if (cell.flags&CELL_VISIBLE) {
					if (pointInRect(point, cell.bounds))
					    return(cell);
				    }
				}
			    }
			}
		    }
		}
	    }
	    return(NULL);
	}

	PickMovableCellAt(Point point) {
	    return(cellslabeled ? PickCellAt(point) : NULL);
	}

	PickMovedCellAt(Point point) {
	    Dictionary cell;

	    if (point != NULL) {
		if (movedcells.next != movedcells) {
		    synchronized(movedcells) {
			for (cell = movedcells.prev; cell != movedcells; cell = cell.prev) {
			    if (cell.flags&CELL_VISIBLE) {
				if (pointInRect(point, cell.bounds))
				    break;
			    }
			}
		    }
		}
	    }
	    return(cell != movedcells ? cell : NULL);
	}

	PointInMark(Point point, Array mark, Matrix matrix, double linewidth) {
	    Path path;
	    int  havepath = FALSE;
	    int  hit;

	    path.CTM.setmatrix(matrix);
	    path.linewidth = linewidth;
	    for (ptr in mark by 2) {
		if (ptr@sizeof > 1) {
		    if (ptr[0] != NULL) {
			if (!havepath) {
			    path.moveto(ptr[0], ptr[1]);
			    havepath = TRUE;
			} else path.lineto(ptr[0], ptr[1]);
		    } else {
			if (ptr[1] instanceof String) {
			    if (ptr[1] === "stroke") {
				if (havepath && path.instroke(point)) {
				    hit = TRUE;
				    break;
				}
			    } else if (ptr[1] === "fill") {
				if (havepath && path.infill(point)) {
				    hit = TRUE;
				    break;
				}
			    }
			}
			path.newpath();
			havepath = FALSE;
		    }
		}
	    }
	    if (havepath && !hit)
		hit = path.instroke(point);
	    return(hit);
	}

	////////////////////////////
	//
	// Link Functions
	//
	////////////////////////////

	AddTemporaryLink(Dictionary tail, Dictionary head, int arrowhead, Graphics graphics) {
	    if (tail && head) {
		if (links) {
		    if (links[0])		// just in case
			RemoveTemporaryLink(graphics);
		    links[0] = new Array {tail, head, arrowhead};
		} else links = new Array[1, ...] {new Array {tail, head, arrowhead}};
		graphics.gsave();
		graphics.newpath();
		GetLinkOutline(links[0], TRUE, graphics);
		graphics.clip();
		Paint(graphics, FALSE);
		graphics.grestore();
	    }
	}

	GetArrowHead(Point tail, Point head, double radius, double extra) {
	    double ds;
	    double dx;
	    double dy;
	    double sin;
	    double cos;
	    double x;
	    double y;
	    Array  coords;

	    if (tail && head) {
		dx = head.x - tail.x;
		dy = head.y - tail.y;
		if ((ds = sqrt(dx*dx + dy*dy)) > 0) {
		    sin = dy/ds;
		    cos = dx/ds;
		    x = head.x;
		    y = head.y;
		    if (extra > 0) {
			radius += 2*extra/ARROWEDGE_COS;
			x += extra*cos;
			y += extra*sin;
		    }
		    coords = new Array {
			x,
			y,
			x - radius*(cos*ARROWEDGE_COS - sin*ARROWEDGE_SIN),
			y - radius*(cos*ARROWEDGE_SIN + sin*ARROWEDGE_COS),
			x - radius*(cos*ARROWEDGE_COS + sin*ARROWEDGE_SIN),
			y - radius*(sin*ARROWEDGE_COS - cos*ARROWEDGE_SIN),
		    };
		}
	    }
	    return(coords);
	}

	GetLinkOutline(Array link, int clipping, Graphics graphics) {
	    Dimension delta;
	    double    extra;
	    double    radius;
	    Point     head;
	    Point     tail;
	    Array     arrow;

	    //
	    // Adds the outline of link to the current path in graphics. When
	    // clipping is TRUE the path is "expanded" a bit so it can be used
	    // as a clipping path for painting operations. The result isn't an
	    // exact match but all pixels normally painted by the link should
	    // end up inside the path. A bit of a kludge and we probably need
	    // to investigate some of our low level Java code to see if we're
	    // responsible. Meanwhile this approach should be sufficient.
	    //
	    // NOTE - much of what's done here is currently duplicated in the
	    // GetLinkOutlines() function that's defined below. There's really
	    // no good excuse and we eventually will clean it up, but for now
	    // changes to one probably should be duplicated in the other.
	    //
	    // NOTE - we use PickCellAnchor() to pick the points in the cells
	    // that we're supposed to connect. It's probably right except when
	    // cellanchor is NONE and this is used by the arrowselector panning
	    // code. Not sure there's a good answer because NONE means the point
	    // is determined by the "selectors" rather than the cell.
	    //

	    if (link != NULL) {
		if (clipping) {
		    delta = graphics.CTM.idtransform(3.0, 0.0);		// trial and error value
		    extra = sqrt(delta.width*delta.width + delta.height*delta.height);
		    graphics.linecap = CAP_SQUARE;
		} else {
		    extra = 0;
		    graphics.linecap = CAP_BUTT;
		}
		graphics.linewidth = LINEWIDTH + extra;
		tail = PickCellAnchor(link[0]);
		head = PickCellAnchor(link[1]);
		radius = (1.5*LINEWIDTH + 1)/ARROWEDGE_SIN;	// seems like a reasonable guess
		arrow = link[2] ? GetArrowHead(tail, head, radius, extra) : NULL;
		graphics.moveto(graphics.maptopixel(tail.x, tail.y));
		if (arrow) {
		    graphics.lineto(graphics.maptopixel(
			(arrow[0] + arrow[2] + arrow[4])/3.0,
			(arrow[1] + arrow[3] + arrow[5])/3.0
		    ));
		} else graphics.lineto(graphics.maptopixel(head.x, head.y));
		graphics.strokepath();
		if (arrow) {
		    graphics.moveto(graphics.maptopixel(arrow[0], arrow[1]));
		    graphics.lineto(graphics.maptopixel(arrow[2], arrow[3]));
		    graphics.lineto(graphics.maptopixel(arrow[4], arrow[5]));
		    graphics.closepath();
		}
	    }
	}

	GetLinkOutlines(Rectangle rect, int clipping, Graphics graphics) {
	    Dimension delta;
	    double    extra;
	    double    radius;
	    Point     head;
	    Point     tail;
	    Array     arrow;
	    Array     arrows[0, ...];

	    //
	    // NOTE - much of what's done here is currently duplicated in the
	    // GetLinkOutline() function that's defined above. There's really
	    // no good excuse and we eventually will clean it up, but for now
	    // changes to one probably should be duplicated in the other.
	    //

	    if (links != NULL) {
		if (clipping) {
		    delta = graphics.CTM.idtransform(4.0, 0.0);		// trial an error value
		    extra = sqrt(delta.width*delta.width + delta.height*delta.height);
		} else extra = 0;
		graphics.linewidth = LINEWIDTH + extra;
		radius = (1.5*LINEWIDTH + 1)/ARROWEDGE_SIN;	// seems like a reasonable guess
		for (link in links) {
		    if (link[0]) {
			tail = PickCellAnchor(link[0][0]);
			head = PickCellAnchor(link[0][1]);
			if (rect == NULL || rectIntersectsRect(rect, rectUnionRect(tail, head))) {
			    arrow = link[0][2] ? GetArrowHead(tail, head, radius, extra) : NULL;
			    graphics.moveto(graphics.maptopixel(tail.x, tail.y));
			    if (arrow) {
				arrows[arrows@sizeof] = arrow;
				graphics.lineto(graphics.maptopixel(
				    (arrow[0] + arrow[2] + arrow[4])/3.0,
				    (arrow[1] + arrow[3] + arrow[5])/3.0
				));
			    } else graphics.lineto(graphics.maptopixel(head.x, head.y));
			}
		    }
		}
		graphics.strokepath();
		for (ptr in arrows) {
		    arrow = ptr[0];
		    graphics.moveto(graphics.maptopixel(arrow[0], arrow[1]));
		    graphics.lineto(graphics.maptopixel(arrow[2], arrow[3]));
		    graphics.lineto(graphics.maptopixel(arrow[4], arrow[5]));
		    graphics.closepath();
		}
	    }
	}

	PickCellAnchor(Dictionary cell) {
	    Rectangle bounds = cell.bounds;
	    Point     point;

	    //
	    // NOTE - this doesn't handle NONE!!!
	    //

	    switch (cellanchor) {
		case TOPLEFT:
		    point.x = bounds.x;
		    point.y = bounds.y;
		    break;

		case TOP:
		    point.x = bounds.x + bounds.width/2.0;
		    point.y = bounds.y;
		    break;

		case TOPRIGHT:
		    point.x = bounds.x + bounds.width;
		    point.y = bounds.y;
		    break;

		case LEFT:
		    point.x = bounds.x;
		    point.y = bounds.y + bounds.height/2.0;
		    break;

		case CENTER:
		default:
		    point.x = bounds.x + bounds.width/2.0;
		    point.y = bounds.y + bounds.height/2.0;
		    break;

		case RIGHT:
		    point.x = bounds.x + bounds.width;
		    point.y = bounds.y + bounds.height/2.0;
		    break;

		case BOTTOMLEFT:
		    point.x = bounds.x;
		    point.y = bounds.y + bounds.height;
		    break;

		case BOTTOM:
		    point.x = bounds.x + bounds.width/2.0;
		    point.y = bounds.y + bounds.height;
		    break;

		case BOTTOMRIGHT:
		    point.x = bounds.x + bounds.width;
		    point.y = bounds.y + bounds.height;
		    break;
	    }
	    return(point);
	}

	RemoveTemporaryLink(Graphics graphics) {
	    Array link;

	    if (links) {
		if ((link = links[0]) != NULL) {
		    links[0] = NULL;
		    graphics.gsave();
		    graphics.newpath();
		    GetLinkOutline(link, TRUE, graphics);
		    graphics.clip();
		    Paint(graphics, TRUE);
		    graphics.grestore();
		}
	    }
	}

	////////////////////////////
	//
	// Mark Functions
	//
	////////////////////////////

	AddBadCellMark(Dictionary cell) {
	    if (badcell_mark)
		AddMark(cell, badcell_mark, NULL);
	}

	AddMark(Object target, Array mark, Rectangle bbox) {
	    Pointer slot;

	    //
	    // Now tries to make sure we don't add the same mark to target
	    // more than once.
	    //

	    if (defined("marks", target)) {
		if (bbox != NULL && mark != badcell_mark)
		    mark = new Array {NULL, bbox, unroll(mark)};
		if (target.marks) {
		    for (ptr in target.marks) {
			if (ptr[0] == mark) {
			    slot = ptr;
			    break;
			} else if (slot == NULL && ptr[0] == NULL)
			    slot = ptr;
		    }
		    if (slot == NULL)
			target.marks[target.marks@sizeof] = mark;
		    else *slot = mark;
		} else target.marks = new Array[1, ...] {mark};
	    }
	}

	ClearBadCellMark(Dictionary cell) {
	    if (badcell_mark)
		ClearMark(cell, badcell_mark);
	}

	ClearBadCellMarks() {
	    Dictionary cell;
	    int        layer;

	    //
	    // We have to look at all cells because the bad cell marks aren't
	    // necessarily cleared when a cell is moved back into the chart.
	    // This is intentional and not a mistake because it lets the user
	    // solve the puzzle but still see the mistakes that were made.
	    //

	    for (ptr in allcells)
		ClearBadCellMark(ptr[0]);
	}

	ClearMark(Object target, Array mark) {
	    if (defined("marks", target)) {
		for (ptr in target.marks) {
		    if (ptr[0] == mark) {
			ptr[0] = NULL;
			break;
		    }
		}
	    }
	}

	EraseCellMarks() = EraseChartCellMarks() | EraseMovedCellMarks();

	EraseCellMarksNear(Rectangle rect, Matrix matrix) {
	    Dictionary cell;
	    Point      center;
	    int        cleared;

	    center.x = rect.x + rect.width/2;
	    center.y = rect.y + rect.width/2;

	    if ((cell = PickCellAt(center)) != NULL) {
		if (cell.marks) {
		     cleared = TRUE;
		     cell.marks = NULL;
		}
	    }
	    return(cleared);
	}

	EraseChartCellMarks() {
	    Dictionary cell;
	    int        cleared;
	    int        layer;

	    for (ptr in chartcells) {
		for (layer = 0; layer <= lastcelllayer && (cell = GetNextChartCell(ptr@offset, &layer, 1)); ) {
		    if (cell.marks) {
			cleared = TRUE;
			cell.marks = NULL;
		    }
		}
	    }
	    return(cleared);
	}

	EraseChartMarks() {
	    int cleared;

	    if (marks) {
		cleared = TRUE;
		marks = NULL;
	    }
	    return(cleared);
	}

	EraseChartMarksNear(Rectangle rect, Matrix matrix) {
	    Point center;
	    int   cleared;

	    center.x = rect.x + rect.width/2;
	    center.y = rect.y + rect.height/2;

	    for (mark in marks) {
		if (mark[0]@sizeof > 1) {
		    if (rectIntersectsRect(rect, mark[0][1])) {
			if (PointInMark(center, mark[0], matrix, rect.width)) {
			    cleared = TRUE;
			    mark[0] = NULL;
			}
		    }
		}
	    }
	    return(cleared);
	}

	EraseMarksNear(Point point, Matrix matrix, double linewidth) {
	    Rectangle rect;
	    int       cleared;

	    linewidth = max(linewidth, 3);
	    rect.x = point.x - linewidth/2;
	    rect.y = point.y - linewidth/2;
	    rect.width = linewidth;
	    rect.height = linewidth;

	    return(EraseChartMarksNear(rect, matrix) | EraseCellMarksNear(rect, matrix));
	}

	EraseMovedCellMarks() {
	    Dictionary cell;
	    int        cleared;

	    if (movedcells.next != movedcells) {
		synchronized(movedcells) {
		    for (cell = movedcells.next; cell != movedcells; cell = cell.next) {
			if (cell.marks) {
			    cleared = TRUE;
			    cell.marks = NULL;
			}
		    }
		}
	    }
	    return(cleared);
	}

	////////////////////////////
	//
	// Miscellaneous Functions
	//
	////////////////////////////

	ClearCachedCharts() {
	    if (clearcache != NULL) {
		if (*clearcache instanceof Callable)
		    (*clearcache)();
	    }
	}

	ClearSelected() {
	    for (ptr in allcells)
		ptr[0].flags &= ~CELL_SELECTED;
	}

	CopyCellToClipboard(Dictionary cell) {
	    CopyToSystemClipboard(GetCellContents(cell));
	}

	GetCellContents(Dictionary cell) {
	    String contents;
	    String text;
	    Array  labels;

	    if (cell != NULL) {
		for (ptr in cell.labels) {
		    if (defined(ptr) && *ptr != NULL) {
			text = trim((*ptr).text);
			if (text@sizeof > 0)
			    contents += text + "\n";
		    }
		}
	    }
	    return(contents);
	}

	GetCellInteriorBounds(Dictionary cell) {
	    return(
		new Rectangle {
		    double x = cell.bounds.x + cellinset;
		    double y = cell.bounds.y + cellinset;
		    double width = cell.bounds.width - 2*cellinset;
		    double height = cell.bounds.height - 2*cellinset;
		}
	    );
	}

	GetNextChartCell(int index, Pointer lptr, int incr) {
	    Dictionary cell;
	    Object     element;
	    int        layer;

	    //
	    // Returns the cell stored at chartcells[index] that's at or above the
	    // layer *lptr or NULL if there is no cell. The number stored a *lptr
	    // is updated to reflect where the next call, if there is one, should
	    // start. This is a general function that works for all charts, but it
	    // introduces overhead that starts to show up in moderate size charts
	    // (i.e., more than 1000 cells) and in most cases PaintChartCells() is
	    // where you pay the biggest price. As a result you'll probably find
	    // two versions of PaintChartCells() and the one that's actually used
	    // is selected at runtime based on the value assigned to lastcelllayer.
	    // The fast version, among other things, doesn't call this function but
	    // instead just does
	    //
	    //     cell = chartcells[index];
	    //
	    // to get the cell stored at index.
	    //
	    // NOTE - the GetNextChartCell_Simple() function that's defined below
	    // automatically replaces this function when simplecellmodel is TRUE.
	    //

	    if ((layer = *lptr) <= lastcelllayer) {
		if (lastcelllayer) {
		    if ((element = chartcells[index]) instanceof Dictionary) {
			if (layer == 0) {
			    cell = element;
			    *lptr = 1;
			}
		    } else if (element instanceof Array) {
			if (incr >= 0) {
			    for (; layer < element@sizeof; layer++) {
				if (element[layer] instanceof Dictionary) {
				    cell = element[layer++];
				    break;
				}
			    }
			    *lptr = layer;
			} else {
			    for (layer = element@sizeof - 1 - layer; layer >= 0; layer--) {
				if (element[layer] instanceof Dictionary) {
				    cell = element[layer--];
				    break;
				}
			    }
			    *lptr = element@sizeof - 1 - layer;
			}
		    }
		} else {
		    *lptr = 1;
		    cell = chartcells[index];
		}
	    }
	    return(cell);
	}

	GetNextChartCell_Simple(int index, Pointer lptr, int incr) = *lptr ? NULL : (*lptr = 1, chartcells[index]);

	GetNextSelectableCellNamed(String name, int direction) {
	    Dictionary cell;
	    Array      cells;
	    int        count;
	    int        incr;
	    int        n;

	    if (name) {
		if (defined(name, namemap)) {
		    if (namemap[name] instanceof Array) {
			if ((cells = namemap[name]) != NULL) {
			    for (ptr in cells) {
				if (ptr[0].selectable) {
				    incr = (direction > 0) ? 1 : -1;
				    count = cells@sizeof;
				    for (n = ptr@offset + incr; count > 0; n += incr, count--) {
					if (n >= cells@sizeof)
					    n = 0;
					else if (n < 0)
					    n = cells@sizeof - 1;
					if (cells[n].flags&CELL_VISIBLE) {
					    cell = cells[n];
					    ptr[0].selectable = FALSE;
					    cell.selectable = TRUE;
					    break;
					}
				    }
				    break;
				}
			    }
			}
		    } else cell = namemap[name];
		}
	    }
	    return((cell && cell.flags&CELL_VISIBLE) ? cell : NULL);
	}

	GetSelectableCellNamed(String name) {
	    Dictionary cell;
	    Array      cells;

	    if (name) {
		if (defined(name, namemap)) {
		    if (namemap[name] instanceof Array) {
			if ((cells = namemap[name]) != NULL) {
			    for (ptr in cells) {
				if (ptr[0].selectable) {
				    cell = ptr[0];
				    break;
				}
			    }
			}
		    } else cell = namemap[name];
		}
	    }
	    return((cell && cell.flags&CELL_VISIBLE) ? cell : NULL);
	}

	IsCellMoved(Dictionary cell) = (cell.next != NULL);
	IsCellSelectable(Dictionary cell) = cell.selectable;
	IsCellSelected(Dictionary cell) = (cell.flags&CELL_SELECTED) ? TRUE : FALSE;
	IsCellVisible(Dictionary cell) = (cell.flags&CELL_VISIBLE) ? TRUE : FALSE;
	IsPuzzle() = puzzle;

	MakeCellSelectable(Dictionary cell) {
	    Dictionary lastselectable;
	    Array      cells;

	    //
	    // Makes sure cell is the only one in the cell.name list that has
	    // it's selectable field set to TRUE. The selectable field in a
	    // cell is an obscure field that right now is only supposed to
	    // come into play when cell names aren't unique. The return value,
	    // if it's not NULL, is the last cell that was selectable. We're
	    // making some obvious assumptions, like at most one cell has its
	    // selectable field set to TRUE, that we evetually may revisit.
	    //

	    if (cell) {
		if (defined(cell.name, namemap)) {
		    if (namemap[cell.name] instanceof Array) {
			if ((cells = namemap[cell.name]) != NULL) {
			    for (ptr in cells) {
				if (ptr[0] != cell && ptr[0].selectable) {
				    ptr[0].selectable = FALSE;
				    lastselectable = ptr[0];
				    break;
				}
			    }
			}
		    }
		    cell.selectable = TRUE;
		}
	    }
	    return(lastselectable);
	}

	StopThreads() {
	    labelthread.alive = FALSE;
	}

	SyncSelectedCell(Dictionary cell, int state) {
	    if ((cell.flags&CELL_SELECTED) ^^ state) {
		if (state)
		    cell.flags |= CELL_SELECTED;
		else cell.flags &= ~CELL_SELECTED;
		RaiseCell(cell);
	    }
	}
    };

    //
    // You've seen unroll() before (remember the Die() function), but now we
    // use it to copy the chartdata argument into our chart dictionary, which
    // means definitions in chartdata replace existing definitions in chart or
    // are added as new definitions (because it's growable). So building a new
    // chart means adding special functions to a dictionary that's passed to
    // ConstructChart() as the first argument.
    //
    // After that we call chart.Initialize(), which ends up in functions, like
    // LoadChart(), that unroll() copied into chart. When Initialize() returns
    // the chart is built and ready to use, so we return it to the caller.
    //
    // NOTE - remember you can use fprintf() to help you understand code that
    // might be confusing. For example,
    //
    //     fprintf(stderr, "chart=%O\n", chart);
    //
    // dumps the contents of chart, so adding it before and after the unroll()
    // call let's you see how chartdata modified the chart dictionary. Add it
    // after the Initialize() call and you should notice that many variables
    // were defined. If you're interested in a one variable, say namemap, just
    // add
    //
    //     fprintf(stderr, "namemap=%O\n", chart.namemap);
    //
    // after the Initialize() call.
    //

    unroll(chartdata, chart);
    chart.Initialize();
    return(chart);
}

////////////////////////////
//
// Browser Section
//
////////////////////////////

//
// Browser support that was borrowed from YWAIT and extensively modified for
// use in this script.
//

GetBrowserCommand() {
    Process proc;
    String  viewer;
    Array   viewers;

    //
    // As rather complicated function that does a pretty good job picking
    // the command for most operating systems. Picking the browser on Unix
    // turns out to be the hardest.
    //

    if (BROWSER_COMMAND == NULL && SET_BROWSER_COMMAND) {
        viewer = NULL;
	if (ISMAC) {
	    if (checkExec("/usr/bin/open"))
		viewer = "/usr/bin/open %s";
	} else if (ISWIN) {
	    viewer = findPaths(
		new Array {"cmd.exe", "command.com"},
		"c:\\windows\\system32;c:\\winnt\\system32",
		-1
	    );
	    if (viewer && checkExec(viewer))
		viewer += " /c start \"\" \"%s\"";
	} else {                                        // ISUNIX
	    if (checkReadEnvironment("PATH")) {
		viewers = findPaths(
		    new Array {
                        "sensible-browser",
                        "chromium-browser",
                        "firefox",
                    },
		    getenv("PATH"),
		    0
		);
	    }
	    if (viewers == NULL) {
		viewers = new Array {
		    "/usr/bin/sensible-browser",
		    "/usr/bin/chromium-browser",
		    "/usr/bin/firefox",
		};
	    }

	    for (ptr in viewers) {
		if (checkExec(*ptr)) {
		    try {
			if ((proc = exec(*ptr + " --version")) != NULL)
			    waitFor(proc);
		    }
		    catch(e) {
			proc = NULL;
		    }
		    //
		    // Looks like the interpreter currently won't let us
		    // break from inside a try/catch. We will investigate,
		    // but not right now. Anyway, we reorganized the code
		    // a bit and this now works.
		    //

		    if (proc && proc.exitvalue == 0) {
			viewer = *ptr + " %s";
			break;
		    }
		}
	    }
	}
	if (viewer != NULL && viewer@length > 0)
	    BROWSER_COMMAND = viewer;
	SET_BROWSER_COMMAND = FALSE;
    }

    return(BROWSER_COMMAND);
}

HaveAppleExtension() {
    return(ISMAC && defined("apple", yoix) && defined("appleApplication", yoix.apple) && appleApplication());
}

HaveBrowserCommand() {
    //
    // Not convinced Oracle, or anyone else, is supporting JNLP, so we no
    // longer even try to use yoix.jnlp. There were two references in the
    // 2.3.1 version of this function that have been removed.
    //
    return(GetBrowserCommand() != NULL);
}

OpenBrowser(String url) {
    int     status = 0;
    Array   exec_viewer;
    Process proc;
    String  viewer;
    int     index;

    //
    // Returns a status of 0 if everything worked, 1 if we failed because
    // of something other than a security check, and 2 if the failure was
    // caused by a security check. We also show the security check error
    // message, which pretty much comes from Java, but it should contain
    // some useful information.
    //

    try {
	if (HaveAppleExtension() && !VM.applet) {
	    appleOpenURL(url);
            status = 0;
	} else if ((viewer = GetBrowserCommand()) != NULL) {
	    try {
		index = indexOf(viewer, ' ');
		if (index < 0) // unlikely
		    exec_viewer = new Array[] {viewer, url};
		else exec_viewer = new Array[] {substring(viewer, 0, index), url};
                if ((proc = exec(exec_viewer)) != NULL) {
                    if (proc.alive || proc.exitvalue == 0)
                        status = 0;
                    else status = 1;
                } else status = 1;
            }
	    catch(e) {
		status = 1;
	    }

            //
            // Not convinced this is even necessary. Old version only did it if
            // there was an error (i.e., status is ono-zero).
            //

	    SET_BROWSER_COMMAND = FALSE;
	} else status = 1;
    }
    catch(e) {
	if (e.name === "securitycheck") {
	    Warn(e.message);
	    status = 2;
	} else status = 1;
    }

    return(status);
}

////////////////////////////
//
// Help Section
//
////////////////////////////

//
// Next we put some HTML in a string that we can show users when they want
// quick instructions. The three characters sequence @<< starts a string in
// which all characters (including the newlines) up to the closing >>@ are
// collected as is.
//

String HELPSUMMARY = @<<<html>
<head>
<title>AT&amp;T Labs Research - Yoix / YChart Help</title>
    <style type="text/css">
        body {
            margin: 12px;
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 12px; 
            color: Black;
            background-color: White;
        }
        CENTER {
            text-align: center;
        }
        P {
            padding: 10pt 0pt 0pt 0pt 
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 12px; 
            color: Black;
        }
        TD {
            padding: 10pt 0pt 10pt 0pt 
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 12px; 
            color: Black;
        }
        EM {
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-style: italic;
            font-size : 12px; 
            color: Black;
        }
        CODE {
            font-family : Courier, "Courier New", Monaco;
            font-size : 12px; 
            color: Black;
        }
        PRE {
            font-family : Courier, "Courier New", Monaco;
            font-size : 12px; 
            color: Black;
            padding: 10pt 0pt 10pt 0pt 
        }
        OL, UL {
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 12px; 
            color: Black;
            padding: 0pt 0pt 0pt 12px 
        }
        LI {
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 12px; 
            color: Black;
            padding: 6pt 0pt 6pt 0pt
        }
        H1 {
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 24px;
            font-weight : bold;
            padding: 9pt 0pt 9pt 0pt 
        }
        H2 {
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 18px;
            font-weight : bold;
            padding: 7pt 0pt 7pt 0pt 
        }
        H3 {
            font-family : Helvetica, Arial, Verdana, Lucida;
            font-size : 12px;
            font-weight : bold;
            font-style : italic;
            padding: 5pt 0pt 5pt 0pt 
        }
    </head>
<body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" >
<table border="0" cellpadding="0" cellspacing="0" width="800">
<tr><td><table vspace=24 hspace=24><tr><td>
<!-- user content -->

<H1><A HREF='index.html' class='H1'>Yoix</A> / General YChart Usage Help</H1>
In the following, any mention of a <em>drop-down menu</em> refers to a menu implemented
using a <code>JComboBox</code>.
Also, Apple users should translate any reference to a <b>CTRL</b> modifer as a reference to the Apple command key, which is marked by the Unicode "Place of Interest Sign", namely the &#x2318; character.
This key is also sometimes referred to as the Apple key since on some keyboards it also has the Apple logo character, namely the &#xf8ff; character, on it.
For Apple users, pressing the <b>left</b> mouse button while holding the key marked <b>CTRL</b> acts just like a <b>right</b> mouse button press as regards <em>pop-up menus</em>, but this is platform dependent behavior that is not controlled by YChart.
<h2>Mouse Actions</h2>
The <b>right</b> mouse button applied over the chart itself will bring up a <em>pop-up menu</em> that provides fast access to many of the options available through the <em>drop-down menu</em> with the difference that the options selected through the <em>pop-up menu</em> only remain in effect for the next mouse action whereas options selected through the <em>drop-down</em> menu remain in effect for as long as the option remains selected in that menu.

Also, when a puzzle chart is available, additional options appear in this <em>pop-up menu</em> that are specific to the puzzle chart.

<p>
Note that when the mouse cursor is over the <em>drop-down menu</em> at the lower-center of the screen, a <em>pop-up menu</em> setting the sort order of the <em>drop-down menu</em> is available in some cases.
<p>
The <b>center</b> mouse button will always allow one to reposition the chart by panning, i.e., draging, the chart.
<p>
The <left> mouse button accepts modifiers and can be used to perform a number of functions:
<ul>
  <li>
  <b>Left button + No modifiers</b>:
  The <b>left</b> mouse button without any modifiers can trigger several actions depending on where it is applied:
  <ul type=circle>
    <li>
    when applied in the chart itself, the specific action is determined by the current menu selection in the <em>drop-down menu</em> or the active <em>pop-up menu</em> selection, if any;
    </li>
    <li>
    when applied over the magnifying glass icon at the lower-center-left of the screen, a slider pops up to allow adjustment of the chart zoom as the mouse cursor, with the left button still depressed, is dragged over the slider;
    </li>
    <li>
    when applied over the blue, decimal number to the left of the magnifying glass icon, the zoom factor will toggle between its current value, which is indicated by those decimal numbers, and <code>1.00</code>;
    </li>
    <li>
    when applied over the compass rose at the lower-right of the screen, the chart will be moved left, right, up or down depending on which little triangle is pressed. When the center square is pressed the chart will toggle between its current position and being anchored of the selected cell or, when no cell is selected, on the anchor point of the chart (see the <em>Anchor</em> option described below as part of the <em>Settings</em> menu of the menubar).
    Note that this latter behavior also occurs when the <b>right</b> mouse button is applied over the aforementioned decimal number, namely the zoom factor.
    </li>
  </ul>
  </li>
  <li>
  <b>Left button + CTRL modifier</b>:
  when applied to a cell, toggles the selection state of that cell.
  Selecting a cell not only highlights the cell, but also populates several areas with information related to the selected cell:
  <ul type=circle>
    <li> right side of the split pane, if visible, populates with details relating to the selected cell;</li>
    <li> the cell selection <em>drop-down menu</em> at the lower-center of the screen is set to the selected cell;</li>
    <li>if available, the URL text field is populated with an appropriate URL where additional information related to the selected cell can be found. Incidentally, pressing the <em>Open</em> button to the right of that field should bring up a web browser displaying the page associated with that URL.
  </ul>
  </li>
  <li>
  <b>Left button + SHIFT modifier</b>:
  when applied to a cell, it allows that cell to be moved (dragged) to a new location.
  At the same time, it highlights the original location of that cell.
  </li>
</ul>
<h2>Mouse Wheel</h2>
The mouse wheel works in many components and it is often the fastest way to do certain things:
<ul>
  <li>when the mouse cursor is on the chart itself, the mouse wheel will zoom the chart in or out and
  wherever the mouse cursor happens to be located will remain fixed as the zoom occurs;</li>
  <li>zooming occurs when the mouse cursor is over the magnifying glass icon or the zoom-scale label; in these cases, the fixed zoom point is the current anchor point (see the <em>Anchor</em> option described below as part of the <em>Settings</em> menu of the menubar);
  <li>when applied over a <code>JComboBox</code>, i.e., a <em>drop-down menu</em>, the mouse wheel will scroll through the available items in the menu. For example, over the middle <em>drop-down menu</em>, scrolling will cause each current menu item to select the associated cell and anchor the chart on that cell.</li>
  <li>if the mouse wheel is rotated over any of the the middle <em>drop-down menus</em> while the <b>SHIFT</b> key is held then the selected items will be restricted to those that correspond to cells that have been moved.</li>
</ul>
<h2>Menu Options</h2>
<h3>Action Menu</h3>
The <em>action menu</em> is a <em>drop-down menu</em> located a the lower-left of the screen. Its options include:
<ul>
  <li>
  <b>Cell Copy</b>:
  Allows a user to choose a
  cell and when chosen, the information in the cell is stored in the
  system clipboard buffer. The information is stored as individual
  lines of text in the following order:
  <ol>
    <li>main, center label;</li>
    <li>top labels left to right, working down;</li>
    <li>bottom labels, left to right, working up.</li>
  </ol>
</li>
<li>
<b>Cell Drag and Drop (DnD)</b>:
Allows a user to initiate a dragging action on a cell and
drop any of its labels onto any appropriate recipient inside or
outside the application.
</li>
<li>
<b>Erase Mark</b>:
Allows a user to select a mark on the chart or cell and clear it,
i.e., erase it (see <em>mark cell</em> and <em>mark chart</em>, below).
</li>
<li>
<b>Mark Cell</b>:
Allows user to write, using the mouse, in a cell.
Writing outside the cell is cropped.
The result is a multi-segment line, i.e., a <em>squiggle</em>, with or without an arrowhead at its final point.
Arrow mode can be toggled either through the <em>Settings</em> menu in the menubar or by pressing the <b>ALT</b>
key while marking.
Linux users may need to depress the <b>ALT</b> after the mouse motion has begun to avoid unintentionally
triggering a window manager action.
As far as YChart is concerned, the <b>ALT</b> key only really has an effect when the mouse button is released.
</li>
<li>
<b>Mark Chart</b>:
Allows user to write, using the mouse, on the chart.
Arrow mode can be toggled either through the <em>Settings</em> menu in the menubar or by pressing the <b>ALT</b>
key while marking.
See <em>mark cell</em>, above, for additional comments regarding arrow marking.
</li>
<li>
<b>Move Cell</b>:
Allows a user to move and position a cell anywhere in the chart.
</li>
<li>
<b>Pan</b>:
Allows a user to move the whole chart as a unit within the visible
area.
</li>
<li>
<b>Return Cell</b>:
Allows a user to return a moved cell to its original location. The
original location is highlighted.
A double-click on a moved cell will return it directly to its original
location.
</li>
<li>
<b>Select Cell</b>:
Allows a user to select a cell.
</li>
</ul>
<h3>Selection Menu</h3>
The selection menu at the lower-center of the screen lists the cells.
Selection from the menu causes the corresponding cell to be selected
and vice versa.
There can be up to three different selection menus on the same screen, each employing a different selection criterion.
<h3>Site Menu</h3>
This menu is visible when the URL field is visible.
When there are several external sources available for additional
information about a cell, this menu allows a particular site to be the
source used when constructing the external source URL when cells are selected.
<h3>Pop-Up Chart Menu</h3>
The pop-up menu available on the chart contains the same options as
the action menu plus the following options:
<ul>
  <li>
  <b>Erase All Cell Marks</b>:
  Erases all cell markings, but leaves chart markings intact.
  </li>
  <li>
  <b>Erase All Chart Marks</b>:
  Erases all chart markings, but leaves cell markings intact.
  </li>
  <li>
  <b>Return All Cells</b>:
  Returns all cells to their original positions.
  </li>
</ul>

Also, when a puzzle chart is available, there is a sub-menu in
the <em>pop-up menu</em> that contains the following additional entries:
<ul>
  <li>
  <b>Auto Check</b>:
  Automatically marks a misplaced cell with a red "X" across the face of
  the cell as the cells are placed.
  </li>
  <li>
  <b>Check Chart</b>:
  Runs a check of all the currently placed cells and marks the face of
  any misplaced cells with a red "X".
  </li>
  <li>
  <b>Clear Mistakes</b>:
  Clears the red "X" from misplaced cells, but does not reposition them.
  This action clears all red "X" marks whether they resulted from an
  <em>Auto Check</em> or a <em>Check Chart</em>.
  mode.
  </li>
  <li>
  <b>Scatter the Cells</b>:
  Resets the puzzle to its initial state, although the cell starting
  positions will be different from the last time since they are
  randomly placed.
  </li>
  <li>
  <b>Solve the Puzzle</b>:
  moves all the puzzle pieces to their correct positions.
  </li>
</ul>
<h3>Menubar</h3>
There are several menubar menus. Of interest are:
<ul>
  <li>
  <b>Settings</b>:
  <ul type=circle>
    <li>
    <b>Anchor</b>:
    A menu that can be used to disable cell anchoring, which means cells will not
    move when selected. It can also be used to set the anchoring of the chart so
    that the anchor point in the selected cell, or the anchor point of the chart
    if there is no selected cell, appears at one of the following locations in the
    viewer panel: top left, top, top right, left, center, right, bottom left, bottom
    and bottom right. The precise position of the anchor points are actually under
    the control of the YChart designer; the listed points are the defaults.
    </li>
    <li>
    <b>Show Column Labels</b>:
    Toggles display of chart column labels, if any.
    </li>
    <li>
    <b>Show Row Labels</b>:
    Toggles display of chart row labels, if any.
    </li>
    <li>
    <b>Show Chart Grid</b>:
    Toggles display of the grid used when placing cells.
    </li>
    <li>
    <b>Show Find Panel</b>:
    Toggles display of the find panel, which can also be toggled by using
    CTRL-F.
    </li>
    <li>
    <b>Hide Unselected Cell Labels</b>:
    Arranges to hide all cell labels except for the ones that belong to the
    currently selected cell. We though this might occasionally be useful if
    the chart is being used as a teaching tool.
    </li>
    <li>
    <b>Terminate Marks With Arrow</b>:
    Chart or cell marks added when this is selected are terminated with an arrow head.
    </li>
  </ul>
</li>
<li>
<b>Charts</b>:
Lists the charts that are available for loading into the viewer. There
are also options for reloading the current chart and clearing the
chart cache.
</li>
<li>
<b>Colors</b>:
Lists the coloring schemes available for the current chart. In
addition there is a reverse video option that essentially just
toggles the background color between black and white.
</li>
<li>
<b>Filters</b>:
This is an optional menu that, if present, contains items usually organized in sub-menus
that represent a single filter and allow groups of cells to be selectively hidden.
When there are several filters, cells are hidden unless they are selected by all the
filters.
Two special items named <em>All On</em> and <em>All Off</em> usually appear in filter
sub-menus and can be used to apply the selection operation to all cells in the chart.
</ul>
<h2>Find Panel</h2>
Display of the find panel can occur through a <em>Settings</em>
menubar option or by using CTRL-F.
The find panel can be used to search through the selection menu.
If a match is found, that menu entry and the corresponding cell are
selected, otherwise the search string is shown in red.
A match occurs if search string is contained anywhere within a
selection menu entry.
There is an option to match upper/lower case letters and to search
forwards and backwards.
<h2>Arrow Buttons</h2>
Certain YChart displays may have up and down arrow buttons to the right of the selection menu(s) at the lower-center of the screen.
When present, these buttons allow one to step through cell selections.
To clarify, visually, the transition from one selected cell to the next, an arrow is drawn from the previously selected cell to the newly selected cell and the chart is anchored (see the <em>Anchor</em> option described above as part of the <em>Settings</em> menu of the menubar) on the newly selected cell.
The speed with which the chart is re-anchored and the duration that the arrow is displayed depends
directly on how long the arrow button remains depressed.
<p>
In cases where the next cell to select may be ambiguous because it could be any of a set of cells, then the last cell that was selected, using any of the possible cell selection methods, in that set will be used.
In such cases, a check mark may be used by the YChart designer to indicate which cell that will be.
<h2>Key Mappings</h2>
There are a number of key mappings provided as a convenient way to accomplish tasks. These mappings include:
<ul>
  <li><b>CTRL-F</b>: toggle find panel visibility</li>
  <li><b>CTRL-G</b>: find next matching cell (forward)</li>
  <li><b>CTRL-SHIFT-G</b>: find next matching cell (backward)</li>
  <li><b>UP-ARROW</b>: pan or scroll chart up by half a row</li>
  <li><b>DOWN-ARROW</b>: pan or scroll chart down by half a row</li>
  <li><b>LEFT-ARROW</b>: pan or scroll chart left by half a column</li>
  <li><b>RIGHT-ARROW</b>: pan or scroll chart right by half a column</li>
  <li><b>PAGE-UP</b>: pan or scroll chart up by the visible amount</li>
  <li><b>PAGE-DOWN</b>: pan or scroll chart down by the visible amount</li>
  <li><b>SHIFT-PAGE-UP</b>: pan or scroll chart left by the visible amount</li>
  <li><b>SHIFT-PAGE-DOWN</b>: pan or scroll chart right by the visible amount</li>
  <li><b>CTRL-PAGE-UP</b>: zoom chart out a bit</li>
  <li><b>CTRL-PAGE-DOWN</b>: zoom chart in a bit</li>
  <li><b>HOME</b>: toggle between anchoring the chart as a whole or anchoring on the selected cell (see <em>Anchor</em>)</li>
  <li><b>END</b>: toggle between current zoom factor and actual size (zoom factor of 1.0)</li>
</ul>

<h2>Command-Line Arguments</h2>
A standalone YChart application is invoked by any of the following three command-line calling sequences:
<pre>
   java [java_args] -jar yoix.jar [yoix_args] ychart.yx [ychart_args] ychart_script_file.yx

   yoix [yoix_args] ychart.yx [ychart_args] ychart_script_file.yx

   ychart [ychart_args] ychart_script_file.yx
</pre>
The optional Java and Yoix command-line arguments are described elsewhere. The optional YChart arguments are:
<ul>
  <li><b>-a <em>ratio</em></b>: Sets the cell aspect ratio as a non-negative floating-point number. Uninitialized by default.</li>
  <li><b>-b <em>border</em></b>: Sets the cell border as a non-negative floating-point number. Uninitialized by default.</li>
  <li><b>-f <em>font</em></b>: Sets the font used in the chart. The font is scaled to provide the different sized fonts used throughout the chart. The default is: <em>Lucida-bold-12</em>.</li>
  <li><b>-m <em>margin</em></b>: Sets the cell margin as a non-negative floating-point number. Uninitialized by default.</li>
  <li><b>(-|+)p</b>: Do (+) or do not (-) pre-load the charts; only charts that have a non-zero <em>preload</em> field in their dictionaries can be pre-loaded. The default is to not pre-load any charts.</li>
  <li><b>(-|+)r</b>: Do (+) or do not (-) reverse the chart foreground and background colors. The default is to not reverse the colors.</li>
  <li><b>-s <em>separation</em></b>: Sets the cell separation as a non-negative floating-point number. Uninitialized by default.</li>
  <li><b>(-|+)u</b>: Do (+) or do not (-) use the clipping path to suppress painting computations for cells outside the clip area. The default is to use the clipping path.</li>
  <li><b>-w <em>line-width</em></b>: Sets the mark line-width as a non-negative floating-point number. The default is 1.5.</li>
  <li><b>(-|+)y</b>: Do (+) or do not (-) use the YChart module (yoix.ychart). A warning is written to the standard error stream if the module is not used. The default is to use the YChart module.</li>
  <li><b>-B <em>browser-command</em></b>: The command to execute when opening a URL. The default is to attempt to determine the command automatically.</li>
  <li><b>-P <em>program</em></b>: Sets the program name that is displayed in error messages and warnings. The default is: yoix.</li>
  <li><b>-T <em>frame-title</em></b>: Sets the title used for the <em>JFrame</em>. The default is: Yoix&#x00ae; YChart.</li>
  <li><b>(-|+)Y</b>: Do (+) or do not (-) use the YChart module (yoix.ychart). No warning is written to the standard error stream if the module is not used. The default is to use the YChart module.</li>
</ul>

<!-- /user content -->
</td></tr></table></td></tr>
</table>
</body>
</html>
>>@;

////////////////////////////
//
// GUI Section
//
////////////////////////////

final int MOUSE_AVAILABLE = 0;
final int MOUSE_CELLCOPY = 1;
final int MOUSE_CELLDND = 2;
final int MOUSE_ERASEMARK = 3;
final int MOUSE_MARKCELL = 4;
final int MOUSE_MARKCHART = 5;
final int MOUSE_MOVECELL = 6;
final int MOUSE_RETURNCELL = 7;
final int MOUSE_SELECTCELL = 8;

//
// Our original code used a simple screen built by NewHTMLViewer(), which
// is defined next, to display external web sites and the help information
// that's stored as HTML in the HELPSUMMARY string that was kust defined.
// Unfortunately a JTextPane operating in HTML mode can't currently cope
// with some of the web sites that we wanted to display, so we now only
// use screens built by NewHTMLViewer() to display HELPSUMMARY. However
// the code used to build the screen isn't too complicated, particularly
// when compared to the main screen, so we decided to start with it.
//
// NOTE - we decided to have a function build the screen rather than just
// defining it in-line right here, because at the time we were using it
// for several different things. However we've changed our approach and
// are now only using one of these screens, so the function really isn't
// needed, but it also doesn't really hurt and is an example of a common
// technique in Yoix so we're going to leave it be for now.
//

NewHTMLViewer(Object parent) {
    JFrame screen = {
	Object parent = parent;
	String title = "HTML Viewer";
	Color  background = SCREEN_BACKGROUND;
	Color  foreground = SCREEN_FOREGROUND;
	Font   font = GetScreenFont();
	int    autoraise = TRUE;
	int    border = 72.0/8;

	////////////////////////////
	//
	// Custom Variables
	//
	////////////////////////////

	Array pagestack[0, ...];
	int   pagetop = -1;
	int   pagelimit = -1;
	int   initialized = FALSE;

	////////////////////////////
	//
	// Screen Layout
	//
	////////////////////////////

	GridBagLayout layoutmanager = {
	    int vgap = 72/16;
	    int hgap = 72/16;
	};

	Array layout = {
	    new JLabel {
		String tag = "$_url_label";
		Object transferhandler = NULL;		// required for custom drag and drop
		int    alignment = LEFT;

		Function dragGestureRecognized = DragGestureRecognized;
	    },
	    HORIZONTAL, REMAINDER,

	    new JTextPane {
		String tag = "$_html_display";
		Object transferhandler = NULL;		// required for custom drag and drop
		double insets = 72.0/8;
		Color  background = TEXT_BACKGROUND;
		Color  foreground = TEXT_FOREGROUND;
		int    mode = 1;		// 1=HTML; 0=plain; -1=RTF
		int    caretmodel = 1;
		int    edit = FALSE;
		int    scroll = AS_NEEDED;

		Function dragGestureRecognized = DragGestureRecognized;
		Function keyPressed = KeyPressed;

		hyperlinkActivated(e) {
		    root.PushURL(e.href);
		}
	    },
	    BOTH, REMAINDER,

	    new JPanel {
		GridBagLayout layoutmanager;
		Array layout = {
		    new JPanel {
			GridLayout layoutmanager;
			Array layout = {
			    new JButton {
				String tag = "$_prev_button";
				String text = "Prev";
				int    requestfocus = TRUE;

				actionPerformed(e) {
				    root.components.$_html_display.page = root.pagestack[--root.pagetop].url;
				    root.SyncComponents();
				}
			    },
			    new JButton {
				String text = "Reload";
				String tag = "$_reload_button";
				int    requestfocus = TRUE;

				actionPerformed(e) {
				    root.components.$_html_display.page = NULL;
				    root.components.$_html_display.page = root.pagestack[root.pagetop].url;
				}
			    },
			    new JButton {
				String tag = "$_next_button";
				String text = "Next";
				int    requestfocus = TRUE;

				actionPerformed(e) {
				    root.components.$_html_display.page = root.pagestack[++root.pagetop].url;
				    root.SyncComponents();
				}
			    },
			};
		    },
		    new Dictionary {
			int gridx = 1;
			int gridy = 1;
			int weightx = 1;
		    },

		    new JButton {
			String text = "Dismiss";

			actionPerformed(e) {
			    root.HideScreen();
			}
		    },
		    RIGHT,
		};
	    },
	    HORIZONTAL,
	};

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	windowClosing(e) {
	    //
	    // This event handler is needed to prevent the automatic dispose of
	    // windows by the Yoix interpreter. There's more documention about
	    // this in the Yoix windowClosing() reference page.
	    //

	    HideScreen();
	}

	////////////////////////////
	//
	// Screen Functions
	//
	////////////////////////////

	HideScreen() {
	    visible = FALSE;
	}

	ShowScreen() {
	    if (!initialized) {
		initialized = TRUE;
		if (parent != NULL) {
		    size = new Dimension {
			double width = 0.8*parent.size.width;
			double height = 0.6*parent.size.height;
		    };
		    location = new Point {
			double x = parent.location.x + parent.size.width/2 - size.width/2;
			double y = parent.location.y + parent.size.height/2 - size.height/2;
		    };
		}
	    }
	    visible = TRUE;
	}

	////////////////////////////
	//
	// Miscellaneous Functions
	//
	////////////////////////////

	PushURL(String url) {
	    Dictionary info;
	    String     context;

	    context = (pagetop >= 0) ? pagestack[pagetop].url : NULL;
	    if ((info = parseURL(context, url)) != NULL) {
		url = info.externalform;
		if (pagetop < 0 || pagestack[pagetop].url !== url) {
		    //
		    // We eventually want to save some state information for
		    // the JTextPane that's displaying the current html page
		    // (e.g., scrollbar positions), but we're not sure that
		    // info is easily available right now. We will look into
		    // it later, but that's why we're using a dictionary that
		    // right now only has one entry.
		    //
		    pagestack[++pagetop] = new Dictionary {
			String url = info.externalform;
		    };
		    pagelimit = pagetop;
		    try {
			components.$_html_display.page = pagestack[pagetop].url;
		    }
		    catch(e) {
			Warn(e.message);
			pagelimit = --pagetop;
		    }
		    SyncComponents();
		}
	    } else Warn(strfmt("malformed link \"%s\"", url));
	}

	ShowText(String text) {
	    components.$_html_display.page = NULL;
	    components.$_html_display.font = "sansserif-plain-12"; // seems to be necessary to get reasonable font behavior
	    components.$_html_display.text = text;
	    components.$_html_display.selectedends = new Array {0, 0};
	    SyncComponents();
	    ShowScreen();
	    components.$_url_label.text = NULL;		// clears what SyncComponents() put there - small kludge
	}

	ShowURL(String url) {
	    if (url@sizeof > 0) {
		PushURL(url);
		ShowScreen();
	    }
	}

	SyncComponents() {
	    if (pagetop >= 0)
		components.$_url_label.text = pagestack[pagetop].url;
	    components.$_next_button.enabled = (pagetop < pagelimit);
	    components.$_reload_button.enabled = (pagetop >= 0);
	    components.$_prev_button.enabled = (pagetop > 0);
	}
    };

    //
    // This just returns the screen that was declared as a local variable when
    // the function wasd called.
    //
    return(screen);
}

//
// Function to return magnifier icon, which comes from the "Java look and feel
// Graphics Repository" from Sun Microsystems, so the following license applies
// to the icon.
//
// Start Sun Icon License
//
// Copyright 2000 by Sun Microsystems, Inc. All Rights Reserved.
//
// Sun grants you ("Licensee") a non-exclusive, royalty free, license
// to use, and redistribute this software graphics artwork, as individual
// graphics or as a collection, as part of software code or programs
// that you develop, provided that i) this copyright notice and license
// accompany the software graphics artwork; and ii) you do not utilize
// the software graphics artwork in a manner which is disparaging to
// Sun. Unless enforcement is prohibited by applicable law, you may
// not modify the graphics, and must use them true to color and
// unmodified in every way.
//
// This software graphics artwork is provided "AS IS," without a
// warranty of any kind. ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS
// AND WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY
// EXCLUDED. SUN AND ITS LICENSORS SHALL NOT BE LIABLE FOR ANY DAMAGES
// SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
// THE SOFTWARE GRAPHICS ARTWORK.
//
// IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE,
// PROFIT OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL,
// INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF
// THE THEORY OF LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO
// USE SOFTWARE GRAPHICS ARTWORK, EVEN IF SUN HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
//
// If any of the above provisions are held to be in violation of
// applicable law, void, or unenforceable in any jurisdiction, then
// such provisions are waived to the extent necessary for this Disclaimer
// to be otherwise enforceable in such jurisdiction.
//
// End Sun Icon License
//

GetMagnifierIcon() {
    String pixels = @<<1F8B0800000000000000D5965D6EC3201084DF7B8A1C01B0C1ECE32EE0FB1FA9C0A08A0A3B3F8AED364CA42025CA7C995DCC6A7FD3FE66E6FABA291D54D117DEFE8F3E1348C52AAC617F11506F19E72C9224293AEC830D367F60B2528F780A50FB695856FB55654DA9C8259DE5448B0E449A349378F15185BCE232A949397D34100A518022EC81E2D9331BD8F728E4897895AC0C14A7E8D26A8A0E00EA0BD4A7D250900AEC07144A94C4E5BF31C708AC2380EA42AF6CA0ECA4F283921365CB56220AB7D6755842AD577AFBBB7BA0944E4AF69DC26D248476DE4D05FB2115A0B0B084F9E884EA61DE2D50DDA35732CAFC1BA5B44F92C31282F0737BBD3216A843E11EE580841A109E25F5B9B2D7B6238A183181DF29D62E508FD50EF03D9456207CDFA5A2772E96077719C2EF2DC77D5FA0762C265932700A46DCAB582FDCF6B0ECEDC75E69F615C53B97AC6326BDD0F358A78C1FB0070AB044D3B2A467B04E9C87600F14A2459C099EAD8FF7B14E1FD09A7D45E1D5D362E22A33953EDCC4BA68626C8FDC8A124CC92C1F89CDF9E9D21116A900A53F167F06D46BEF62F9CC21FF52A06FBF8B1DE4AF0D0000>>@;
    Color bkgd;
    Color pixel;
    Image image;
    StringStream input = {
	int mode = READ;
	int open = 1;
	int filters = GZIP|HEXCODER;
	String name = pixels;
    };
    int row, col;
    int width, height, cols, rows, type, flag, red, green, blue;

    if (fscanf(input, "%d %d %d %d %d %02X%02X%02X%02X\n", &width, &height, &cols, &rows, &type, &flag, &red, &green, &blue) == 9) {
	bkgd = new Color { int red = red; int green = green; int blue = blue; };
	image = new Image {
	    int type = type;
	    Color background = bkgd;
	    Dimension size =  { int width = width; int height = height; };
	 };
	for (row = 0; row < rows; row++) {
	    for (col = 0; col < cols; col++) {
		if (fscanf(input, "%02X%02X%02X", &red, &green, &blue) == 3) {
		    pixel = new Color {
			int red = red;
			int green = green;
			int blue = blue;
		    };
		    if (bkgd == NULL || pixel !== bkgd)
			image.setpixel(col, row, pixel);
		} else Die("missing pixel at (%d, %d) in magnifier icon", col, row);
	    }
	}
    } else Die("icon string does not appear to be a valid compressed hexed image");

    return(image);
}

//
// The next function is used to build the selectors (currently are three) that let
// you navigate around in the chart. They're all identical, except for the tag and
// the index.
//

NewSelector(String tag, int index) {
    JChoice selector = {
	String tag = tag;
	String prototypevalue = "";		// "" means get it from loaded labels
	Array  currentlabels = NULL;
	int    selector = index;		// our internal index
	int    restoring = FALSE;
	int    visible = FALSE;

	ButtonGroup sortby_group;

	JPopupMenu popup = {
	    Color background = SCREEN_BACKGROUND;
	    Color foreground = SCREEN_FOREGROUND;
	};

	itemStateChanged(e) {
	    if (!restoring)
		root.components.$_selector_panel.HandleItemStateChanged(e.state, selector);
	}

	mousePressed(e) {
	    ShowPopup(e);
	}

	mouseReleased(e) {
	    ShowPopup(e);
	}

	mouseWheelMoved(e) {
	    root.components.$_selector_panel.HandleMouseWheelMoved(e, selector);
	}

	////////////////////////////
	//
	// Miscellaneous Functions
	//
	////////////////////////////

	LoadSelector() {
	    Array data;

	    //
	    // Each selector should make sure the labels array has an empty
	    // string at index 0. It originally was going to be optional, but
	    // it's convenient and now assumed to be the case in quite a few
	    // places.
	    //

	    data = root.activechart.GetSelectorData(selector, sortby_group.selected ? sortby_group.selected.command : NULL);
	    if (data@sizeof > 0) {
		if (data[0] !== "")
		    data = new Array {"", unroll(data)};
	    } else data = NULL;
	    visible = (data != NULL);
	    labels = data;
	    currentlabels = data;
	}

	RestoreState(Object arg) {
	    Array data;
	    save  restoring = TRUE;

	    if (arg != NULL) {
		currentlabels = arg.currentlabels;
		popup.items = arg.popup_items;
		sortby_group.selected = arg.sortby_selected;
		if (defined("items", arg) && defined("selected", arg)) {
		    items = arg.items;
		    selected = arg.selected;
		}
	    } else {
		data = root.activechart.GetSelectorMenuData(selector);
		popup.items = root.BuildButtonMenuItems(data, sortby_group, &SetSortedBy);
		if (!SHARESELECTION)
		    selected = 0;
	    }
	}

	SaveState() {
	    Dictionary dict;

	    dict = new Dictionary[0, ...] {
		Array  currentlabels = currentlabels;
		Object popup_items = popup.items;
		Object sortby_selected = sortby_group.selected;
	    };
	    if (!SHARESELECTION) {
		dict.selected = selected;
		dict.items = items;
	    }
	    return(dict);
	}

	SetSortedBy() {
	    //
	    // A brute force approach that works because LoadSelectors()
	    // calls GetSelectorData(), which is where sorting currently
	    // happens. Ugly and not too hard to imagine better solutions,
	    // but we're probably not going to do anything about it this
	    // release.
	    //
	    root.components.$_selector_panel.LoadSelectors();
	}

	ShowPopup(MouseEvent e) {
	    if (e.popuptrigger && e.pressed <= 1) {
		if (popup.items@sizeof) {
		    popup.location = e.location;
		    popup.visible = TRUE;
		}
	    }
	}
    };

    return(selector);
}

//
// This is the main screen, and as you might notice it's quite complicated.
//

JFrame mainscreen = {
    Dimension size = NULL;
    String    title = TITLE;
    double    border = 72.0/16;
    Color     background = SCREEN_BACKGROUND;
    Color     foreground = SCREEN_FOREGROUND;
    Font      font = GetScreenFont();

    ////////////////////////////
    //
    // Custom Variables
    //
    ////////////////////////////

    Dictionary activechart = NULL;
    Dictionary tooltips = NULL;
    String     activemodel = NULL;
    double     currentscaling = 1.0;
    double     maxscaling = POSITIVE_INFINITY;
    double     minscaling = 0.2;
    double     lastscaling = 1.0;
    int        primaryoperation = MOUSE_AVAILABLE;	// panning
    int        initialized = FALSE;
    int        restoring = FALSE;

    //
    // Groups used to enforce "radio button" behavior among collections of
    // menu items.
    //

    ButtonGroup coloredby_group;
    ButtonGroup chart_model_group;
    ButtonGroup anchor_group;

    //
    // We use this for coloring cells, but likely will let the user choose
    // things like the model and adjust settings for hue (and maybe others).
    //

    Object coloredby_selected = NULL;
    Array  activecolordata = NULL;
    int    reveresevideo = FALSE;

    //
    // Help and version info.
    //

    String help_about = NULL;
    String help_summary = NULL;
    String help_url = NULL;

    //
    // Right now there's just one HTML viewer and we use it for hard-coded
    // HTML help (i.e., the HELPSUMMARY string) and for viewing the contents
    // of external web sites.
    //

    Object htmlviewer = NULL;

    //
    // A Dictionary that describes the the state of various chart labels.
    // Right now we only recognize "row" and "column" labels, but we could
    // add more (e.g., "top column labels" or "left row labels"). It's not
    // a high priority so it probably won't happen for quite a while.
    //

    Dictionary selected_chart_labels[] = {
	COLUMN_LABELS, TRUE,
	ROW_LABELS, TRUE
    };

    //
    // A cache for the supported charts that we've already created.
    //

    Dictionary chartcache[0, ...];

    //
    // We use a thread to start the browser. Mostly done to let queueOnce()
    // eliminate accidental or even intentional button presses for the URL
    // that we're trying to show.
    //

    Thread browserthread;

    //
    // We use a simple thread to coordinate the update of any components
    // that can be postponed a bit when the user is changing the selected
    // cell using the mouse wheel. There are lots of different approaches,
    // but the one we use here relies on queueOnce() to make sure we don't
    // ask this thread to do more than necessary. Also notice that we use
    // invokeLater() to run the handler because all updates really should
    // be carried out in the event thread. Finally notice that we also set
    // persistent to TRUE, so we only use one underlying Java thread.
    //

    Thread syncthread = {
	int daemon = TRUE;
	int persistent = TRUE;
	int priority = MIN_PRIORITY;

	double alarm = 0;

	HandleDelayedSync(...) {
	    Object handler = argv[1];
	    int    arg = argv[2];
	    double now = time();

	    do {
		sleep(alarm - now);
		now = time();
	    } while (alarm > now);
	    invokeLater(handler, arg);
	}

	DelayedSync(...) {
	    alarm = time() + SYNCDELAY;
	    queueOnce(HandleDelayedSync, unroll(&argv[1]));
	}
    };

    ////////////////////////////
    //
    // Glasspane
    //
    ////////////////////////////

    JPanel glasspane = {
	BorderLayout layoutmanager;
	int cursor = Cursor.WAIT_CURSOR;

	//
	// Unfortunately there are lots of places where the code simply assumes
	// that activechart isn't NULL. As an alternative to fixing the code, at
	// least for this release, we decided to intercept events in a glasspane
	// that has stub event handlers defined for the events that might cause
	// problems. A reaonable alternative would be to disable and enable the
	// JFrame, which would take care of most of its chidren, but a disabled
	// component won't show a wait cursor.
	//

	keyPressed(e) {}
	keyReleased(e) {}
	keyTyped(e) {}
	mouseEntered(e) {}
	mouseExited(e) {}
	mouseMoved(e) {}
	mousePressed(e) {}
	mouseReleased(e) {}
	mouseDragged(e) {}
	mouseWheelMoved(e) {}

	componentShown(e) {
	    requestfocus = TRUE;
	}
    };

    ////////////////////////////
    //
    // Menubar Layout
    //
    ////////////////////////////

    JMenuBar menubar = {
	Array items = {
	    new JMenu {
		String text = "File";
		Array items = {
		    new JMenuItem {
			String text = "Print";
			String command = "print";
			int    enabled = FALSE;

			actionPerformed(e) {
			    Warn("printing has not been implemented yet");
			}
		    },
		    NULL,
		    new JMenuItem {
			String text = "Quit";
			String command = "quit";
			String accelerator = "ctrl Q";

			actionPerformed(e) {
			    exit(0);
			}
		    },
		};
	    },

	    new JMenu {
		String text = "Settings";
		Array items = {
		    new JMenu {
			String text = "Anchor";
			Array items = {
			    new JCheckBoxMenuItem {
				String tag = "$_anchorenabled";
				String text = "Enabled";
				int    state = TRUE;

				itemStateChanged(e) {
				    root.SetAnchorEnabled(e.state);
				}
			    },
			    NULL,
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Top Left";
				String      command = toString(TOPLEFT);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(TOPLEFT);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Top";
				String      command = toString(TOP);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(TOP);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Top Right";
				String      command = toString(TOPRIGHT);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(TOPRIGHT);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Left";
				String      command = toString(LEFT);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(LEFT);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Center";
				String      command = toString(CENTER);
				int         state = TRUE;

				itemStateChanged(e) {
				    root.SetAnchor(CENTER);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Right";
				String      command = toString(RIGHT);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(RIGHT);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Bottom Left";
				String      command = toString(BOTTOMLEFT);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(BOTTOMLEFT);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Bottom";
				String      command = toString(BOTTOM);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(BOTTOM);
				}
			    },
			    new JRadioButtonMenuItem {
				ButtonGroup group = anchor_group;
				String      text = "Bottom Right";
				String      command = toString(BOTTOMRIGHT);
				int         state = FALSE;

				itemStateChanged(e) {
				    root.SetAnchor(BOTTOMRIGHT);
				}
			    },
			};
		    },
		    NULL,
		    new JCheckBoxMenuItem {
			String text = COLUMN_LABELS;
			int    state = (COLUMN_LABELS != NULL) ? selected_chart_labels[COLUMN_LABELS] : FALSE;
			int    visible = (COLUMN_LABELS != NULL);

			itemStateChanged(e) {
			    root.SetSelectedChartLabels(text, state);
			}
		    },
		    new JCheckBoxMenuItem {
			String text = ROW_LABELS;
			int    state = (ROW_LABELS != NULL) ? selected_chart_labels[ROW_LABELS] : FALSE;
			int    visible = (ROW_LABELS != NULL);

			itemStateChanged(e) {
			    root.SetSelectedChartLabels(text, state);
			}
		    },
		    new JCheckBoxMenuItem {
			String tag = "$_showgrid";
			String text = "Show Chart Grid";
			int    state = FALSE;

			itemStateChanged(e) {
			    root.SetShowGrid(state);
			}
		    },
		    new JCheckBoxMenuItem {
			String tag = "$_showfind";
			String text = "Show Find Panel";
			String accelerator = "ctrl typed F";
			int    state = FALSE;

			itemStateChanged(e) {
			    root.SetFindPanelVisibility(state);
			}
		    },
		    NULL,
		    new JCheckBoxMenuItem {
			String tag = "$_hideunselectedlabels";
			String text = "Hide Unselected Cell Labels";
			int    state = FALSE;

			itemStateChanged(e) {
			    root.SetHideUnselectedCellLabels(state);
			}
		    },
		    new JCheckBoxMenuItem {
			String tag = "$_markarrows";
			String text = "Terminate Marks With Arrow";
			int    state = ARROW_MARKS;

			itemStateChanged(e) {
			    ARROW_MARKS = state;
			}
		    },

		    //
		    // Rather pointless, so it's disabled.
		    //
		    new JCheckBoxMenuItem {
			String tag = "$_tooltips";
			String text = "Show Tooltips";
			int    state = TRUE;
			int    visible = FALSE;

			itemStateChanged(e) {
			    root.SyncToolTips();
			}
		    },
		};
	    },

	    new JMenu {
		String tag = "$_charts_menu";
		String text = "Charts";
	    },

	    new JMenu {
		String tag = "$_colors_menu";
		String text = "Colors";
	    },

	    new JMenu {
		String tag = "$_filters_menu";
		String text = "Filters";
		int    visible = FALSE;
	    },

	    new JMenu {
		String tag = "$_help_menu";
		String text = "Help";
	    },
	};
    };

    ////////////////////////////
    //
    // Screen Layout
    //
    ////////////////////////////

    GridBagLayout layoutmanager = {
	int vgap = 72/16;
	int hgap = 72/16;
    };

    Array layout = {
	new JLabel {
	    String tag = "$_chart_model_label";
	    String text;
	    Font   font = GetHeadingFont();

	    ClearChart() {
		text = NULL;
	    }

	    RestoreState(Object arg) {
		text = root.GetActiveChartName();
	    }
	},
	CENTER, REMAINDER,

	new JPanel {
	    String tag = "$_external_panel";

	    GridBagLayout layoutmanager = {
		double hgap = 72.0/16;
	    };
	    Array layout = {
		"URL",
		new JTextField {
		    String tag = "$_external_url";
		    int    autotrim = TRUE;
		    Object transferhandler = NULL;		// required for custom drag and drop

		    Function dragGestureRecognized = DragGestureRecognized;
		    Function keyPressed = KeyPressed;

		    ClearChart() {
			text = NULL;
		    }
		},
		BOTH,

		new JChoice {
		    String tag = "$_external_site";

		    Dictionary currentcell = NULL;
		    Array      externalsites;

		    itemStateChanged(e) {
			if (e.state) {
			    currentcell = NULL;
			    SyncSelected();
			}
		    }

		    mouseWheelMoved(e) {
			int index = indexOfObject(mappings, selected);

			selected = (e.wheelrotation < 0) ? max(index - 1, 0) : min(index + 1, mappings@sizeof - 1);
		    }

		    RestoreState(Object arg) {
			if (arg == NULL) {
			    arg = new Dictionary {
				Object selected = selected;
				Array  externalsites = root.activechart.GetExternalSiteData();
			    };
			}

			externalsites = arg.externalsites;
			items = arg.externalsites;
			selected = (arg.selected != NULL || items@sizeof == 0) ? arg.selected : items[1];
			SyncSelected();
			root.components.$_external_panel.SetEnabled(externalsites@length > 0);
			root.components.$_external_panel.SetVisible(externalsites != NULL);
		    }

		    SaveState() {
			return(new Dictionary {
			    Object selected = selected;
			    Array  externalsites = externalsites;
			 });
		    }

		    SyncSelected() {
			Dictionary cell;
			String     name;

			if ((cell = root.GetCurrentCell()) != currentcell) {
			    if (externalsites && selected) {
				root.components.$_external_url.text = root.activechart.GetExternalSiteURL(cell, selected);
				currentcell = cell;
			    } else {
				root.components.$_external_url.text = NULL;
				currentcell = NULL;
			    }
			}
		    }
		},
		NONE,

		new JButton {
		    String text = "Open";

		    actionPerformed(e) {
			Array urls = strsplit(root.components.$_external_url.text, "|");
			for (ptr in urls)
			    root.browserthread.queueOnce(&root.ShowExternalURL, *ptr);
		    }
		},
		NONE,
	    };

	    SetEnabled(int state) {
		enabled = state && HaveBrowserCommand();
	    }

	    SetVisible(int state) {
		visible = state && HaveBrowserCommand();
	    }
	},
	HORIZONTAL, REMAINDER,

	new JSplitPane {
	    String tag = "$_chart_splitpane";
	    double resizeweight = 1;
	    double dividerlocation = 1.0;
	    int    continuouslayout = FALSE;
	    int    onetouchexpandable = TRUE;
	    int    orientation = HORIZONTAL;

	    Dimension preferredsize = {
		double width = CHART_WIDTH;
		double height = CHART_HEIGHT;
	    };

	    //
	    // A custom variable used help maintain the divider's location
	    // when we change charts (see RestoreState() and SaveState()).
	    //

	    double lastsaveddivider = 1.0;

	    Array layout = {
		new JPanel {
		    String tag = "$_chart_panel";
		    Color  background = REVERSE_VIDEO ? Color.white : Color.black;
		    Color  foreground = REVERSE_VIDEO ? Color.black : Color.white;
		    BevelBorder border;

		    GridBagLayout layoutmanager;
		    Array layout = {
			new JCanvas {
			    String tag = "$_chart_canvas";
			    int    panandzoom = 0x000083;	// automatic panning and copyarea

			    Graphics graphics = {
				int fractionalmetrics = TRUE;
			    };

			    Dimension lastsize = NULL;
			    Matrix    defaultmatrix = NULL;
			    Matrix    screenmatrix = VM.screen.defaultmatrix;

			    Dictionary pressedcell = NULL;
			    Rectangle  pressedcellhome = NULL;
			    String     dragtext = NULL;
			    Point      pressedpoint = NULL;
			    Point      pressedoffset = NULL;
			    int        mouse = MOUSE_AVAILABLE;

			    Object marking = NULL;
			    Array  nextmark = NULL;

                            //
                            // An array that's used for temporarily saving mouse wheel
                            // zooming events. Lets us collect and combine several of
                            // them, so intermediate zooms can sometimes be skipped.
                            //

                            Array wheelzoom_events = NULL;

			    JPopupMenu popup = {
				Color background = SCREEN_BACKGROUND;
				Color foreground = SCREEN_FOREGROUND;

				Array items = {
				    new JMenu {
					String text = "Puzzle";
					String tag = "$_puzzle";

					Array items = {
					    new JCheckBoxMenuItem {
						String text = "Auto Check";
						String tag = "$_autocheck";

						itemStateChanged(e) {
						    invokeLater(&root.SetAutoCheck, state);
						}
					    },
					    new JMenuItem {
						String text = "Check Chart";

						actionPerformed(e) {
						    invokeLater(&root.CheckChart);
						}
					    },
					    new JMenuItem {
						String text = "Clear Mistakes";

						actionPerformed(e) {
						    invokeLater(&root.ClearMistakes);
						}
					    },
					    NULL,
					    new JMenuItem {
						String text = "Scatter the Cells";

						actionPerformed(e) {
						    invokeLater(&root.ScatterAllCells);
						}
					    },
					    new JMenuItem {
						String text = "Solve the Puzzle";

						actionPerformed(e) {
						    invokeLater(&root.SolvePuzzle);
						}
					    },
					};
				    },
				    new JMenuItem  {
					String text = "Cell DnD";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_CELLDND);
					}
				    },
				    new JMenuItem  {
					String text = "Cell Copy";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_CELLCOPY);
					}
				    },
				    NULL,
				    new JMenuItem  {
					String text = "Select Cell";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_SELECTCELL);
					}
				    },
				    new JMenuItem  {
					String text = "Move Cell";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_MOVECELL);
					}
				    },
				    new JMenuItem {
					String text = "Return Cell";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_RETURNCELL);
					}
				    },
				    NULL,
				    new JMenuItem {
		                	String text = "Mark Chart";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_MARKCHART);
					}
				    },
				    new JMenuItem {
		                	String text = "Mark Cell";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_MARKCELL);
					}
				    },
				    new JMenuItem  {
					String text = "Erase Mark";

					actionPerformed(e) {
					    root.ShiftOperation(e, MOUSE_ERASEMARK);
					}
				    },
				    NULL,
				    new JMenuItem  {
					String text = "Erase All Chart Marks";

					actionPerformed(e) {
					    invokeLater(&root.EraseChartMarks);
					}
				    },
				    new JMenuItem  {
					String text = "Erase All Cell Marks";

					actionPerformed(e) {
					    invokeLater(&root.EraseCellMarks);
					}
				    },
				    NULL,
				    new JMenuItem  {
					String text = "Return All Cells";
					String tag = "$_return_all_cells";

					actionPerformed(e) {
					    invokeLater(&root.ReturnAllCells);
					}
				    },
				};
			    };

			    paint(Rectangle rect) {
				if (root.activechart && !root.glasspane.visible)
				    root.activechart.PaintRect(rect, FALSE, graphics);
			    }

			    ////////////////////////////
			    //
			    // Event Handlers
			    //
			    ////////////////////////////

			    Function dragGestureRecognized = DragGestureRecognized;

			    componentResized(e) {
				if (size.width > 1 && size.height > 1) {	// just to be safe
				    if (root.activechart)
					SyncMatrix();
				    lastsize = size;
				}
			    }

			    dragDropEnd(e) {
				//
				// Need this to substitute for mouseReleased() once a drag
				// is started because mouseReleased() won't be called.
				//

				dragtext = NULL;
				StartOperation(MOUSE_AVAILABLE);
			    }

			    mouseDragged(e) {
				double dx;
				double dy;

				switch (mouse) {
				    case MOUSE_CELLCOPY:
				    case MOUSE_RETURNCELL:
				    case MOUSE_SELECTCELL:
					if (pressedcell != NULL) {
					    if (root.activechart.PickCellAt(e.coordinates) == pressedcell) {
						if (!pressedcell.state) {
						    pressedcell.state = 1;
						    root.PaintCell(pressedcell);
						}
					    } else {
						if (pressedcell.state) {
						    pressedcell.state = 0;
						    root.PaintCell(pressedcell);
						}
					    }
					}
					break;

				    case MOUSE_MARKCELL:
				    case MOUSE_MARKCHART:
					if (nextmark) {
					    nextmark[nextmark@sizeof] = e.coordinates.x;
					    nextmark[nextmark@sizeof] = e.coordinates.y;
					    graphics.lineto(e.coordinates.x, e.coordinates.y);
					    graphics.stroke(1.0, FALSE);
					}
					break;

				    case MOUSE_MOVECELL:
					if (pressedcell != NULL) {
					    if (pointInRect(e.coordinates, pressedcellhome) && !root.activechart.IsPuzzle()) {
						dx = pressedcellhome.x - pressedcell.bounds.x;
						dy = pressedcellhome.y - pressedcell.bounds.y;
						pressedpoint.x = pressedcellhome.x + pressedoffset.x;
						pressedpoint.y = pressedcellhome.y + pressedoffset.y;
					    } else {
						dx = e.coordinates.x - pressedpoint.x;
						dy = e.coordinates.y - pressedpoint.y;
						pressedpoint.x += dx;
						pressedpoint.y += dy;
					    }
					    graphics.rectmove(pressedcell.bounds, dx, dy);
					}
					break;
				}
			    }

			    mouseEntered(e) {
				root.SetTipText(e.coordinates);
			    }

			    mouseExited(e) {
				root.SetTipText();
			    }

			    mouseMoved(e) {
				root.SetTipText(e.coordinates);
			    }

			    mousePressed(e, ...) {
				Dictionary cell;
				Rectangle  interior = NULL;
				int        operation;

				//
				// We get a little tricky here to avoid obscure menu (popup
				// and pulldown) repaint issues that only happen when we're
				// supposed to mark a cell, a menu is partially covering the
				// canvas, and the user presses button 1 in this canvas but
				// outside the menu. The menu is dismissed and a paint event
				// is generated to refresh the part of the canvas that needs
				// it, but we take control and modify graphics so the user
				// can only draw on the pressed cell before the paint event
				// arrives. To get around the problem we always requeue this
				// call using invokeLater() if it's new event but we add an
				// argument to the next call so we know not to queue it again.
				//
				// NOTE - this approach forces us to handle mouseReleased()
				// in exactly the same way, otherwise we could end up in the
				// mouseReleased() event handler before mousePressed() really
				// gets called.
				//

				if (argc > 2) {
				    root.requestfocus = TRUE;
				    switch (operation = PickNextOperation(e)) {
					case MOUSE_CELLCOPY:
					case MOUSE_RETURNCELL:
					case MOUSE_SELECTCELL:
					    if ((pressedcell = root.activechart.PickCellAt(e.coordinates)) != NULL) {
						pressedpoint = e.coordinates;
						if (!pressedcell.state) {
						    StartOperation(operation);
						    pressedcell.state = 1;
						    root.PaintCell(pressedcell);
						}
					    }
					    break;

					case MOUSE_CELLDND:
					    if ((cell = root.activechart.PickCellAt(e.coordinates)) != NULL) {
						StartOperation(operation);
						dragtext = root.activechart.GetCellTextAt(cell, FALSE, e.coordinates);
					    }
					    break;

					case MOUSE_ERASEMARK:
					    StartOperation(operation);
					    break;

					case MOUSE_MARKCELL:
					    StartOperation(operation);
					    graphics.gsave();
					    graphics.foreground = foreground;
					    graphics.linewidth = LINEWIDTH;
					    graphics.linecap = CAP_BUTT;
					    graphics.linejoin = JOIN_ROUND;
					    if ((marking = root.activechart.PickCellAt(e.coordinates)) != NULL) {
						interior = root.activechart.GetCellInteriorBounds(marking);
						graphics.rectclip(interior);
						graphics.translate(interior.x, interior.y);
						nextmark = new Array[2, ...] {e.coordinates.x - interior.x, e.coordinates.y - interior.y};
						graphics.newpath();
						graphics.moveto(nextmark[0], nextmark[1]);
					    } else nextmark = NULL;
					    break;

					case MOUSE_MARKCHART:
					    StartOperation(operation);
					    graphics.gsave();
					    graphics.foreground = foreground;
					    graphics.linewidth = LINEWIDTH;
					    graphics.linecap = CAP_BUTT;
					    graphics.linejoin = JOIN_ROUND;
					    marking = root.activechart;
					    nextmark = new Array[2, ...] {e.coordinates.x, e.coordinates.y};
					    graphics.newpath();
					    graphics.moveto(nextmark[0], nextmark[1]);
					    break;

					case MOUSE_MOVECELL:
					    if ((pressedcell = root.activechart.PickMovableCellAt(e.coordinates)) != NULL) {
						StartOperation(operation);
						pressedpoint = e.coordinates;
						pressedcellhome = root.activechart.GetHomeBoundsForCell(pressedcell);
						pressedoffset = new Point {
						    double x = pressedpoint.x - pressedcell.bounds.x;
						    double y = pressedpoint.y - pressedcell.bounds.y;
						};
						root.activechart.StartMovingCell(pressedcell, root.activechart.IsPuzzle() ? NULL : root.background, graphics);
						root.PaintCell(pressedcell);
					    }
					    break;

					default:
					    ShowPopup(e);
					    break;
				    }
				    SyncCursor();
				} else invokeLater(&mousePressed, e, TRUE);
			    }

			    mouseReleased(e, ...) {
				double dx;
				double dy;

				//
				// We have to duplicate the mousePressed() approach described
				// above, otherwise there's a small chance we will be called
				// before the corresponding mouse pressed event is handled.
				//

				if (argc > 2) {
				    switch (mouse) {
					case MOUSE_CELLCOPY:
					case MOUSE_RETURNCELL:
					case MOUSE_SELECTCELL:
					    if (pressedcell != NULL && pressedcell.state) {
						pressedcell.state = 0;
						if (mouse == MOUSE_SELECTCELL) {
						    root.ToggleCellSelection(pressedcell);
						    if (root.activechart.AfterPressed != NULL)
							invokeLater(&root.activechart.AfterPressed, pressedcell, e);
						} else if (mouse == MOUSE_CELLCOPY)
						    root.activechart.CopyCellToClipboard(pressedcell);
						else if (mouse == MOUSE_RETURNCELL)
						    root.activechart.ReturnCell(pressedcell, TRUE, graphics);
						root.PaintCell(pressedcell);
					    }
					    break;

					case MOUSE_ERASEMARK:
					    EraseMarksNear(e.coordinates);
					    break;

					case MOUSE_MARKCELL:
					case MOUSE_MARKCHART:
					    if (nextmark@sizeof >= 4) {
						if ((e.modifiers & ALT_MASK) ^^ ARROW_MARKS)
						    AddArrowHead();
						root.activechart.AddMark(marking, nextmark, graphics.pathbbox(0, 2));	// pathbbox arguments are a kludge!!!
						graphics.newpath();
						root.activechart.PaintMarks(nextmark, graphics);
					    }
					    graphics.grestore();
					    break;

					case MOUSE_MOVECELL:
					    if (pressedcell != NULL) {
						root.activechart.StopMovingCell(graphics);
						if (!pointInRect(e.coordinates, pressedcellhome) || root.activechart.IsPuzzle()) {
						    root.activechart.SnapCellToGrid(pressedcell, e.coordinates, graphics);
						    root.PaintCell(pressedcell);
						} else root.activechart.ReturnCell(pressedcell, TRUE, graphics);
					    }
					    break;

					default:
					    ShowPopup(e);
					    break;
				    }
				    invokeLater(&root.SetTipText, e.coordinates);
				    pressedcell = NULL;
				    pressedpoint = NULL;
				    pressedoffset = NULL;
				    pressedcellhome = NULL;
				    nextmark = NULL;
				    marking = NULL;
				    dragtext = NULL;
				    StartOperation(PickNextOperation(e));
				} else invokeLater(&mouseReleased, e, TRUE);
			    }

			    mouseWheelMoved(e) {
                                //
                                // Part of some quickly written code that was designed to
                                // improve the zooming performance in big charts, like the
                                // unicode chart. Helps, but there's still plenty of room
                                // for improvement - definitely not a high priority.
                                //

				if (mouse == MOUSE_AVAILABLE) {
                                    if (wheelzoom_events == NULL)
                                        wheelzoom_events = new Array[0, ...];
                                    wheelzoom_events[wheelzoom_events@sizeof] = e;
                                    if (e.whennext == 0)
                                        invokeLater(&HandleWheelZoom, &wheelzoom_events);
                                }
			    }

			    ////////////////////////////
			    //
			    // Callback Functions
			    //
			    ////////////////////////////

			    afterPan(Object bbox_new, Object bbox_clean) {
				Dictionary chart;

				if (chart = root.activechart)
				    chart.PaintFloatingLabels(bbox_new, bbox_clean, graphics);
			    }

			    ////////////////////////////
			    //
			    // Miscellaneous Functions
			    //
			    ////////////////////////////


			    AddArrowHead() {
				Array  coords;
				double radius;
				double dx;
				double dy;
				double ds;
				double x;
				double y;
				double s;
				double tipx;
				double tipy;
				int    np;
				int    sz = nextmark@sizeof;

				radius = 0.25*min(root.activechart.rowheight, root.activechart.columnwidth);

				tipx = nextmark[sz - 2];
				tipy = nextmark[sz - 1];

				//
				// Probably wouldn't be too hard to improve this, but
				// it's good enough for now.
				// 

				for (np = 4; np < sz; np += 2) {
				    if (nextmark@sizeof > np) {
					dx = nextmark[sz-np] - tipx;
					dy = nextmark[sz-np+1] - tipy;
					ds = sqrt(dx*dx + dy*dy);
					if (ds > radius) {
					    if (s > 0) {
						ds = s;
						dx = x;
						dy = y;
					    }
					    break;
					} else {
					    x = dx;
					    y = dy;
					    s = ds;
					}
				    }
				}

				if ((ds = sqrt(dx*dx + dy*dy)) > 0) {
				    //
				    // We adjust the location of the tip slightly to
				    // account for line thickness. Using 0.75 is more
				    // than needed - 0.5 would be the mathematically
				    // correct factor.
				    //
				    tipx -= (0.75*LINEWIDTH*dx/ds)/root.activechart.ARROWEDGE_TAN;
				    tipy -= (0.75*LINEWIDTH*dy/ds)/root.activechart.ARROWEDGE_TAN;

				    coords = root.activechart.GetArrowHead(
					new Point {
					    double x = tipx + dx;
					    double y = tipy + dy;
					},
					new Point {
					    double x = tipx;
					    double y = tipy;
					},
					radius,
					0
				    );

				    if (coords) {
					//
					// Notice that we continue adding the points to
					// the path for our bounding box calculation, but
					// we let low level chart code handle the drawing
					// because there now are two parts.
					//
					nextmark[nextmark@sizeof] = NULL;
					nextmark[nextmark@sizeof] = "stroke";
					graphics.lineto(coords[0], coords[1]);
					nextmark[nextmark@sizeof] = coords[0];
					nextmark[nextmark@sizeof] = coords[1];
					graphics.lineto(coords[2], coords[3]);
					nextmark[nextmark@sizeof] = coords[2];
					nextmark[nextmark@sizeof] = coords[3];
					graphics.lineto(coords[4], coords[5]);
					nextmark[nextmark@sizeof] = coords[4];
					nextmark[nextmark@sizeof] = coords[5];
					graphics.lineto(coords[0], coords[1]);
					nextmark[nextmark@sizeof] = coords[0];
					nextmark[nextmark@sizeof] = coords[1];
					nextmark[nextmark@sizeof] = NULL;
					nextmark[nextmark@sizeof] = "fill";
				    }
				}
			    }

			    CheckChart() {
				root.activechart.CheckAllCells(graphics);
			    }

			    ClearMistakes() {
				//
				// Should activechart.ClearBadCellMarks() return a value,
				// like EraseCellMarks, that lets us skip painting? It's
				// a more difficult and really not a big deal, so we'll
				// leave things be for now.
				//
				root.activechart.ClearBadCellMarks();
				root.RepaintChart();
			    }

			    EraseCellMarks() {
				if (root.activechart.EraseCellMarks())
				    root.RepaintChart();
			    }

			    EraseChartMarks() {
				if (root.activechart.EraseChartMarks())
				    root.RepaintChart();
			    }

			    EraseMarksNear(Point point) {
				Dimension sides;

				//
				// We handle the minimum linewidth calculation so we don't
				// need to pass two matrices to EraseMarksNear(), but it's
				// questionable logic since the minimum linewidth that we
				// calculated is now one of the arguments??
				//

				sides = graphics.idtransform(5, 5);	// use 5 pixel minimum linewidth
				if (root.activechart.EraseMarksNear(point, defaultmatrix, sides.width))
				    root.RepaintChart();
			    }

			    GetScalingToFit(Rectangle rect) {
				Dimension dimension;
				double    scaling = 1.0;

				if (rect != NULL) {
				    dimension = MapSizeToCurrentData();
				    scaling = min(dimension.width/rect.width, dimension.height/rect.height);
				}
				return(scaling);
			    }

			    GetCellAnchor(Dictionary cell) {
				Rectangle bounds = cell.bounds;
				Point     point;

				switch (root.activechart.cellanchor) {
				    case NONE:
					point = root.GetCurrentPoint();
					break;

				    case TOPLEFT:
					point.x = bounds.x;
					point.y = bounds.y;
					break;

				    case TOP:
					point.x = bounds.x + bounds.width/2.0;
					point.y = bounds.y;
					break;

				    case TOPRIGHT:
					point.x = bounds.x + bounds.width;
					point.y = bounds.y;
					break;

				    case LEFT:
					point.x = bounds.x;
					point.y = bounds.y + bounds.height/2.0;
					break;

				    case CENTER:
				    default:
					point.x = bounds.x + bounds.width/2.0;
					point.y = bounds.y + bounds.height/2.0;
					break;

				    case RIGHT:
					point.x = bounds.x + bounds.width;
					point.y = bounds.y + bounds.height/2.0;
					break;

				    case BOTTOMLEFT:
					point.x = bounds.x;
					point.y = bounds.y + bounds.height;
					break;

				    case BOTTOM:
					point.x = bounds.x + bounds.width/2.0;
					point.y = bounds.y + bounds.height;
					break;

				    case BOTTOMRIGHT:
					point.x = bounds.x + bounds.width;
					point.y = bounds.y + bounds.height;
					break;
				}
				return(point);
			    }

			    GetScreenAnchor(...) {
				Dictionary chart = root.activechart;
				Rectangle  bounds;
				Insets     insets;
				double     dx;
				double     dy;
				Point      point;

				//
				// Assumes the argument, if supplied, is a rectangle in some
				// unspecified coordinate system, otherwise we calcuate the
				// anchor point for the entire canvas using screenanchorinsets
				// and screenanchoroffset to make adjustments to the answer.
				//

				if (argc == 1) {
				    bounds.width = this.size.width;
				    bounds.height = this.size.height;
				    if (chart.screenanchorinsets)
					insets = chart.screenanchorinsets;
				    if (chart.screenanchoroffset) {
					dx = root.activechart.screenanchoroffset.x;
					dy = root.activechart.screenanchoroffset.y;
				    }
				} else {
				    if (argv[1] instanceof Dimension) {
					bounds.width = argv[1].width;
					bounds.height = argv[1].height;
				    } else bounds = argv[1];
				}

				switch (chart.screenanchor) {
				    case TOPLEFT:
					point.x = bounds.x + insets.left + dx;
					point.y = bounds.y + insets.top + dy;
					break;

				    case TOP:
					point.x = bounds.x + bounds.width/2.0 + dx;
					point.y = bounds.y + insets.top + dy;
					break;

				    case TOPRIGHT:
					point.x = bounds.x + bounds.width - insets.right + dx;
					point.y = bounds.y + insets.top + dy;
					break;

				    case LEFT:
					point.x = bounds.x + insets.left + dx;
					point.y = bounds.y + bounds.height/2.0 + dy;
					break;

				    case CENTER:
				    default:
					point.x = bounds.x + bounds.width/2.0 + dx;
					point.y = bounds.y + bounds.height/2.0 + dy;
					break;

				    case RIGHT:
					point.x = bounds.x + bounds.width - insets.right + dx;
					point.y = bounds.y + bounds.height/2.0 + dy;
					break;

				    case BOTTOMLEFT:
					point.x = bounds.x + insets.left + dx;
					point.y = bounds.y + bounds.height - insets.bottom + dy;
					break;

				    case BOTTOM:
					point.x = bounds.x + bounds.width/2.0 + dx;
					point.y = bounds.y + bounds.height - insets.bottom + dy;
					break;

				    case BOTTOMRIGHT:
					point.x = bounds.x + bounds.width - insets.right + dx;
					point.y = bounds.y + bounds.height - insets.bottom + dy;
					break;
				}
				return(point);
			    }

			    GetScreenAnchorInCurrentData(...) {
				Point point = GetScreenAnchor(unroll(&argv[1]));

				return(ScreenPointToCurrentData(point.x, point.y));
			    }

			    GetScreenAnchorInDefaultData(...) {
				Point point = GetScreenAnchor(unroll(&argv[1]));

				return(ScreenPointToDefaultData(point.x, point.y));
			    }

			    HandlePanBy(double dx, double dy, int maxsteps) {
				Object point = origin;
				double x0;
				double y0;
				double dt;
				double t;
				int    steps;
                                int    n;

				if (maxsteps > 1 && (steps = ceil(sqrt(dx*dx + dy*dy)/(0.5*root.activechart.celldiagonal))) > 0) {
				    steps = min(steps, maxsteps);
				    dt = 1.0/steps;
				    x0 = point.x;
				    y0 = point.y;
				    for (n = 1; n <= steps; n++) {
					t = n*dt;
					point.x = t*dx + x0;
					point.y = t*dy + y0;
					origin = point;
				    }
				} else {
				    point.x += dx;
				    point.y += dy;
				    origin = point;
				}
			    }

			    HandleTranslateCellTo(Dictionary cell, Dictionary lastcell, int maxsteps) {
				Point screenanchor = GetScreenAnchorInCurrentData();
				Point cellanchor = GetCellAnchor(cell);
				Point p1 = NULL;
				Point p2 = NULL;

				if (lastcell != NULL && root.activechart.cellanchor != NONE) {
				    if (root.activechart.fuzzyanchor && pointInRect(screenanchor, lastcell.bounds)) {
					p1 = graphics.maptopixel(cell.bounds.x, cell.bounds.y);
					p2 = graphics.maptopixel(lastcell.bounds.x, lastcell.bounds.y);
				    } else {
					p1 = graphics.maptopixel(cellanchor.x, cellanchor.y);
					p2 = graphics.maptopixel(screenanchor.x, screenanchor.y);
				    }
				} else {
				    p1 = graphics.maptopixel(cellanchor.x, cellanchor.y);
				    p2 = graphics.maptopixel(screenanchor.x, screenanchor.y);
				}

				root.PanBy(p1.x - p2.x, p1.y - p2.y, maxsteps);
				root.PaintCell(cell);
			    }

			    HandleTranslatePointTo(...) {
				Point point = (argc > 1 && argv[1]) ? argv[1] : GetScreenAnchor(root.activechart.boundingbox);
				Point dest = (argc > 2 && argv[2]) ? argv[2] : GetScreenAnchorInCurrentData();

				graphics.translate(dest.x - point.x, dest.y - point.y);
				root.RepaintChart();
			    }

                            HandleWheelZoom(Pointer pointer) {
                                MouseWheelEvent event;
                                Array           events;

                                //
                                // Part of some quickly written code that was designed to
                                // improve the zooming performance in big charts, like the
                                // unicode chart. Helps, but there's still plenty of room
                                // for improvement - definitely not a high priority.
                                //

                                if (pointer != NULL) {
                                    if ((events = *pointer) != NULL) {
                                        *pointer = NULL;
                                        event = NULL;
                                        for (ptr in &events[events@sizeof - 1] by -1) {
                                            if (event != NULL)
                                                event.unitstoscroll += ptr[0].unitstoscroll;
                                            else event = ptr[0];
                                            *ptr = NULL;
                                        }

                                        if (event != NULL) {
                                            if (mouse == MOUSE_AVAILABLE)
                                                root.ZoomTo(root.components.$_zoom_icon.sliderwindow.components.$_zoom_slider.PickNextScaling(event.unitstoscroll), event.coordinates);
                                        }
                                    }
                                }
                            }

			    HandleZoomTo(double scaling, ...) {
				Point lock = (argc > 2 && argv[2]) ? argv[2] : GetScreenAnchorInCurrentData();

				if ((scaling = max(root.minscaling, min(scaling, root.maxscaling))) != root.currentscaling) {
				    graphics {
					translate(lock.x, lock.y);
					CTM.sx = scaling*defaultmatrix.sx;
					CTM.sy = scaling*defaultmatrix.sy;
					translate(-lock.x, -lock.y);
					root.SetScaling(scaling);
				    }
				    root.RepaintChart();
				}
			    }

			    IsCellAnchored(Dictionary cell) {
				Rectangle rect;
				Dimension dimen = NULL;
				Point     point = NULL;
				Point     screenanchor  = NULL;
				int       result = FALSE;

				if (cell) {
				    point = GetCellAnchor(cell);
				    screenanchor = GetScreenAnchorInCurrentData();
				    dimen = ScreenSizeToCurrentData(2, 2);
				    rect.x = screenanchor.x - dimen.width;
				    rect.y = screenanchor.y - dimen.height;
				    rect.width = 2*dimen.width;
				    rect.height = 2*dimen.height;
				}
				return(pointInRect(point, rect));
			    }

			    MapAdjustedSizeToCurrentData(double dx, double dy) = ScreenSizeToCurrentData(size.width - dx, size.height - dy);
			    MapSizeToCurrentData() = ScreenSizeToCurrentData(size.width, size.height);
			    MapSizeToDefaultData() = ScreenSizeToDefaultData(size.width, size.height);

			    PickNextOperation(MouseEvent e) {
				int operation = MOUSE_AVAILABLE;

				if (!e.popuptrigger) {
				    if (e.id == yoix.event.HandlerID.mousePressed) {
					if (e.modifiersdown&BUTTON1_DOWN_MASK) {
					    operation = root.GetPrimaryOperation();
					    switch (mouse) {
						case MOUSE_AVAILABLE:
						    if (e.modifiersdown&SHIFT_DOWN_MASK)
							operation = MOUSE_MOVECELL;
						    else if (e.modifiersdown&CTRL_DOWN_MASK || (ISMAC && (e.modifiersdown & META_DOWN_MASK)))
							operation = MOUSE_SELECTCELL;
						    break;

						case MOUSE_ERASEMARK:
						case MOUSE_MARKCELL:
						case MOUSE_MARKCHART:
						    operation = mouse;
						    break;
					    }
					}
				    } else if (e.id == yoix.event.HandlerID.mouseReleased) {
					if (e.modifiersdown&CTRL_DOWN_MASK || (ISMAC && (e.modifiersdown & META_DOWN_MASK))) {
					    switch (mouse) {
						case MOUSE_CELLCOPY:
						case MOUSE_CELLDND:
						case MOUSE_ERASEMARK:
						case MOUSE_MARKCELL:
						case MOUSE_MARKCHART:
						case MOUSE_RETURNCELL:
						    operation = mouse;
						    break;
					    }
					}
				    }
				}
				return(operation);
			    }

			    RestoreState(Object arg) {
				Dictionary chart = root.activechart;
				Dimension  cellsize = NULL;
				Matrix     matrix = NULL;
				double     scaling;

				if ((defaultmatrix = chart.GetDefaultMatrix(size, 1.0)) != NULL) {
				    if (arg != NULL) {
					scaling = arg.scaling;
					root.lastscaling = arg.lastscaling;
					matrix = chart.GetAdjustedMatrix(size, scaling, arg.lock);
				    } else {
					scaling = 1.0;
					root.lastscaling = 1.0;
					matrix = defaultmatrix;
				    }
				    if (chart.IsPuzzle()) {
					popup.components.$_puzzle.text = chart.chartmodel;
					popup.components.$_return_all_cells.visible = FALSE;
					popup.components.$_autocheck.state = chart.autocheck;
					popup.components.$_puzzle.visible = TRUE;
				    } else {
					popup.components.$_return_all_cells.visible = TRUE;
					popup.components.$_puzzle.visible = FALSE;
				    }
				    graphics.setmatrix(matrix);
				    chart.LayoutChartLabels(root.selected_chart_labels);
				    root.SetScalingBounds(chart.GetCellSize(defaultmatrix));
				    root.SetScaling(scaling);
				    if (arg == NULL)
					root.ZoomToInitialBounds();
				    root.RepaintChart();
				}
			    }

			    ReturnAllCells() {
				root.activechart.ReturnAllCells(TRUE, graphics);
			    }

			    SaveState() {
				return(new Dictionary {
				    double scaling = root.currentscaling;
				    double lastscaling = root.lastscaling;
				    //
				    // In this case we don't want the calculation of
				    // the point to include the insets or offsets that
				    // are used if we don't supply an argument.
				    // 
				    Point  lock = GetScreenAnchorInCurrentData(size);
				});
			    }

			    ScatterAllCells() {
				root.activechart.ScatterAllCells(graphics);
			    }

			    ScreenPointToCurrentData(double x, double y) = graphics.itransform(screenmatrix.transform(x, y));
			    ScreenPointToDefaultData(double x, double y) = defaultmatrix.itransform(screenmatrix.transform(x, y));
			    ScreenSizeToCurrentData(double width, double height) = graphics.idtransform(screenmatrix.dtransform(width, height));
			    ScreenSizeToDefaultData(double width, double height) = defaultmatrix.idtransform(screenmatrix.dtransform(width, height));

			    SetAutoCheck(int state) {
				root.activechart.autocheck = state;
			    }

			    ShiftOperation(ActionEvent e, int operation) {
				//
				// Decided that the cursor should be explicity
				// set to the HAND_CURSOR whenever we start a
				// "temporary" operation.
				//
				if ((e.modifiers&SHIFT_MASK) != SHIFT_MASK) {
				    StartOperation(operation);
				    cursor = Cursor.HAND_CURSOR;
				} else root.SetPrimaryOperation(operation);
			    }

			    ShowPopup(MouseEvent e) {
				if (e.popuptrigger && e.pressed <= 1) {
				    popup.location = e.location;
				    popup.visible = TRUE;
				}
			    }

			    SolvePuzzle() {
				root.activechart.ReturnAllCells(FALSE, graphics);
			    }

			    StartOperation(int operation) {
				if (mouse != operation) {
				    if (mouse == MOUSE_AVAILABLE || operation == MOUSE_AVAILABLE) {
					if (mouse == MOUSE_AVAILABLE) {
					    root.SavePrimaryOperation();
					    root.SetPrimaryOperation(operation);
					} else root.SyncPrimaryOperation();
					mouse = operation;
					SyncCursor();
					SyncPanAndZoom();
				    }
				}
			    }

			    SyncCursor() {
				switch (mouse) {
				    case MOUSE_CELLCOPY:
				    case MOUSE_CELLDND:
				    case MOUSE_ERASEMARK:
				    case MOUSE_MARKCELL:
				    case MOUSE_MARKCHART:
				    case MOUSE_RETURNCELL:
					cursor = Cursor.HAND_CURSOR;
					break;

				    case MOUSE_MOVECELL:
					cursor = Cursor.MOVE_CURSOR;
					break;

				    default:
					cursor = Cursor.STANDARD_CURSOR;
					break;
				}
			    }

			    SyncMatrix() {
				//
				// Right now this is only used when our size changes, but
				// it may be needed if we let the user pick screenanchor.
				//

				if ((defaultmatrix = root.activechart.GetDefaultMatrix(size, 1.0)) != NULL) {
				    if (lastsize) {
					graphics.setmatrix(
					    root.activechart.GetAdjustedMatrix(
						size,
						root.currentscaling,
						GetScreenAnchorInCurrentData(lastsize)
					    )
					);
					SyncScaling();
					root.RepaintChart();
				    }
				}
			    }

			    SyncPanAndZoom() {
				switch (root.GetPrimaryOperation()) {
				    case MOUSE_CELLCOPY:
				    case MOUSE_CELLDND:
				    case MOUSE_ERASEMARK:
				    case MOUSE_MARKCELL:
				    case MOUSE_MARKCHART:
				    case MOUSE_MOVECELL:
				    case MOUSE_RETURNCELL:
				    case MOUSE_SELECTCELL:
					panandzoom &= ~0x01;
					break;

				    default:
					panandzoom |= 0x01;
					break;
				}
			    }

			    SyncScaling() {
				root.activechart.SyncMinimumSizes(graphics);
			    }

			    SyncState() {
				RestoreState(SaveState());
			    }
			},
			BOTH, REMAINDER,

			//
			// We use a separator rather than numeric padding because
			// we want to make sure the user will see something. With
			// padding we would allocate space but (as things stand)
			// that space would inherit its background color from the
			// $_chart_panel. Using JSeparator implicity assumes it's
			// painted using its background and foreground colors, so
			// something will be visible to the user. That assumption
			// can be validated by looking at the Swing plaf code for
			// the JSeparator and we trust other look and feels will
			// do something similiar.
			//

			new JSeparator {
			    int orientation = HORIZONTAL;	// unnecessary - it's the default
			},
			HORIZONTAL, REMAINDER,

			new JPanel {
			    String tag = "$_tip_panel";

			    GridBagLayout layoutmanager;
			    Array layout = {
				new JLabel {
				    String tag = "$_status_label";
				    int    alignment = CENTER;
				    int    enabled = TRUE;

				    RestoreState(Object arg) {
					SetStatus(root.activechart);
				    }

				    SetStatus(Dictionary chart) {
					String status = chart ? chart.GetChartStatus() : NULL;
					String model = chart ? chart.chartmodel : NULL;

					if (model === root.activemodel) {
					    text = status;
					    visible = (status != NULL);
					}
				    }
				},
				new Dictionary {
				    int gridx = 1;
				    int gridy = 1;
				    int weightx = 1;
				},

				new JLabel {
				    String tag = "$_celltip_label";
				    int    alignment = LEFT;

				    Function dragGestureRecognized = DragGestureRecognized;
				},
				LEFT,

				new JPanel {
				    String tag = "$_colortip_panel";

				    GridBagLayout layoutmanager = {
					double hgap = 72.0/32;
				    };
				    Array layout = {
					new JLabel {
					    String tag = "$_colortip_label";
					    int    alignment = RIGHT;

					    Function dragGestureRecognized = DragGestureRecognized;
					},
					BOTH,
					new JCanvas {
					    String tag = "$_colortip_color";
					    Dimension preferredsize = {
						double width = 72.0/8;
					    };
					},
					BOTH,
				    };
				},
				RIGHT,
			    };
			},
			HORIZONTAL, REMAINDER,
		    };
		},

		new JTextPane {
		    String tag = "$_cell_detail";
		    Object transferhandler = NULL;		// required for custom drag and drop
		    double insets = 72.0/8;
		    Color  background = TEXT_BACKGROUND;
		    Color  foreground = TEXT_FOREGROUND;
		    int    mode = 1;				// 1=HTML; 0=plain; -1=RTF
		    int    caretmodel = 1;
		    int    edit = FALSE;
		    int    scroll = AS_NEEDED;

		    Dimension preferredsize = {
			double width = 3.0*72;
		    };

		    Dictionary currentcell;

		    Function dragGestureRecognized = DragGestureRecognized;
		    Function keyPressed = KeyPressed;

		    componentResized(e) {
			SyncSelected();
		    }

		    ChooseInitialPreferredSize(double width) {
			preferredsize = new Dimension {
			    double width = min(width, root.size.width/4);
			};
		    }

		    RestoreState(Object arg) {
			//
			// Right now nothing's really required, but there's
			// a good chance that in the future different charts
			// will be want to present different information here.
			//

			SyncSelected();
		    }

		    SyncSelected() {
			Dictionary cell;
			String     detail;

			//
			// The dividerlocation test below makes sure we're really
			// showing, but essentially assumes we're using a version
			// of the JSplitPane that returns a number between 0 and 1
			// inclusive when we read dividerlocation. That wasn't the
			// case in versions older that 5/8/08.
			//

			if (root.activechart && root.components.$_chart_splitpane.dividerlocation < 1.0) {		// we're showing
			    if ((cell = root.GetCurrentCell()) != currentcell) {
				if (cell != NULL) {
				    detail = root.activechart.GetCellDetail(cell);
				    //
				    // Eventually might check return value to see if it's
				    // HTML or not and adjust our behavior accordingly,
				    // but for now we don't bother.
				    //
				    text = detail;
				    caret = 0;
				} else text = NULL;
				currentcell = cell;
			    }
			} else {
			    text = NULL;
			    currentcell = NULL;
			}
		    }
		},
	    };

	    ClearChart() {
		root.components.$_chart_canvas.graphics.erasedrawable();
		root.components.$_celltip_label.text = NULL;
		root.components.$_colortip_label.text = NULL;
		root.components.$_colortip_color.background = root.components.$_colortip_panel.background;
		root.components.$_cell_detail.text = NULL;
	    }

	    RestoreState(Object arg) {
		if (root.activechart) {
		    if (arg == NULL) {
			switch (root.activechart.GetCellDetailDividerModel()) {
			    case 0:
				break;

			    case 1:
				if (dividerlocation == 1.0) {
				    if (lastsaveddivider < 1.0)
					dividerlocation = lastsaveddivider;
				    else dividerlocation = -1.0;
				}
				break;

			    case 2:
				if (dividerlocation != 1.0)
				    dividerlocation = 1.0;
				break;
			}
		    } else {
			switch (root.activechart.GetCellDetailDividerModel()) {
			    case 0:
				 break;

			    case 1:
			    case 2:
				if (arg.dividerlocation == 1.0) {	// wasn't showing
				    if (dividerlocation < 1.0)
					dividerlocation = 1.0;
				} else {
				    if (dividerlocation == 1.0) {
					if (lastsaveddivider < 1.0)
					    dividerlocation = lastsaveddivider;
					else dividerlocation = arg.dividerlocation;
				    }
				}
				break;
			}
		    }
		}
	    }

	    SaveState() {
		if (dividerlocation < 1.0)
		    lastsaveddivider = dividerlocation;
		return(new Dictionary {
		    double dividerlocation = dividerlocation;
		});
	    }
	},
	BOTH, REMAINDER,

	new JPanel {
	    String tag = "$_find_panel";
	    int    visible = TRUE;

	    GridBagLayout layoutmanager = {
		double hgap = 72.0/32;
	    };
	    Array layout = {
		new JButton {
		    String tooltiptext = "Hide the find panel";
		    double insets = 0;
		    Image  icon = BuildControlIcon('x', 72.0/5, 72.0/5, Color.black);

		    actionPerformed(e) {
			root.SetFindPanelVisibility(FALSE);
		    }
		},
		NONE,
		new JTextField {
		    String tag = "$_find_pattern";
		    String tooltiptext = "Find this text";
		    int    columns = 15;

		    actionPerformed(e) {
			root.SetNextMatchingCell(1);
		    }

		    keyPressed(e) {
			foreground = root.foreground;
			root.keyPressed(e);
		    }
		},
		BOTH, LEFT,
		new JButton {
		    String tooltiptext = "Find next occurrence";
		    double insets = 0;
		    Image  icon = BuildControlIcon('v', 72.0/5, 72.0/5, Color.black);

		    actionPerformed(e) {
			root.SetNextMatchingCell(1);
			root.components.$_find_pattern.requestfocus = TRUE;
		    }

		    mouseWheelMoved(e) {
			root.SetNextMatchingCell(e.wheelrotation);
		    }
		},
		NONE,
		new JButton {
		    String tooltiptext = "Find previous occurrence";
		    double insets = 0;
		    Image  icon = BuildControlIcon('^', 72.0/5, 72.0/5, Color.black);

		    actionPerformed(e) {
			root.SetNextMatchingCell(-1);
			root.components.$_find_pattern.requestfocus = TRUE;
		    }

		    mouseWheelMoved(e) {
			//
			// We're currently ignoring arrow direction, which is what we
			// do with the arrow selection buttons. Really not convinced
			// either way - a negative sign is all that it would take to
			// change the behavior.
			//

			root.SetNextMatchingCell(e.wheelrotation);
		    }
		},
		NONE,
		new JCheckBox {
		    String tag = "$_find_match_case";
		    String text = "Match Case";

		    actionPerformed(e) {
			root.components.$_find_pattern.requestfocus = TRUE;
		    }
		},
		NONE,
	    };

	    ////////////////////////////
	    //
	    // Event Handlers
	    //
	    ////////////////////////////

	    componentHidden(e) {
		root.requestfocus = TRUE;
	    }

	    componentShown(e) {
		root.components.$_find_pattern.requestfocus = TRUE;
	    }

	    ////////////////////////////
	    //
	    // Miscellaneous Functions
	    //
	    ////////////////////////////

	    GetIgnoreCase() {
		return(!root.components.$_find_match_case.state);
	    }

	    GetPattern() {
		return(root.components.$_find_pattern.text);
	    }

	    GetPatternType() {
		//
		// We eventually may support regular expression matching.
		//
		return(0);
	    }

	    PatternNotFound() {
		root.components.$_find_pattern.foreground = Color.red;
	    }

	    SetVisible(int state) {
		visible = state;
		root.menubar.components.$_showfind.state = state;
	    }

	    ToggleVisible() {
		SetVisible(!visible);
	    }
	},
	HORIZONTAL, REMAINDER,

	72.0/16,

	new JPanel {
	    GridBagLayout layoutmanager;
	    Array layout = {
		new JPanel {
		    GridBagLayout layoutmanager = {
			double hgap = 72.0/32;
		    };
		    Array layout = {
			new JPanel {
			    String tag = "$_zoom_panel";
			    GridBagLayout layoutmanager = {
				double hgap = 72.0/32;
			    };
			    Array layout = {
				new JLabel {
				    String tag = "$_zoom_label";
				    Color  foreground = Color.blue;
				    int    alignment = RIGHT;
				    int    flags = 0;

				    Dimension preferredsize = GetScreenFont().stringsize("9999.99");

				    mouseEntered(e) {
					if (flags) {
					    foreground = Color.magenta;
					    flags |= 0x01;
					}
				    }

				    mouseExited(e) {
					if (flags) {
					    foreground = Color.blue;
					    flags &= ~0x01;
					}
				    }

				    mousePressed(e) {
					foreground = Color.magenta;
					flags = 0x03;
				    }

				    mouseReleased(e) {
					if (flags&0x01) {
					    if ((e.modifiers & BUTTON1_MASK) == 0)
						root.ToggleAnchored();
					    else root.ToggleZoom();
					}
					flags = 0;
					foreground = Color.blue;
				    }

				    mouseWheelMoved(e) {
                                        postEvent(e, root.components.$_zoom_icon.sliderwindow.components.$_zoom_slider);
				    }

				    ClearChart() {
					text = NULL;
				    }

				    SyncScaling() {
					text = strfmt("%.2f", root.currentscaling);
				    }
				},
				NONE,

				new JLabel {
				    String tag = "$_zoom_icon";
				    Image  icon = GetMagnifierIcon();

				    JWindow sliderwindow = {
					Dimension size = NULL;
					Object    parent = NULL;
					int       resizable = FALSE;
					int       opaque = TRUE;
					Object    mainroot = NULL;

					BevelBorder border = {
					    int raised = TRUE;
					};

					GridBagLayout layoutmanager = {
					    int columns = 1;
					};

					Array layout = {
					    new JSlider {
						String tag = "$_zoom_slider";
						int    orientation = HORIZONTAL;
						int    minimum = 0;
						int    maximum = 200;
						int    value = 5;

						Dimension preferredsize = {
						    double width = 2.0*72.0;
						};

						double lastscale = 1.0;
						double startscale = 0.0;

						//
						// We use a line to pick scaling values at the
						// low end of the slider (up to line_cutoff[0])
						// and a quadratic after that. The two equations
						// join at the line_cutoff[] point and have the
						// same slope where they join. The quadratic also
						// passes through the (maximum, maxscaling) point.
						// The coefficients of the quadratic that meets
						// these requirements are:
						//
						//    A = ((y1 - y0) - m*(x1 - x0))/(x1 - x0)^2
						//    B = m - 2*A*x0
						//    C = y0 + A*x0^2 - m*x0
						//
						// Values have to be updated whenever maxscaling
						// or minscaling changes.
						//

						Array line_cutoff = {NaN, 2.0};		// (x0, y0)
						Array linear = {0.1, NaN};		// mx + b
						Array quadratic = {NaN, NaN, NaN};	// Ax^2 + Bx + C

						////////////////////////////
						//
						// Event Handlers
						//
						////////////////////////////

						mouseReleased(e) {
						    //
						    // Unusual, but this is occasionally needed.
						    //
						    root.visible = FALSE;
						}

						mouseWheelMoved(e) {
						    value -= e.unitstoscroll;
						}

						stateChanged(e) {
						    root.mainroot.ZoomTo(PickNextScaling(0));
						}

						////////////////////////////
						//
						// Miscellaneous Functions
						//
						////////////////////////////

						GetScalingFor(double x) {
						    double y;

						    if (x > line_cutoff[0])
							y = quadratic[0]*x*x + quadratic[1]*x + quadratic[2];
						    else y = linear[0]*x + linear[1];
						    return(max(root.mainroot.minscaling, min(y, root.mainroot.maxscaling)));
						}

						GetValueFor(double y) {
						    double x;

						    if (y > line_cutoff[1])
							x = (-quadratic[1] + sqrt(quadratic[1]*quadratic[1] - 4*quadratic[0]*(quadratic[2] - y)))/(2*quadratic[0]);
						    else x = (y - linear[1])/linear[0];
						    return(max(minimum, min(round(x), maximum)));
						}

						PickNextScaling(int rotation) {
						    return(GetScalingFor(max(minimum, min(value - rotation, maximum))));
						}

						SetZoomSliderControls() {
						    double dx;
						    double dy;

						    line_cutoff[0] = (line_cutoff[1] - root.mainroot.minscaling)/linear[0];

						    dx = maximum - line_cutoff[0];
						    dy = root.mainroot.maxscaling - line_cutoff[1];

						    linear[1] = root.mainroot.minscaling;
						    quadratic[0] = (dy - linear[0]*dx)/(dx*dx);
						    quadratic[1] = linear[0] - 2*quadratic[0]*line_cutoff[0];
						    quadratic[2] = line_cutoff[1] - linear[0]*line_cutoff[0] + quadratic[0]*line_cutoff[0]*line_cutoff[0];
						}

						SyncScaling() {
						    value = GetValueFor(root.mainroot.currentscaling);
						}
					    },
					    BOTH,
					};
				    };

				    ////////////////////////////
				    //
				    // Event Handlers
				    //
				    ////////////////////////////

				    JSlider slider = sliderwindow.components.$_zoom_slider;
				    Point pt;
				    Point poff = {
					int x = 2;
					int y = slider.size.height - 8;
				    };
				    double xbeg = slider.size.height/2;
				    double xend = slider.size.width - xbeg;
				    double xpos;
				    double xoff;
				    double pcnt;

				    mousePressed(e) {
					if (e.modifiers & BUTTON1_MASK) {
					    xoff = e.location.x;
					    pt = getLocationOnScreen(this);
					    pt.x += e.location.x - poff.x;
					    pt.y += e.location.y - poff.y;
					    sliderwindow.location = pt;
					    sliderwindow.visible = TRUE;
					    pcnt = (double)(slider.value - slider.minimum)/(double)(slider.maximum - slider.extent - slider.minimum);
					    xpos = xbeg + pcnt * (xend - xbeg);
					    toFront(sliderwindow);
					    slider.requestfocus = TRUE;
					}
				    }

				    mouseDragged(e) {
					int    x = e.coordinates.x - xoff + poff.x;
					double p;

					if (sliderwindow.visible) {
					    toFront(sliderwindow);	// Java 1.4.2 needs this
					    if (x > xpos) {
						xpos = 0;
						p = (x - xbeg)/(xend - xbeg);
						if (p < 0)
						    p = 0;
						else if (p > 1)
						    p = 1;
						slider.value = iround(p * (double)(slider.maximum - slider.extent - slider.minimum)) + slider.minimum;
					    }
					}
				    }

				    mouseReleased(e) {
					sliderwindow.visible = FALSE;
				    }

				    mouseWheelMoved(e) {
                                        postEvent(e, sliderwindow.components.$_zoom_slider);
				    }
				},
				NONE,
			    };

			    ////////////////////////////
			    //
			    // Event Handlers
			    //
			    ////////////////////////////

			    mouseWheelMoved(e) {
                                postEvent(e, root.components.$_zoom_icon.sliderwindow.components.$_zoom_slider);
			    }
			},
			BOTH,

			72.0/16,

			new JPanel {
			    //
			    // This is an important panel, but unfortunately the code is rather
			    // confusing, particularly in the way it's "hooked up to" the chart,
			    // so there's definitely lots of room for improvement.
			    //

			    String tag = "$_selector_panel";

			    Dictionary currentcell = NULL;
			    int        anchoring = TRUE;

			    //
			    // We set handlestatechanged to FALSE right before we make changes
			    // to the selectors that we don't want handled by itemStateChanged()
			    // event handlers. Using the endabled field that's defined in all
			    // Swing components is simpler but we didn't want to risk changes
			    // to the visual appearance of components that usually accompanies
			    // changes to enabled.
			    //

			    int handlestatechanged = TRUE;

			    //
			    // These are the tag names of the JChoices that users can change
			    // when they want to focus in on a particular chart cell. There
			    // currently are four, but all you can add more as long as you
			    // update the tag names stored in the selectors array.
			    //

			    Array selectors = {"$_selector1", "$_selector2", "$_selector3", "$_selector4"};

			    GridBagLayout layoutmanager = {
				double hgap = 72.0/32;
			    };

			    Array layout = {
				NewSelector("$_selector1", 0),
				NONE,
				NewSelector("$_selector2", 1),
				NONE,
				NewSelector("$_selector3", 2),
				NONE,
				NewSelector("$_selector4", 3),
				NONE,
			    };

			    ////////////////////////////
			    //
			    // Miscellaneous Functions
			    //
			    ////////////////////////////

			    ClearChart() {
				int n;

				currentcell = NULL;
				for (n = 0; n < selectors@sizeof; n++)
				    root.components[selectors[n]].visible = FALSE;
			    }

			    ClearSelection() {
				Array selection[0, ...];
				save  anchoring = FALSE;

				for (ptr in selectors)
				    selection[selection@sizeof] = 0;
				SetNextSelection(selection);
			    }

			    GetCurrentCell() {
				Array args[2*selectors@sizeof];
				int   index = 0;

				for (ptr in selectors) {
				    args[index++] = root.components[ptr[0]].currentlabels;
				    args[index++] = root.components[ptr[0]].selectedindex;
				}
				return(root.activechart.GetSelectionAsCell(unroll(args)));
			    }

			    GetCurrentPoint() {
				Array args[2*selectors@sizeof];
				int   index = 0;

				for (ptr in selectors) {
				    args[index++] = root.components[ptr[0]].currentlabels;
				    args[index++] = root.components[ptr[0]].selectedindex;
				}
				return(root.activechart.GetSelectionAsPoint(unroll(args)));
			    }

			    GetCurrentSelection() {
				Array selection[selectors@sizeof];
				int   n;

				for (n = 0; n < selectors@sizeof; n++)
				    selection[n] = root.components[selectors[n]].selectedindex;
				return(selection);
			    }

			    GetNextCell(int selector, int direction) {
				Dictionary cell;
				Array      selection;
				Array      args[selectors@sizeof];
				int        index;
				int        n;

				if (selector >= 0 && selector < selectors@sizeof) {
				    args = new Array[selectors@sizeof];
				    for (n < 0; n < args@sizeof; n++)
					args[n] = (n == selector) ? direction : 0;
				    selection = GetSelectionForRotation(unroll(args));
				    args = new Array[2*selectors@sizeof];
				    for (n = 0, index = 0; n < selectors@sizeof; n++) {
					args[index++] = root.components[selectors[n]].currentlabels;
					args[index++] = (n < selection@sizeof && selection[n] >= 0) ? selection[n] : 0;
				    }
				    cell = root.activechart.GetSelectionAsCell(unroll(args));
				} else cell = GetCurrentCell();
				return(cell);
			    }

			    GetSelectionForCell(Dictionary cell) {
				Array args[2*selectors@sizeof + 1];
				int   index = 0;

				args[index++] = cell;
				for (ptr in selectors) {
				    args[index++] = root.components[ptr[0]].currentlabels;
				    args[index++] = root.components[ptr[0]].selectedindex;
				}
				return(root.activechart.GetSelectionForCell(unroll(args)));
			    }

			    GetSelectionForRotation(int direction, ...) {
				Array args[3*selectors@sizeof];
				int   n;

				for (n = 0; n < selectors@sizeof; n++) {
				    args[3*n] = root.components[selectors[n]].currentlabels;
				    args[3*n + 1] = root.components[selectors[n]].selectedindex;
				    args[3*n + 2] = (n+1 < argc) ? argv[n+1] : 0;
				}
				return(root.activechart.GetSelectionForRotation(unroll(args)));
			    }

			    HandleItemStateChanged(int state, int selector) {
				Dictionary cell;

				if (handlestatechanged) {
				    if (state) {
					ValidateSelectionBy(selector);
					cell = GetCurrentCell();
					invokeLater(&root.SyncSelectedCell, cell, state, anchoring, currentcell);
					if (cell)
					    currentcell = cell;
					anchoring = TRUE;
					root.SyncSelected(FALSE);
				    } else invokeLater(&root.SyncSelectedCell, currentcell, state, anchoring, NULL);
				}
			    }

			    HandleMouseWheelMoved(MouseWheelEvent e, int selector) {
				Dictionary cell;
				Dictionary lastselectable;
				Array      args[selectors@sizeof];
				int        direction;
				int        n;

				if (selector >= 0 && selector < selectors@sizeof) {
				    direction = e.wheelrotation;
				    if (e.modifiersdown&SHIFT_DOWN_MASK) {
					if ((cell = root.activechart.PickClosestMovedCell(GetCurrentCell(), direction)) != NULL) {
					    if ((lastselectable = root.activechart.MakeCellSelectable(cell)) != NULL) {
						root.PaintCell(lastselectable);
						ClearSelection();
					    }
					    SetNextCell(cell);
					}
				    } else {
					for (n = 0; n < selectors@sizeof; n++)
					    args[n] = (selector == n) ? direction : 0;
					SetNextSelection(GetSelectionForRotation(unroll(args)));
				    }
				}
			    }

			    LoadSelectors(...) {
				Dictionary cell = (argc > 1) ? argv[1] : GetCurrentCell();
				int        n;

				save anchoring = (cell == NULL);
				handlestatechanged = FALSE;
				ClearSelection();
				for (n = 0; n < selectors@sizeof; n++)
				    root.components[selectors[n]].LoadSelector();
				handlestatechanged = TRUE;
				SetNextSelection(GetSelectionForCell(cell));
			    }

			    RestoreState(Object arg) {
				Dictionary cell;

				if (arg != NULL) {
				    cell = SHARESELECTION ? GetCurrentCell() : arg.cell;
				    currentcell = arg.currentcell;
				} else {
				    cell = SHARESELECTION ? GetCurrentCell() : NULL;
				    currentcell = NULL;
				}
				if (!SHARESELECTION)
				    ClearSelection();
				LoadSelectors(cell);
			    }

			    SaveState() {
				return(new Dictionary {
				    Dictionary cell = GetCurrentCell();
				    Dictionary currentcell = currentcell;
				});
			    }

			    SetNextCell(Dictionary cell) {
				SetNextSelection(GetSelectionForCell(cell));
			    }

			    SetNextSelection(Array selection) {
				Object comp;
				int    firstchange = -1;
				int    n;

				//
				// Setting handlestatechanged the way we do here works because Java's
				// JComboBox implementation calls event handlers directly when the
				// current selection changes. Means the events don't end up in the
				// even queue, so we don't have to wait for those events to drain
				// before setting handlestatechanged back to TRUE and dealing with
				// the first one.
				//

				handlestatechanged = FALSE;
				for (n = 0; n < selectors@sizeof && n < selection@sizeof; n++) {
				    comp = root.components[selectors[n]];
				    if (comp.selectedindex != selection[n]) {
					if (firstchange < 0)
					    firstchange = n;
					else comp.selected = (selection[n] >= 0) ? selection[n] : 0;
				    }
				}
				handlestatechanged = TRUE;
				if (firstchange >= 0)
				    root.components[selectors[firstchange]].selected = selection[firstchange];
			    }

			    SyncSelection() {
				Dictionary cell;

				//
				// This was added for filtering and something like it is needed to
				// make sure the stuff displayed by the selectors is valid after we
				// "deselect" cells, however it's probably called whenever a filter
				// changes the visibility of some cells.
				//

				cell = GetCurrentCell();
				ValidateSelectionBy(0);
				if (GetCurrentCell() != cell)
				    ToggleCellSelection(cell);
			    }

			    ToggleCellSelection(Dictionary cell) {
				Dictionary lastselectable;

				if (cell != GetCurrentCell()) {
				    //
				    // This lets the chart handle internal housekeeping that should
				    // happen before we change the cell, but right now it really only
				    // matters when several cells share a name.
				    //
				    if ((lastselectable = root.activechart.MakeCellSelectable(cell)) != NULL) {
					root.PaintCell(lastselectable);
					ClearSelection();
				    }
				    anchoring = FALSE;
				    SetNextCell(cell);
				} else ClearSelection();
			    }

			    ValidateSelectionBy(int selector) {
				Object comp;
				Array  selection;
				Array  args[3*selectors@sizeof];
				int    n;

				for (n = 0; n < selectors@sizeof; n++) {
				    args[3*n] = root.components[selectors[n]].currentlabels;
				    args[3*n + 1] = root.components[selectors[n]].selectedindex;
				    args[3*n + 2] = (n == selector);
				}
				if ((selection = root.activechart.GetSelectionForStateChanged(unroll(args))) != NULL) {
				    handlestatechanged = FALSE;
				    for (n = 0; n < selectors@sizeof && n < selection@sizeof; n++) {
					comp = root.components[selectors[n]];
					if (comp.selectedindex != selection[n])
					    comp.selected = (selection[n] >= 0) ? selection[n] : 0;
				    }
				    handlestatechanged = TRUE;
				}
			    }
			},
			NONE,

			new JPanel {
			    String tag = "$_arrow_panel";
			    int    visible = FALSE;

			    //
			    // A simple thread that handles automatic panning that
			    // happens while the user presses and holds one of the
			    // arrow buttons.
			    //

			    Thread autopanner = {
				int daemon = TRUE;
				int persistent = TRUE;
				int priority = MIN_PRIORITY;
			    };

			    Dictionary nextcell;
			    double     initialdelay = 0.30;
			    double     delay = 0.10;
			    double     dx;
			    double     dy;
			    Point      p0;
			    Point      p1;
			    int        steps = 0;
			    int        count = 0;
			    int        started = FALSE;

			    GridBagLayout layoutmanager;
			    Array layout = {
				new JButton {
				    Image  icon = BuildControlIcon('^', 72.0/5, 72.0/5, Color.black);
				    double insets = 0;
				    int    flags = 0;		// bit0 = entered, bit1 = pressed

				    mouseEntered(e) {
					flags |= 0x01;
					if (flags&0x02)
					    root.components.$_arrow_panel.ResumePanning();
				    }

				    mouseExited(e) {
					flags &= ~0x01;
					if (flags&0x02)
					    root.components.$_arrow_panel.UndoPanning();
				    }

				    mousePressed(e) {
					if (!(flags&0x02)) {
					    flags |= 0x02;
					    root.components.$_arrow_panel.StartPanning(root.activechart.arrowdirection, e.modifiersdown&BUTTON1_DOWN_MASK);
					}
				    }

				    mouseReleased(e) {
					if (flags&0x02 && (e.modifiersdown&BUTTON_DOWN_MASK) == 0) {
					    flags &= ~0x02;
					    root.components.$_arrow_panel.StopPanning(flags&0x01);
					}
				    }

				    mouseWheelMoved(e) {
					root.components.$_selector_panel.HandleMouseWheelMoved(e, root.activechart.arrowselector);
				    }
				},

				72.0/32,

				new JButton {
				    Image  icon = BuildControlIcon('v', 72.0/5, 72.0/5, Color.black);
				    double insets = 0;
				    int    flags = 0;		// bit0 = entered, bit1 = pressed

				    mouseEntered(e) {
					flags |= 0x01;
					if (flags&0x02)
					    root.components.$_arrow_panel.ResumePanning();
				    }

				    mouseExited(e) {
					flags &= ~0x01;
					if (flags&0x02)
					    root.components.$_arrow_panel.UndoPanning();
				    }

				    mousePressed(e) {
					if (!(flags&0x02)) {
					    flags |= 0x02;
					    root.components.$_arrow_panel.StartPanning(-root.activechart.arrowdirection, e.modifiersdown&BUTTON1_DOWN_MASK);
					}
				    }

				    mouseReleased(e) {
					if (flags&0x02 && (e.modifiersdown&BUTTON_DOWN_MASK) == 0) {
					    flags &= ~0x02;
					    root.components.$_arrow_panel.StopPanning(flags&0x01);
					}
				    }

				    mouseWheelMoved(e) {
					root.components.$_selector_panel.HandleMouseWheelMoved(e, root.activechart.arrowselector);
				    }
				},
			    };

			    ClearChart() {
				visible = FALSE;
			    }

			    HandlePan() {
				Point anchor;

				if (started) {
				    if (count < steps) {
					count++;
					anchor = root.GetScreenAnchorInCurrentData();
					root.PanBy(p0.x + count*dx - anchor.x, p0.y + count*dy - anchor.y, 0);
					if (count < steps) {
					    autopanner.queue(sleep, delay);
					    autopanner.queue(invokeLater, &HandlePan);
					}
				    }
				}
			    }

			    RestoreState(Object arg) {
				visible = (root.activechart.arrowselector >= 0 && root.activechart.arrowdirection != 0);
			    }

			    ResumePanning() {
				if (steps > 0) {
				    started = TRUE;
				    autopanner.queue(sleep, initialdelay);
				    autopanner.queue(invokeLater, &HandlePan);
				}
			    }

			    StartPanning(int direction, int autopan) {
				Dictionary current = root.GetCurrentCell();
				Dictionary next = root.GetNextCell(root.activechart.arrowselector, direction);

				started = FALSE;
				steps = 0;

				if (next) {
				    if (current) {
					root.ShowSelectedCell(TRUE);
					root.AddTemporaryLink(root.activechart.arrowselector, direction);
					if (autopan) {
					    p0 = root.activechart.PickCellAnchor(current);
					    p1 = root.activechart.PickCellAnchor(next);
					    dx = p1.x - p0.x;
					    dy = p1.y - p0.y;
					    if ((steps = ceil(2.5*sqrt(dx*dx + dy*dy)/root.activechart.celldiagonal)) > 0) {
						dx /= steps;
						dy /= steps;
						count = 0;
						ResumePanning();
					    }
					}
				    }
				    nextcell = next;
				}
			    }

			    StopPanning(int entered) {
				Dictionary next = nextcell;

				started = FALSE;
				steps = 0;
				nextcell = NULL;
				autopanner.queue(NULL);
				autopanner.interrupted = TRUE;
				if (entered)
				    invokeLater(&root.SetNextCell, next);
				invokeLater(&root.RemoveTemporaryLink);
			    }

			    UndoPanning() {
				started = FALSE;
				autopanner.queue(NULL);
				autopanner.interrupted = TRUE;
				if (steps > 0 && count > 0) {
				    root.TranslatePointTo(p0);
				    count = 0;
				}
			    }
			},
			NONE,
		    };
		},
		new Dictionary {
		    int gridx = 1;
		    int gridy = 1;
		    int weightx = 1;
		},

		new JPanel {
		    String tag = "$_scrollbutton_panel";

		    //
		    // A thread that we use to manage queued sleeps and scrolling
		    // actions, which should always be handed to the event thread
		    // using invokeLater() when they get to the head of our queue.
		    //

		    Thread autoscroller = {
			int daemon = TRUE;
			int persistent = TRUE;
			int priority = MIN_PRIORITY;
		    };

		    double initialdelay = 0.30;
		    double delay = 0.10;
		    double dx;
		    double dy;
		    int    started = FALSE;

		    GridBagLayout layoutmanager;
		    Array layout = {
			new JButton {
			    Image  icon = BuildControlIcon('^', 72.0/9, 72.0/9, Color.black, 0.85);
			    double insets = 0;
			    double border = 0;
			    String tooltiptext = "Scroll up by half a row";

			    mousePressed(e) {
				root.requestfocus = TRUE;
				root.components.$_scrollbutton_panel.StartScrolling(0, 0.5);
			    }

			    mouseReleased(e) {
				root.components.$_scrollbutton_panel.StopScrolling();
			    }

			    mouseWheelMoved(e) {
				root.PanByCell(0, e.wheelrotation > 0 ? 0.5 : -0.5, 0);
			    }
			},
			new GridBagConstraints {
			    int gridx = 2;
			    int gridy = 1;
			},

			new JButton {
			    Image  icon = BuildControlIcon('<', 72.0/9, 72.0/9, Color.black, 0.85);
			    double insets = 0;
			    double border = 0;
			    String tooltiptext = "Scroll left by half a column";

			    mousePressed(e) {
				root.requestfocus = TRUE;
				root.components.$_scrollbutton_panel.StartScrolling(0.5, 0);
			    }

			    mouseReleased(e) {
				root.components.$_scrollbutton_panel.StopScrolling();
			    }

			    mouseWheelMoved(e) {
				root.PanByCell(e.wheelrotation > 0 ? -0.5 : 0.5, 0, 0);
			    }
			},
			new GridBagConstraints {
			    int gridx = 1;
			    int gridy = 2;
			},

			new JButton {
			    Image  icon = BuildControlIcon(-1, 72.0/9, 72.0/9, Color.black, 0.85);
			    double insets = 0;
			    double border = 0;
			    String tooltiptext = "Center selected cell or chart";

			    actionPerformed(e) {
				invokeLater(&root.ToggleAnchored);
			    }
			},
			new GridBagConstraints {
			    int gridx = 2;
			    int gridy = 2;
			},

			new JButton {
			    Image  icon = BuildControlIcon('>', 72.0/9, 72.0/9, Color.black, 0.85);
			    double insets = 0;
			    double border = 0;
			    String tooltiptext = "Scroll right by half a column";

			    mousePressed(e) {
				root.requestfocus = TRUE;
				root.components.$_scrollbutton_panel.StartScrolling(-0.5, 0);
			    }

			    mouseReleased(e) {
				root.components.$_scrollbutton_panel.StopScrolling();
			    }

			    mouseWheelMoved(e) {
				root.PanByCell(e.wheelrotation > 0 ? -0.5 : 0.5, 0, 0);
			    }
			},
			new GridBagConstraints {
			    int gridx = 3;
			    int gridy = 2;
			},

			new JButton {
			    Image  icon = BuildControlIcon('v', 72.0/9, 72.0/9, Color.black, 0.85);
			    double insets = 0;
			    double border = 0;
			    String tooltiptext = "Scroll down by half a row";

			    mousePressed(e) {
				root.requestfocus = TRUE;
				root.components.$_scrollbutton_panel.StartScrolling(0, -0.5);
			    }

			    mouseReleased(e) {
				root.components.$_scrollbutton_panel.StopScrolling();
			    }

			    mouseWheelMoved(e) {
				root.PanByCell(0, e.wheelrotation > 0 ? 0.5 : -0.5, 0);
			    }
			},
			new GridBagConstraints {
			    int gridx = 2;
			    int gridy = 3;
			},
		    };

		    ////////////////////////////
		    //
		    // Miscellaneous Functions
		    //
		    ////////////////////////////

		    HandleScroll() {
			if (started) {
			    root.PanBy(dx, dy, 0);
			    autoscroller.queue(invokeLater, &HandleScroll);
			    autoscroller.queue(sleep, delay);
			}
		    }

		    StartScrolling(double columns, double rows) {
			if (!started) {
			    dx = columns*root.activechart.columnwidth;
			    dy = rows*root.activechart.rowheight;
			    started = TRUE;
			    autoscroller.queue(invokeLater, &HandleScroll);
			    autoscroller.queue(sleep, initialdelay);
			}
		    }

		    StopScrolling() {
			if (started) {
			    started = FALSE;
			    autoscroller.queue(NULL);
			    autoscroller.interrupted = TRUE;
			}
		    }
		},
		NONE, RIGHT,

		new JChoice {
		    String tag = "$_primary_operation";
		    String selected = toString(MOUSE_AVAILABLE);

		    Array items = {
			"Pan", toString(MOUSE_AVAILABLE),
			"Cell DnD", toString(MOUSE_CELLDND),
			"Cell Copy", toString(MOUSE_CELLCOPY),
			"Select Cell", toString(MOUSE_SELECTCELL),
			"Move Cell", toString(MOUSE_MOVECELL),
			"Return Cell", toString(MOUSE_RETURNCELL),
			"Mark Chart", toString(MOUSE_MARKCHART),
			"Mark Cell", toString(MOUSE_MARKCELL),
			"Erase Mark", toString(MOUSE_ERASEMARK),
		    };

		    itemStateChanged(e) {
			if (e.state) {
			    root.components.$_chart_canvas.SyncPanAndZoom();
			    root.components.$_chart_canvas.SyncCursor();
			}
		    }

		    mouseWheelMoved(e) {
			int index = indexOfObject(mappings, selected);

			selected = (e.wheelrotation < 0) ? max(index - 1, 0) : min(index + 1, mappings@sizeof - 1);
		    }

		    RestoreState(Object arg) {
			if (arg == NULL)
			    selected = root.activechart.IsPuzzle() ? toString(MOUSE_MOVECELL) : toString(MOUSE_AVAILABLE);
			else selected = arg.selected;
		    }

		    SaveState() {
			return(new Dictionary {
			    Object selected = selected;
			});
		    }
		},
		NONE, LEFT,
	    };
	},
	HORIZONTAL, REMAINDER,
    };

    ////////////////////////////
    //
    // Event Handlers
    //
    ////////////////////////////

    keyPressed(e) {
	Dimension dimension;

	switch (e.keycode) {
	    case KeyCode.VK_F:
		if (e.modifiersdown & CTRL_DOWN_MASK)
		    ToggleFindPanelVisibility();
		break;

	    case KeyCode.VK_G:
		if (e.modifiersdown & CTRL_DOWN_MASK)
		    SetNextMatchingCell((e.modifiersdown & SHIFT_DOWN_MASK) ? -1 : 1);
		break;

	    case KeyCode.VK_UP:
		PanBy(0, 0.5*activechart.rowheight, 1);
		break;

	    case KeyCode.VK_LEFT:
		PanBy(0.5*activechart.columnwidth, 0, 1);
		break;

	    case KeyCode.VK_RIGHT:
		PanBy(-0.5*activechart.columnwidth, 0, 1);
		break;

	    case KeyCode.VK_DOWN:
		PanBy(0, -0.5*activechart.rowheight, 1);
		break;

	    case KeyCode.VK_PAGE_UP:		// hold shift to page right; hold ctrl to zoom out
		if (e.modifiersdown&CTRL_DOWN_MASK)
		    ZoomTo(components.$_zoom_icon.sliderwindow.components.$_zoom_slider.PickNextScaling(1));
		else {
		    dimension = components.$_chart_canvas.MapAdjustedSizeToCurrentData(72.0/4, 72.0/4);
		    if (e.modifiersdown&SHIFT_DOWN_MASK)
			PanBy(-dimension.width, 0, 1);
		    else PanBy(0, dimension.height, 1);
		}
		break;

	    case KeyCode.VK_PAGE_DOWN:		// hold shift to page left; hold ctrl to zoom in
		if (e.modifiersdown&CTRL_DOWN_MASK)
		    ZoomTo(components.$_zoom_icon.sliderwindow.components.$_zoom_slider.PickNextScaling(-1));
		else {
		    dimension = components.$_chart_canvas.MapAdjustedSizeToCurrentData(72.0/4, 72.0/4);
		    if (e.modifiersdown&SHIFT_DOWN_MASK) 
			PanBy(dimension.width, 0, 1);
		    else PanBy(0, -dimension.height, 1);
		}
		break;

	    case KeyCode.VK_HOME:
		ToggleAnchored();
		break;

	    case KeyCode.VK_END:
		ToggleZoom();
		break;
	}
    }

    mousePressed(e) {
	requestfocus = TRUE;
    }

    windowClosing(e) {
	exit(0);
    }

    ////////////////////////////
    //
    // Screen Functions
    //
    ////////////////////////////

    ShowScreen() {
	Dimension preferredsize = NULL;

	Thread preloader = {
	    int daemon = TRUE;
	    int priority = MIN_PRIORITY + 1;
	};

	if (!initialized) {
	    components.$_cell_detail.ChooseInitialPreferredSize(CELLDETAILWIDTH);

	    SetFindPanelVisibility(SHOWFINDPANEL);
	    SetExternalPanelVisibility(SHOWEXTERNALPANEL);
	    components.$_zoom_icon.sliderwindow.mainroot = this;
	    visible = TRUE;
	    HideSplashScreen();
	    LoadChartMenu();
	    SetChartModel();
	    LoadHelpMenu();
	    CollectToolTips();
	    SetInitialCell();
	    initialized = TRUE;
	    preloader.queue(&Preloader);
	}
	visible = TRUE;
    }

    ////////////////////////////
    //
    // Miscellaneous Functions
    //
    ////////////////////////////

    AddTemporaryLink(int selector, int direction) {
	activechart.AddTemporaryLink(GetCurrentCell(), GetNextCell(selector, direction), TRUE, components.$_chart_canvas.graphics);
    }

    BuildButtonMenuItems(Array data, ButtonGroup group, Pointer handler) {
	Pointer eventhandler;
	Object  firstradiobutton = NULL;
	Array   items;

	//
	// The way handler and group are used is a bit of a kludge, but it's
	// OK for now. Basically defining group to be NULL in one of the data
	// dictionaries means use a JCheckBoxMenuItem. Defining handler in one
	// of the dictionaries as a string means look for a function that has
	// that name in activechart and then in "this" and and use it as the
	// pointer to a function that's called to handle events.
	//

	if (data) {
	    items = new Array[0, ...];
	    group.selected = NULL;
	    for (ptr in data) {
		if (ptr[0]) {
		    if (defined("text", ptr[0])) {
			if (defined("handler", ptr[0])) {
			    if (ptr[0].handler instanceof String) {
				if (defined(ptr[0].handler, activechart))
				    eventhandler = &activechart[ptr[0].handler];
				else if (defined(ptr[0].handler, this))
				    eventhandler = &this[ptr[0].handler];
				else eventhandler = NULL;
			    } else if (ptr[0].handler instanceof Pointer && *ptr[0].handler instanceof Callable)
				eventhandler = ptr[0].handler;
			} else eventhandler = handler;
			if (eventhandler != NULL && *eventhandler instanceof Function) {
			    if (defined("group", ptr[0]) && ptr[0].group == NULL) {
				items[items@sizeof] = new JCheckBoxMenuItem {
				    String  text = ptr[0].text;
				    String  command = defined("command", ptr[0]) ? ptr[0].command : ptr[0].text;
				    int     state = defined("state", ptr[0]) && ptr[0].state;
				    Pointer handler = eventhandler;		// need to save it here

				    itemStateChanged(e) {
					if ((*handler)@length == 0)
					    invokeLater(handler);
					else if ((*handler)@length == 1)
					    invokeLater(handler, e);
					else if ((*handler)@length == 2)
					    invokeLater(handler, this, e);
				    }
				};
			    } else {
				items[items@sizeof] = new JRadioButtonMenuItem {
				    ButtonGroup group = group;
				    String      text = ptr[0].text;
				    String      command = defined("command", ptr[0]) ? ptr[0].command : ptr[0].text;
				    int         state = defined("state", ptr[0]) && ptr[0].state;
				    Pointer     handler = eventhandler;		// need to save it here

				    itemStateChanged(e) {
					if (enabled) {		// tricky - we might change state below
					    if ((*handler)@length == 0)
						invokeLater(handler);
					    else if ((*handler)@length == 1)
						invokeLater(handler, e);
					    else if ((*handler)@length == 2)
						invokeLater(handler, this, e);
					}
				    }
				};
				if (firstradiobutton == NULL)
				    firstradiobutton = items[items@sizeof - 1];
			    }
			}
		    }
		} else if (items@sizeof > 0)	// NULL means adds a separator
		    items[items@sizeof] = NULL;
	    }
	    if (items@sizeof > 0) {
		if (group.selected == NULL && firstradiobutton) {
		    save firstradiobutton.enabled = FALSE;
		    firstradiobutton.state = TRUE;
		}
	    }
	}
	return(items@sizeof ? items : NULL);
    }

    ClearChart() {
	Object comp;

	//
	// Mostly just to clear stale information from components when we're about
	// to build a new chart.
	//

	activechart = NULL;
	activemodel = NULL;
	for (ptr in components) {
	    if ((comp = *ptr) != NULL) {
		if (defined("ClearChart", comp) && comp != this)
		    comp.ClearChart();
	    }
	}
    }

    ClearCachedCharts() {
	int collectgarbage = FALSE;

	synchronized(chartcache) {
	    for (ptr in chartcache) {
		if (defined(ptr)) {
		    if (*ptr) {
			ptr[0] = NULL;
			collectgarbage = TRUE;
		    }
		}
	    }
	}
	if (collectgarbage) {
	    gc();
	    sleep(.25);
	    gc();
	    sleep(.50);
	}
    }

    CollectToolTips() {
	if (tooltips == NULL) {
	    tooltips = new Dictionary[0, ...];
	    for (ptr in components) {
		if (defined("tooltiptext", ptr[0]) && ptr[0].tooltiptext)
		    tooltips[ptr[0]@nameof] = ptr[0].tooltiptext;
	    }
	    SyncToolTips();
	}
    }

    GetActiveChartName() {
	return(chart_model_group.selected ? chart_model_group.selected.text : NULL);
    }

    GetCachedChartData(String model) {
	Dictionary chart;

	//
	// Checking the cache twice means we can avoid any synchronization
	// delay if the chart we're looking for exists in chartcache. It's
	// really only important when the preloader is running and happens
	// to be working on a chart that takes a while to build.
	//

	if (!defined(model, chartcache) || chartcache[model] == NULL) {
	    synchronized(chartcache) {
		if (!defined(model, chartcache) || chartcache[model] == NULL) {
		    if ((chart = ConstructChart(ChartData, model, &ClearCachedCharts, &UpdateChartStatus)) != NULL) {
			if (chart.cachechart)
			    chartcache[model] = chart;
		    }
		} else chart = chartcache[model];
	    }
	} else chart = chartcache[model];
	return(chart);
    }

    GetCurrentCell() {
	return(components.$_selector_panel.GetCurrentCell());
    }

    GetCurrentPoint() {
	return(components.$_selector_panel.GetCurrentPoint());
    }

    GetNextCell(int selector, int direction) {
	return(direction ? components.$_selector_panel.GetNextCell(selector, direction) : GetCurrentCell());
    }

    GetPrimaryOperation() {
	return(atoi(components.$_primary_operation.selected));
    }

    GetScreenAnchorInCurrentData() {
	return(components.$_chart_canvas.GetScreenAnchorInCurrentData());
    }

    HideSplashScreen() {
	//
	// The hideSystemSplashScreen() builtin was added in 2.2.1 so it's
	// not always available.
	//

	if (defined("hideSystemSplashScreen", yoix.system))
	    yoix.system.hideSystemSplashScreen();
    }

    LoadChartMenu() {
	Dictionary chart;
	Array      data;
	Array      items;

	//
	// This should only be called once and currently must be done before
	// the initial chart is created because chart_model_group is used in
	// SetChartModel() to select that chart. Notice that ConstructChart()
	// is called with a NULL model, which ends up creating a chart that's
	// not initialized and should only be used to call GetChartMenuData().
	//

	if ((chart = ConstructChart(ChartData, NULL, NULL, NULL)) != NULL) {
	    if ((data = chart.GetChartMenuData()) != NULL) {
		items = new Array {
		    unroll(BuildButtonMenuItems(data, chart_model_group, &this.SetChartModel)),
		    NULL,
		    new JMenu {
			String text = "Controls";
			Array items = {
			    new JMenuItem {
				String text = "Reload Chart";

				actionPerformed(e) {
				    invokeLater(&root.ReloadChart);
				}
			    },
			    new JMenuItem {
				String text = "Clear Cache";

				actionPerformed(e) {
				    invokeLater(&root.ClearCachedCharts);
				}
			    },
			};
		    },
		};

		if (PRELOAD_CHARTS) {
		    for (ptr in data) {
			if (ptr[0]) {
			    if (defined("preload", ptr[0]) && ptr[0].preload)
				chartcache[ptr[0].text] = NULL;
			}
		    }
		}
	    } else {
		items = new Array {
		    new JMenuItem {
			String text = "Reload Chart";
			actionPerformed(e) {
			    invokeLater(&root.ReloadChart);
			}
		    },
		};
	    }
	}
	if (items@sizeof > 0)
	    menubar.components.$_charts_menu.items = items;
	else menubar.components.$_charts_menu.visible = FALSE;
    }

    LoadColorMenu() {
	Array data;
	Array items;

	if ((data = activechart.GetColorMenuData()) != NULL) {
	    if ((items = BuildButtonMenuItems(data, coloredby_group, &this.SetColoredBy)) != NULL) {
		coloredby_selected = coloredby_group.selected;
		activecolordata = activechart.PickColorData(data, coloredby_selected.text);
	    } else items = new Array[0, ...];
	} else items = new Array[0, ...];

	if (items@sizeof > 0)
	    items[items@sizeof] = NULL;
	items[items@sizeof] = new JMenuItem {
	    String text = "Reverse Video";

	    actionPerformed(e) {
		root.ReverseVideo();
	    }
	};
	menubar.components.$_colors_menu.items = items;
    }

    LoadFilterMenu() {
	Thread thread;
	Array  data;
	Array  items;

	if ((data = activechart.GetFilterMenuData()) != NULL)
	    items = LoadFilterMenuData(data, new Array[0, ...]);

	if (items@sizeof > 0) {
	    menubar.components.$_filters_menu.items = items;
	    menubar.components.$_filters_menu.visible = TRUE;

	    //
	    // Filter loading doesn't seem like a high priority so we decided
	    // to do it in a separate thread.
	    //

	    thread.daemon = TRUE;
	    thread.priority = MIN_PRIORITY + 2;
	    thread.queue(&activechart.LoadAllFilters);
	} else {
	    menubar.components.$_filters_menu.items = NULL;
	    menubar.components.$_filters_menu.visible = FALSE;
	}
    }

    LoadFilterMenuData(Array data, Array items) {
	JMenu newmenu;
	int   separator = FALSE;

	for (ptr in data) {
	    if (items@sizeof >= FILTER_MENU_SIZE && ptr@sizeof > 2) {
		newmenu = new JMenu {
		    String text = "More";
		    Array items = LoadFilterMenuData(ptr, new Array[0,...]);
		};
		if (separator)
		    items[items@sizeof-1] = newmenu;
		else items[items@sizeof] = newmenu;
		break;
	    }
	    separator = FALSE;
	    if (ptr[0]) {
		if (ptr[0] instanceof Dictionary) {
		    if (defined("text", ptr[0]) && defined("key", ptr[0])) {
			activechart.RegisterFilter(ptr[0].key);
			//
			// Notice we use == to check equality, which means the text
			// must use the officially defined constants to get special
			// treatment.
			//
			if (ptr[0].text == ALL_ON || ptr[0].text == ALL_OFF) {
			    items[items@sizeof] = new JMenuItem {
				String  text = ptr[0].text;
				String  command = defined("command", ptr[0]) ? ptr[0].command : ptr[0].text;
				int     state = (ptr[0].text == ALL_ON);
				Object  key = ptr[0].key;
				Pointer handler = &this.SetFilteredByAll;	// need to save it here

				actionPerformed(e) {
				    invokeLater(handler, key, state);
				}
			    };
			} else {
			    items[items@sizeof] = new JCheckBoxMenuItem {
				String  text = ptr[0].text;
				String  command = defined("command", ptr[0]) ? ptr[0].command : ptr[0].text;
				int     state = TRUE;
				String  key = ptr[0].key;
				String  value = defined("value", ptr[0]) && ptr[0].value ? ptr[0].value : ptr[0].text;
				Pointer handler = &this.SetFilteredBy;	// need to save it here

				itemStateChanged(e) {
				    //
				    // Explicitly checking enabled, which is temporarily
				    // set to FALSE when we're handling ALL_ON or ALL_OFF
				    // and just syncing the items, because Java currently
				    // calls us even when we're disabled. Anyway, it's a
				    // way to prevent unnecessary work that's been handled
				    // by ALL_ON or ALL_OFF.
				    //
				    if (enabled)
					invokeLater(handler, key, value, e.state);
				}
			    };
			}
		    }
		} else if (ptr[0] instanceof String) {
		    items[items@sizeof] = new JMenu {
			String text = ptr[0];
			Array items = LoadFilterMenuData(ptr[1], new Array[0, ...]);
		    };
		}
	    } else if (items@sizeof > 0) {	// NULL means adds a separator
		items[items@sizeof] = NULL;
		separator = TRUE;
	    }
	}
	return(items);
    }

    LoadHelpMenu() {
	Array items[0, ...];

	if ((help_about = activechart.GetVersion()) == NULL)
	    help_about = TITLE;
	help_about += "\nPowered by Yoix Version " + VM.Version;
	items[items@sizeof] = new JMenuItem {
	    String text = "About";

	    actionPerformed(e) {
		invokeLater(showMessageDialog, root, root.help_about, "");
	    }
	};

	help_summary = defined("HELPSUMMARY") ? HELPSUMMARY : NULL;
	items[items@sizeof] = new JMenuItem {
	    String text = "Summary";
	    int    enabled = (help_summary != NULL);

	    actionPerformed(e) {
		invokeLater(&root.ShowHelpSummary);
	    }
	};

	if (YOIXHOME != NULL || YOIXTUTORIAL != NULL) {
	    if (HaveBrowserCommand()) {
		items[items@sizeof] = NULL;
		items[items@sizeof] = new JMenuItem {
		    String text = "Yoix Home Page";
		    int    visible = (YOIXHOME != NULL);

		    actionPerformed(e) {
			invokeLater(&root.ShowExternalURL, YOIXHOME);
		    }
		};
		items[items@sizeof] = new JMenuItem {
		    String text = "Yoix Tutorial";
		    int    visible = (YOIXTUTORIAL != NULL);

		    actionPerformed(e) {
			invokeLater(&root.ShowExternalURL, YOIXTUTORIAL);
		    }
		};
	    }
	}
	menubar.components.$_help_menu.items = items;
    }

    PaintCell(Dictionary cell) {
	if (!restoring)
	    activechart.PaintCell(cell, components.$_chart_canvas.graphics);
    }

    PaintRect(Rectangle rect, int clear) {
	if (!restoring)
	     activechart.PaintRect(rect, clear, components.$_chart_canvas.graphics);
    }

    PanBy(double dx, double dy, int maxsteps) {
	if (!restoring)
	    components.$_chart_canvas.HandlePanBy(dx, dy, maxsteps);
    }

    PanByCell(double columns, double rows, int maxsteps) {
	if (!restoring)
	    components.$_chart_canvas.HandlePanBy(columns*activechart.cellsize.width, rows*activechart.cellsize.height, 0);
    }

    Preloader() {
	//
	// This is called once at the end ShowScreen() and currently runs
	// in its own thread, but the cell label generation which usually
	// takes the most time also automatically runs in its own thread
	// (see LayoutCellLabels() function in ConstructChart()). Anyway,
	// the bottom line is that using a separate thread to call this
	// function is reasonable, but calling it directly from the same
	// thread that's responsible for startup usually won't have much
	// of an impact on performance. We're going to leave things this
	// way just in case, but feel free to experiment.
	//

	for (ptr in chartcache) {
	    if (defined(ptr) && ptr[0] == NULL)
		GetCachedChartData(ptr[0]@nameof);
	}
    }

    ReloadChart() {
	Dictionary chart;
	String model = chart_model_group.selected ? chart_model_group.selected.command : "";

	synchronized(chartcache) {
	    model = chart_model_group.selected ? chart_model_group.selected.command : "";
	    if ((chart = chartcache[model]) != NULL)
		chart.StopThreads();
	    chartcache[model] = NULL;
	}
	SetChartModel();
    }

    RemoveTemporaryLink() {
	activechart.RemoveTemporaryLink(components.$_chart_canvas.graphics);
    }

    RepaintChart() {
	if (!restoring)
	    components.$_chart_canvas.repaint();
    }

    RestoreChart(Dictionary chart) {
	Object comp;
	int    n;

	//
	// We synchronize just to be safe, but it's probably not required
	// and is mostly here as an example.
	//
	// NOTE - there's at least one panel, namely the $_selector_panel,
	// that implicitly assumes its children are restored first, which
	// is why we go through components in reverse order. Seems like a
	// reasonable requirement that's easy to meet since the components
	// dictionary is always arranged so a container is followed by its
	// children. Anway, if you decide to change it you probably will
	// have some subtle things to deal with in $_selector_panel.
	//
	// NOTE - the "comp != this" test is because we currently end up
	// in our own components dictionary but we're assigned to an empty
	// name (not our own tag). Seems a little strange and don't think
	// it was always that way so we're going to write this code in a
	// way that should work if we decide to change the interpreter's
	// behavior.
	//

	synchronized(this) {
	    restoring = TRUE;
	    for (n = components@sizeof - 1; n >= 0; n--) {
		if ((comp = components[n]) != NULL) {
		    if (defined("RestoreState", comp) && comp != this)
			comp.RestoreState(defined(comp.tag, chart.savedstate) ? chart.savedstate[comp.tag] : NULL);
		}
	    }
	    RestoreState(defined(this.tag, chart.savedstate) ? chart.savedstate[this.tag] : NULL);
	    SyncScreenToChart();
	    chart.savedstate = NULL;
	}
	finally {
	    restoring = FALSE;
	    RepaintChart();
	}
    }

    RestoreState(Object arg) {
	if (arg) {
	    menubar.components.$_filters_menu.items = arg.filters_menu;
	    menubar.components.$_filters_menu.visible = (arg.filters_menu != NULL);
	    activecolordata = arg.colordata;
	    coloredby_selected = arg.coloredby_selected;
	    menubar.components.$_colors_menu.items = arg.colors_menu;
	    menubar.components.$_colors_menu.visible = (arg.colors_menu != NULL);	// currently unnecessary
	    coloredby_group.selected = coloredby_selected;
	} else {
	    LoadColorMenu();
	    LoadFilterMenu();
	}
    }

    ReverseVideo() {
	Object panel = components.$_chart_panel;
	Object comp;
	Object fg;
	Object bg;

	fg = panel.background;
	bg = panel.foreground;

	for (ptr in panel.components) {
	    if (comp = *ptr) {
		comp.background = bg;
		comp.foreground = fg;
	    }
	}
	panel.foreground = fg;
	panel.background = bg;
    }

    SaveChart(Dictionary chart) {
	Dictionary dict[0, ...];
	Object     comp;

	//
	// We synchronize just to be safe, but it's probably not required
	// and is mostly here as an example.
	//
	// NOTE - the "comp != this" test is because we currently end up
	// in our own components dictionary but we're assigned to an empty
	// name (not our own tag). Seems a little strange and don't think
	// it was always that way so we're going to write this code in a
	// way that should work if we decide to change the interpreter's
	// behavior because it's a bug or mistake.
	//

	if (chart != NULL) {
	    synchronized(this) {
		for (ptr in components) {
		    if ((comp = *ptr) != NULL) {
			if (defined("SaveState", comp) && comp != this)
			    dict[comp.tag] = comp.SaveState();
		    }
		}
		dict[this.tag] = SaveState();
		chart.savedstate = dict;
	    }
	}
    }

    SavePrimaryOperation() {
	primaryoperation = atoi(components.$_primary_operation.selected);
    }

    SaveState() {
	return(new Dictionary {
	    Object filters_menu = menubar.components.$_filters_menu.items;
	    Object colors_menu = menubar.components.$_colors_menu.items;
	    Array  colordata = activecolordata;
	    Object coloredby_selected = coloredby_group.selected;
	});
    }

    SetAnchor(int anchor) {
	if (activechart != NULL) {
	    if (anchor != activechart.screenanchor) {
		activechart.screenanchor = anchor;
		if (activechart.cellanchor != NONE)
		    activechart.cellanchor = anchor;
		if (activechart.anchorenabled) {
		    components.$_chart_canvas.SyncMatrix();
		    if (!restoring) {
			if (ShowSelectedCell(TRUE) == NULL)
			    TranslatePointTo();
		    }
		}
	    }
	}
    }

    SetAnchorEnabled(int state) {
	if (activechart != NULL)
	    activechart.anchorenabled = state;
    }

    SetChartModel() {
	Dictionary chart;
	String     model = chart_model_group.selected ? chart_model_group.selected.command : "";
	Thread     thread;

	//
	// We force this into a new thread whenever we're called from the
	// event thread, just to make sure $_status_label is updated in a
	// timely fashion. It's only needed if the user starts loading a
	// chart before the last one is completely finished.
	//

	if (!isDispatchThread()) {
	    SaveChart(activechart);
	    ClearChart();
	    components.$_chart_model_label.text = model;
	    activemodel = model;		// need this for status label
	    glasspane.visible = TRUE;
	    if ((chart = GetCachedChartData(model)) != NULL) {
		activemodel = model;
		activechart = chart;
		activechart.ClearSelected();
		RestoreChart(activechart);
		requestfocus = TRUE;
	    }
	    glasspane.visible = FALSE;
	} else {
	    thread.daemon = TRUE;
	    thread.priority = NORM_PRIORITY - 1;
	    thread.queue(&SetChartModel);
	}
    }

    SetColoredBy() {
	//
	// The use of the wait cursor here implicitly assumes we're running in
	// the event thread because user actions in $_chart_canvas also set the
	// cursor. Not a big deal, but if this doesn't run in the event thread
	// the wait cursor can be replaced before we're finished.
	//

	if (coloredby_selected != coloredby_group.selected) {
	    save cursor = Cursor.WAIT_CURSOR;
	    coloredby_selected = coloredby_group.selected;
	    if (coloredby_selected != NULL)
		activecolordata = activechart.PickColorData(activecolordata, coloredby_selected.text);
	    activechart.ColorChartCells(activecolordata);
	    RepaintChart();
	}
	SetTipText();
    }

    SetExternalPanelVisibility(int state) {
	components.$_external_panel.SetVisible(state);
    }

    SetFilteredBy(Object key, Object value, int state) {
	if (activechart) {
	    if (activechart.SetFilteredBy(key, value, state)) {
		components.$_selector_panel.SyncSelection();
		RepaintChart();
	    }
	}
    }

    SetFilteredByAll(Object key, int state) {
	int repaint;

	//
	// Syncing the states of related filter items is necessary, but it's
	// trickier than it really should be - mostly because of Yoix related
	// issues that we will try to address in a future release.
	//
	// NOTE - an approach that should work would instead just explicitly
	// set the state in each of the appropriate $_filters_menu.components
	// without temporarily disabling them.
	//

	if (activechart) {
	    save cursor = Cursor.WAIT_CURSOR;
	    repaint = activechart.SetFilteredByAll(key, state);
	    components.$_selector_panel.SyncSelection();
	    //
	    // Need to sync the states of individual filter items with
	    // what we just did. Unfortunately the code is a bit of a
	    // kludge - we can't simply use
	    //
	    //	ptr[0] instanceof JCheckBoxMenuItem
	    //
	    // because this is really just checking for JMenuItem, which
	    // also includes the ALL_ON and ALL_OFF JMenuItems. You might
	    // also notice that the components in $_filters_menu aren't
	    // included in menubar.components. This is a bug that we will
	    // try to address in a future release. Anyway - sorry for the
	    // somewhat mysterious code.
	    //
	    for (ptr in menubar.components.$_filters_menu.components) {
		if (defined("key", ptr[0]) && ptr[0].key === key) {
		    if (defined("itemStateChanged", ptr[0])) {
			save ptr[0].enabled = FALSE;	// temporarily disable it
			ptr[0].state = state;
		    }
		}
	    }

	    if (repaint)
		RepaintChart();
	}
    }

    SetFindPanelVisibility(int state) {
	components.$_find_panel.SetVisible(state);
    }

    SetHideUnselectedCellLabels(int state) {
	if (activechart) {
	    activechart.showunselectedlabels = !state;
	    RepaintChart();
	}
    }

    SetInitialCell() {
	Dictionary cell;

	if (!initialized && activechart) {
	    if (INITIALCELL != NULL) {
		if ((cell = activechart.GetSelectableCellNamed(INITIALCELL)) != NULL)
		    ToggleCellSelection(cell);
	    }
	}
    }

    SetNextCell(Dictionary cell) {
	components.$_selector_panel.SetNextCell(cell);
    }

    SetNextMatchingCell(int direction) {
	Dictionary current;
	Dictionary cell;
	String     pattern;
	int        type;
	int        ignorecase;

	if (activechart) {
	    pattern = components.$_find_panel.GetPattern();
	    if (pattern@sizeof > 0) {
		save cursor = Cursor.WAIT_CURSOR;
		type = components.$_find_panel.GetPatternType();
		ignorecase = components.$_find_panel.GetIgnoreCase();
		current = GetCurrentCell();
		if ((cell = activechart.GetNextMatchingCell(current, pattern, type, ignorecase, direction)) != NULL) {
		    if (cell != current) {
			SetNextCell(cell);
			ShowSelectedCell(TRUE);
		    } else ShowSelectedCell(TRUE);
		} else components.$_find_panel.PatternNotFound();
	    }
	}
    }

    SetPrimaryOperation(int operation) {
	components.$_primary_operation.selected = toString(operation);
    }

    SetScaling(double value) {
	lastscaling = currentscaling;
	currentscaling = value;
	components.$_zoom_icon.sliderwindow.components.$_zoom_slider.SyncScaling();
	components.$_zoom_label.SyncScaling();
	components.$_chart_canvas.SyncScaling();
    }

    SetScalingBounds(Dimension cellsize) {
	//
	// Value assigned to maxscaling isn't exactly right and we end up
	// getting answers that depend on the current size of the canvas,
	// which makes sense because we used defaultmatrix to get cellsize
	// and the current canvas size is encoded in defaultmatrix. We will
	// will revisit later on.
	//
	// NOTE - the ZoomSettings code was added quickly as an attempt to
	// improve the performance on zooming in the unicode chart. It can
	// be a demanding operation and coarser settings than the default
	// improve things some. Bit of a kludge that probably should be
	// revisited. Changes were made on 5/24/20.
	//

	if (defined("ZoomSettings", global) && defined("maxscaling", global.ZoomSettings))
	    maxscaling = global.ZoomSettings.maxscaling;
	else maxscaling = ceil(max(VM.screen.width/cellsize.width, VM.screen.height/cellsize.height));

	if (defined("ZoomSettings", global) && defined("minscaling", global.ZoomSettings))
	     minscaling = global.ZoomSettings.minscaling;
	else minscaling = floor(10.0*max(0.1, min(0.5, minscaling)))/10.0;

	if (defined("ZoomSettings", global) && defined("line_cutoff", ZoomSettings))
	    components.$_zoom_icon.sliderwindow.components.$_zoom_slider.line_cutoff = ZoomSettings.line_cutoff;
	if (defined("ZoomSettings", global) && defined("linear", ZoomSettings))
	    components.$_zoom_icon.sliderwindow.components.$_zoom_slider.linear = ZoomSettings.linear;

	components.$_zoom_icon.sliderwindow.components.$_zoom_slider.SetZoomSliderControls();
    }

    SetSelectedChartLabels(String name, int selected) {
	if (name != NULL) {
	    if (selected_chart_labels[name] != selected) {
		selected_chart_labels[name] = selected;
		activechart.LayoutChartLabels(selected_chart_labels);
		components.$_chart_canvas.SyncState();
	    }
	}
    }

    SetShowGrid(int state) {
	if (state != activechart.showgrid) {
	    activechart.showgrid = state;
	    RepaintChart();
	}
    }

    SetTipText(...) {
	Dictionary cell = NULL;
	Point      point = NULL;
	String     tiptext;
	String     text;
	Color      color;

	//
	// The initial activechart check is sometimes needed if we haven't
	// built the first chart but the cursor is inside $_chart_canvas.
	//

	if (activechart != NULL) {
	    if (argc > 1) {
		if (argv[1] instanceof Point) {
		    point = argv[1];
		    cell = activechart.PickCellAt(point);
		}
	    } else cell = GetCurrentCell();

	    if (cell != NULL) {
		if (activechart.showunselectedlabels || activechart.IsCellSelected(cell)) {
		    if ((tiptext = activechart.GetCellTextAt(cell, TRUE, point)) == NULL) {
			if (cell.tip)
			    tiptext = cell.tip;
		    }
		}
		color = cell.background;
	    } else color = components.$_colortip_panel.background;

	    components.$_celltip_label.text = tiptext;
	    components.$_colortip_label.text = activechart.GetColorTipText(cell, defined(0, activecolordata) ?  activecolordata[0] : NULL);
	    components.$_colortip_color.background = color;
	}
    }

    ShowExternalURL(String page) {
	//
	// Old implementation tried to use a JTextPane to view HTML, but we
	// dropped it because there were so many pages that it didn't handle
	// well. So now it's your browser or nothing.
	//

	if (page@sizeof) {
	    switch (OpenBrowser(page)) {
		case 0:		// it worked
		    break;

		case 1:		// failed but wasn't a security check
		    Warn("Could not start a browser. Consider using the -B option\nand possibly adjusting security constraints.");
		    break;

		case 2:		// security check - we already used Warn().
		    break;
	    }
	}
    }

    ShowHelpSummary() {
	if (htmlviewer == NULL)
	    htmlviewer = NewHTMLViewer(this);
	htmlviewer.ShowText(help_summary);
    }

    ShowSelectedCell(...) {
	Dictionary cell;

	//
	// Optional argument, when supplied and TRUE, means force the cell
	// to the center of the screen, otherwise we let TranslateCellTo()
	// decide about anchoring. Suspect we might want more control (e.g,
	// move horizontally and vertically by cellsize or half cellsize
	// units) but extra features will have to wait.
	//

	if ((cell = GetCurrentCell()) != NULL)
	    TranslateCellTo(cell, (argc > 1 && argv[1]) ? NULL : cell, 0);
	return(cell);
    }

    SyncPrimaryOperation() {
	components.$_primary_operation.selected = toString(primaryoperation);
    }

    SyncScreenToChart() {
	//
	// This is stuff that probably should be done whenever we change
	// charts.
	//

	menubar.components.$_showgrid.state = activechart.showgrid;
	menubar.components.$_anchorenabled.state = activechart.anchorenabled;
	menubar.components.$_hideunselectedlabels.state = !activechart.showunselectedlabels;
	anchor_group.selected = toString(activechart.screenanchor);
    }

    SyncSelected(int now) {
	//
	// Hands the job off to a low priority thread if the now argument
	// is FALSE, otherwise it updates the components that display info
	// about the selected cell but aren't immediately notified when it
	// changes. This is primarily designed to offload updates that can
	// wait a bit when the user is rapidly changing the selected cell
	// via the mouse wheel.
	//

	if (now || SYNCDELAY <= 0 || !activechart.anchorenabled) {
	    synchronized(syncthread) {
		components.$_external_site.SyncSelected();
		components.$_cell_detail.SyncSelected();
	    }
	} else syncthread.DelayedSync(&SyncSelected, TRUE);
    }

    SyncSelectedCell(Dictionary cell, int state, int anchoring, Dictionary currentcell) {
	//
	// This function is called whenever the selected cell changes, no
	// matter how that change was triggered, so this is where all the
	// low level "selected" cell details are managed.
	//

	if (cell != NULL) {
	    activechart.SyncSelectedCell(cell, state);
	    if (state) {
		if (anchoring && activechart.anchorenabled)
		    TranslateCellTo(cell, currentcell, 0);
		else PaintCell(cell);
	    } else PaintCell(cell);
	    SetTipText();
	}
    }

    SyncToolTips() {
	if (tooltips != NULL) {
	    if (menubar.components.$_tooltips.state) {
		for (ptr in tooltips)
		    components[ptr[0]@nameof].tooltiptext = ptr[0];
	    } else {
		for (ptr in tooltips)
		    components[ptr[0]@nameof].tooltiptext = NULL;
	    }
	}
    }

    ToggleAnchored() {
	Dictionary cell;

	if ((cell = GetCurrentCell()) != NULL) {
	    if (components.$_chart_canvas.IsCellAnchored(cell))
		TranslatePointTo();
	    else ShowSelectedCell(TRUE);
	} else TranslatePointTo();
    }

    ToggleCellSelection(Dictionary cell) {
	components.$_selector_panel.ToggleCellSelection(cell);
    }

    ToggleFindPanelVisibility() {
	components.$_find_panel.ToggleVisible();
    }

    ToggleZoom() {
	ZoomTo(currentscaling == 1.0 ? lastscaling : 1.0);
    }

    TranslateCellTo(Dictionary cell, Dictionary lastcell, int maxsteps) {
	//
	// Translates the current CTM so the user space point specified by
	// the first argument (center of the data if missing) is shifted to
	// second user space point (center of the canvas if missing). So no
	// arguments simply shifts the center of the data to the center of
	// the canvas.
	//
	components.$_chart_canvas.HandleTranslateCellTo(cell, lastcell, maxsteps);
    }

    TranslatePointTo(...) {
	//
	// Translates the current CTM so the user space point specified by
	// the first argument (center of the data if missing) is shifted to
	// second user space point (center of the canvas if missing). So no
	// arguments simply shifts the center of the data to the center of
	// the canvas.
	//
	components.$_chart_canvas.HandleTranslatePointTo(unroll(&argv[1]));
    }

    UpdateChartStatus(Dictionary chart, int repaint) {
	//
	// This is a callback function that's handed to the chart constructor
	// and is called whenever something notable happens (e.g., starting a
	// new step) during the initialization process. It's only purpose is
	// to let the user know things are progressing when it takes more than
	// a few seonds to build a chart.
	//

	if (chart == activechart || activechart == NULL) {
	    components.$_status_label.SetStatus(chart);
	    if (repaint)
		RepaintChart();
	}
    }

    ZoomTo(double scaling, ...) {
	//
	// Currently just forwards the zooming request to canvas that's
	// displaying the chart, but likely will be more than one way to
	// zoom so this will be responsible for notifying the components
	// that need to know we've zoomed.
	//
	components.$_chart_canvas.HandleZoomTo(unroll(&scaling));
    }

    ZoomToInitialBounds() {
	Rectangle bounds = NULL;
	Point     lock;

	if ((bounds = activechart.GetInitialBounds()) != NULL) {
	    lock.x = bounds.x + bounds.width/2;
	    lock.y = bounds.y + bounds.height/2;
	    TranslatePointTo(lock);
	    ZoomTo(components.$_chart_canvas.GetScalingToFit(bounds), lock);
	}
    }
};

//
// A convenience function that individual applications can use to change the
// main screen's title (note: we use TITLESET so -T has precedence).
//

SetFrameTitle(String title) {
    if (!TITLESET)
	mainscreen.title = title;
}

////////////////////////////
//
// Data Section
//
////////////////////////////

//
// This is the ychart data file that displays several interactive versions
// of the periodic table, including one puzzle, a chart of the naturally
// occurring isotopes, and a fairly simple chart of the nuclides that lists
// no more than one decay mode per isotope. The command line used to run
// this file should look something like,
//
//	yoix ychart.yx [options] elements_ychart.yx
//
// where options are parsed by the Options() function (define in ychart.yx)
// and ychart.yx and elements_ychart.yx should be pathnames or URLs that point
// to ychart.yx and this file.
//

SetFrameTitle("Yoix\x00ae YChart: Elements");

CELLDETAILWIDTH = 3.0*72.0;
INITIALCELL = "Hydrogen";

//
// This section contains information about elements and their isotopes in a
// format that can be used to build the four (or five) different tables that
// we can display.
//

final String YES = "Yes";
final String NO = "No";
final String TRACE = "Trace";

final String NONMETAL = "Nonmetal";
final String SEMIMETAL = "Semimetal";
final String METAL = "Metal";
final String UNKNOWN = "Unknown";

final String SOLID = "Solid";
final String GAS = "Gas";
final String LIQUID = "Liquid";

//
// These are indices into an array named properties that's defined in the
// dictionary that describes each element. So you would find an element's
// melting point at properties[MELTING_POINT].
//

final int GROUP = 0;
final int BLOCK = 1;
final int CLASSIFICATION = 2;
final int STATE = 3;
final int ATOMIC_WEIGHT = 4;
final int ELECTRONEGATIVITY = 5;
final int IONIZATION_ENERGY = 6;
final int ATOMIC_RADIUS = 7;
final int ATOMIC_RADIUS_CALCULATED = 8;
final int MELTING_POINT = 9;
final int BOILING_POINT = 10;
final int DENSITY = 11;
final int MOLAR_VOLUME = 12;
final int ELECTRON_CONFIGURATION = 13;
final int RADIOACTIVE = 14;
final int TEMPORARYNAME = 15;

//
// Every isotopes array can be partitioned into groups of FIELDS_PER_ISOTOPE
// entries and each of the groups describes an isotope. The other constants
// are the indices in each group where a particular property of the isotope
// can be found.
//

final int NEUTRON_NUMBER = 0;
final int ABUNDANCE = 1;
final int DECAY_MODE = 2;
final int HALF_LIFE = 3;
final int FIELDS_PER_ISOTOPE = 4;

//
// These are the supported decay modes that we recognize, but at least one,
// namely SF, isn't currently used. The values are the strings that end up
// being displayed in cells. We use DecayModeTips to map the strings back
// words that provide a more complete description.
//

final String STABLE = "Stable";

final String ALPHA = "\x03B1";
final String BETA = "\x03B2\x207B";
final String EC = "\x03BA";
final String NEUTRON = "n";
final String POSITRON = "\x03B2\x207A";
final String PROTON = "p";
final String SF = "sf";

Dictionary DecayModeTips[] = {
    ALPHA, "alpha",
    BETA, "beta",
    EC, "electron capture",
    NEUTRON, "neutron",
    POSITRON, "positron",
    PROTON, "proton",
    SF, "spontaneous fission",

    UNKNOWN, UNKNOWN,
};

//
// Convenient definitions of strings that are used in various cell labels.
//

final String DEGREESKELVIN = "\x00B0K";
final String PICOMETER = "pm";
final String CHECKMARK = "\x2713";

//
// ElementData contains information about the elements. It's organized as
// an array of dictionaries and each dictionary describes one element. The
// element dictionaries happen to be sorted by atomic number, but it's not
// a requirement.
//

Array ElementData = {
    new Dictionary {
	String name = "Hydrogen";
	String symbol = "H";
	int    Z = 1;
	int    period = 1;

	Array properties = {"1", "s", NONMETAL, GAS, "1.00794(7)", "2.20", "1312.0", "25", "53", "14.01", "20.28", "", "11.42", "1s\x00B9", NO, NO};

	Array isotopes = {
	    0, "99.9885", NULL, NULL,
	    1, "0.0115", NULL, NULL,
	    2, NULL, BETA, "12.33y",
	};
	int primary_isotope = 0;
    },
    new Dictionary {
	String name = "Helium";
	String symbol = "He";
	int    Z = 2;
	int    period = 1;

	Array properties = {"18", "s", NONMETAL, GAS, "4.002602(2)", "", "2372.3", "", "31", "0.95", "4.22", "", "21.0", "1s\x00B2", NO, NO};

	Array isotopes = {
	    1, "0.000137", NULL, NULL,
	    2, "99.999863", NULL, NULL,
	    3, NULL, NEUTRON, "7\x00D710\x207B\x00B2\x00B2s",
	    4, NULL, BETA, "807ms",
	    6, NULL, BETA, "119ms",
	};
	int primary_isotope = 2;
    },
    new Dictionary {
	String name = "Lithium";
	String symbol = "Li";
	int    Z = 3;
	int    period = 2;

	Array properties = {"1", "s", METAL, SOLID, "[6.941(2)]", "0.98", "520.2", "145", "167", "453.69", "1615", "535", "13.02", "[He]2s\x00B9", NO, NO};

	Array isotopes = {
	    2, NULL, PROTON, "3\x00D710\x207B\x00B2\x00B2s",
	    3, "7.59", NULL, NULL,
	    4, "92.41", NULL, NULL,
	    5, NULL, BETA, "840ms",
	    6, NULL, BETA, "178ms",
	    8, NULL, BETA, "8.6ms",
	};
	int primary_isotope = 4;
    },
    new Dictionary {
	String name = "Beryllium";
	String symbol = "Be";
	int    Z = 4;
	int    period = 2;

	Array properties = {"2", "s", METAL, SOLID, "9.012182(3)", "1.57", "899.5", "105", "112", "1560", "2742", "1848", "4.85", "[He]2s\x00B2", NO, NO};

	Array isotopes = {
	    2, NULL, PROTON, "3\x00D710\x207B\x00B2\x00B9s",
	    3, NULL, EC, "53.3d",
	    4, NULL, ALPHA, "7\x00D710\x207B\x00B9\x2077s",
	    5, "100", NULL, NULL,
	    6, NULL, BETA, "1.5\x00D710\x2076y",
	    7, NULL, BETA, "13.8s",
	    8, NULL, BETA, "21.5ms",
	    10, NULL, BETA, "4.6ms",
	};
	int primary_isotope = 5;
    },
    new Dictionary {
	String name = "Boron";
	String symbol = "B";
	int    Z = 5;
	int    period = 2;

	Array properties = {"13", "p", SEMIMETAL, SOLID, "10.811(7)", "2.04", "800.6", "85", "87", "2349", "4200", "2460", "4.39", "[He]2s\x00B22p\x00B9", NO, NO};

	Array isotopes = {
	    3, NULL, POSITRON, "770ms",
	    4, NULL, PROTON, "8\x00D710\x207B\x00B9\x2079s",
	    5, "19.9", NULL, NULL,
	    6, "80.1", NULL, NULL,
	    7, NULL, BETA, "20.2ms",
	    8, NULL, BETA, "17.4ms",
	    9, NULL, BETA, "13ms",
	    10, NULL, BETA, "10ms",
	    12, NULL, BETA, "5ms",
	    14, NULL, BETA, "3ms",
	};
	int primary_isotope = 6;
    },
    new Dictionary {
	String name = "Carbon";
	String symbol = "C";
	int    Z = 6;
	int    period = 2;

	Array properties = {"14", "p", NONMETAL, SOLID, "12.0107(8)", "2.55", "1086.5", "70", "67", "3800", "4300", "2267", "5.29", "[He]2s\x00B22p\x00B2", NO, NO};

	Array isotopes = {
	    3, NULL, POSITRON, "127ms",
	    4, NULL, POSITRON, "19.3s",
	    5, NULL, POSITRON, "20.4m",
	    6, "98.93", NULL, NULL,
	    7, "1.07", NULL, NULL,
	    8, NULL, BETA, "5715y",
	    9, NULL, BETA, "2.45s",
	    10, NULL, BETA, "750ms",
	    11, NULL, BETA, "190ms",
	    12, NULL, BETA, "92ms",
	    13, NULL, BETA, "50ms",
	    14, NULL, BETA, "10ms",
	    16, NULL, BETA, "9ms",
	};
	int primary_isotope = 6;
    },
    new Dictionary {
	String name = "Nitrogen";
	String symbol = "N";
	int    Z = 7;
	int    period = 2;

	Array properties = {"15", "p", NONMETAL, GAS, "14.0067(2)", "3.04", "1402.3", "65", "56", "63.05", "77.36", "", "13.54", "[He]2s\x00B22p\x00B3", NO, NO};

	Array isotopes = {
	    5, NULL, POSITRON, "11ms",
	    6, NULL, POSITRON, "10ms",
	    7, "99.63", NULL, NULL,
	    8, "0.37", NULL, NULL,
	    9, NULL, BETA, "7.13s",
	    10, NULL, BETA, "4.17s",
	    11, NULL, BETA, "620ms",
	    12, NULL, BETA, "280ms",
	    13, NULL, BETA, "133ms",
	    14, NULL, BETA, "80ms",
	    15, NULL, BETA, "28ms",
	    16, NULL, BETA, "14ms",
	};
	int primary_isotope = 7;
    },
    new Dictionary {
	String name = "Oxygen";
	String symbol = "O";
	int    Z = 8;
	int    period = 2;

	Array properties = {"16", "p", NONMETAL, GAS, "15.9994(3)", "3.44", "1313.9", "60", "48", "54.8", "90.2", "", "17.36", "[He]2s\x00B22p\x2074", NO, NO};

	Array isotopes = {
	    5, NULL, POSITRON, "9ms",
	    6, NULL, POSITRON, "70.6s",
	    7, NULL, POSITRON, "122s",
	    8, "99.757", NULL, NULL,
	    9, "0.038", NULL, NULL,
	    10, "0.205", NULL, NULL,
	    11, NULL, BETA, "26.9s",
	    12, NULL, BETA, "13.5s",
	    13, NULL, BETA, "3.4s",
	    14, NULL, BETA, "2.2s",
	    15, NULL, BETA, "80ms",
	    16, NULL, BETA, "65ms",
	};
	int primary_isotope = 8;
    },
    new Dictionary {
	String name = "Fluorine";
	String symbol = "F";
	int    Z = 9;
	int    period = 2;

	Array properties = {"17", "p", NONMETAL, GAS, "18.9984032(5)", "3.98", "1681.0", "50", "42", "53.53", "85.03", "", "11.20", "[He]2s\x00B22p\x2075", NO, NO};

	Array isotopes = {
	    7, NULL, PROTON, "1\x00D710\x207B\x00B9\x2079s",
	    8, NULL, POSITRON, "66.0s",
	    9, NULL, POSITRON, "109.8m",
	    10, "100", NULL, NULL,
	    11, NULL, BETA, "11.1s",
	    12, NULL, BETA, "4.16s",
	    13, NULL, BETA, "4.23s",
	    14, NULL, BETA, "2.2s",
	    15, NULL, BETA, "36ms",
	    16, NULL, BETA, "60ms",
	    17, NULL, BETA, "10ms",
	    18, NULL, BETA, "5ms",
	    20, NULL, BETA, "2.5ms",
	};
	int primary_isotope = 10;
    },
    new Dictionary {
	String name = "Neon";
	String symbol = "Ne";
	int    Z = 10;
	int    period = 2;

	Array properties = {"18", "p", NONMETAL, GAS, "20.1797(6)", "", "2080.7", "", "38", "24.56", "27.07", "", "13.23", "[He]2s\x00B22p\x2076", NO, NO};

	Array isotopes = {
	    7, NULL, POSITRON, "109ms",
	    8, NULL, POSITRON, "1.67s",
	    9, NULL, POSITRON, "17.2s",
	    10, "90.48", NULL, NULL,
	    11, "0.27", NULL, NULL,
	    12, "9.25", NULL, NULL,
	    13, NULL, BETA, "37.2s",
	    14, NULL, BETA, "3.38m",
	    15, NULL, BETA, "610ms",
	    16, NULL, BETA, "197ms",
	    17, NULL, BETA, "31ms",
	    18, NULL, BETA, "17ms",
	    19, NULL, BETA, "16ms",
	    20, NULL, BETA, "6ms",
	    21, NULL, BETA, "3ms",
	    22, NULL, BETA, "4ms",
	};
	int primary_isotope = 10;
    },
    new Dictionary {
	String name = "Sodium";
	String symbol = "Na";
	int    Z = 11;
	int    period = 3;

	Array properties = {"1", "s", METAL, SOLID, "22.98976928(2)", "0.93", "495.8", "180", "190", "370.87", "1156", "968", "23.78", "[Ne]3s\x00B9", NO, NO};

	Array isotopes = {
	    9, NULL, POSITRON, "448ms",
	    10, NULL, POSITRON, "22.5s",
	    11, NULL, POSITRON, "2.604y",
	    12, "100", NULL, NULL,
	    13, NULL, BETA, "14.95h",
	    14, NULL, BETA, "59.3s",
	    15, NULL, BETA, "1.07s",
	    16, NULL, BETA, "290ms",
	    17, NULL, BETA, "31ms",
	    18, NULL, BETA, "44ms",
	    19, NULL, BETA, "50ms",
	    20, NULL, BETA, "17ms",
	    21, NULL, BETA, "13ms",
	    22, NULL, BETA, "8ms",
	    23, NULL, BETA, "5ms",
	    24, NULL, BETA, "1.5ms",
	};
	int primary_isotope = 12;
    },
    new Dictionary {
	String name = "Magnesium";
	String symbol = "Mg";
	int    Z = 12;
	int    period = 3;

	Array properties = {"2", "s", METAL, SOLID, "24.3050(6)", "1.31", "737.7", "150", "145", "923", "1363", "1738", "14.00", "[Ne]3s\x00B2", NO, NO};

	Array isotopes = {
	    8, NULL, POSITRON, "91ms",
	    9, NULL, POSITRON, "122ms",
	    10, NULL, POSITRON, "3.86s",
	    11, NULL, POSITRON, "11.32s",
	    12, "78.99", NULL, NULL,
	    13, "10.00", NULL, NULL,
	    14, "11.01", NULL, NULL,
	    15, NULL, BETA, "9.45m",
	    16, NULL, BETA, "21.0h",
	    17, NULL, BETA, "1.3s",
	    18, NULL, BETA, "320ms",
	    19, NULL, BETA, "240ms",
	    20, NULL, BETA, "100ms",
	    21, NULL, BETA, "90ms",
	    22, NULL, BETA, "20ms",
	    23, NULL, BETA, "70ms",
	};
	int primary_isotope = 12;
    },
    new Dictionary {
	String name = "Aluminum";
	String symbol = "Al";
	int    Z = 13;
	int    period = 3;

	Array properties = {"13", "p", METAL, SOLID, "26.9815386(8)", "1.61", "577.5", "125", "118", "933.47", "2792", "2700", "10.00", "[Ne]3s\x00B23p\x00B9", NO, NO};

	Array isotopes = {
	    9, NULL, POSITRON, "59ms",
	    10, NULL, POSITRON, "0.47s",
	    11, NULL, POSITRON, "2.07s",
	    12, NULL, POSITRON, "7.17s",
	    13, NULL, POSITRON, "6.35s",
	    14, "100", NULL, NULL,
	    15, NULL, BETA, "2.25m",
	    16, NULL, BETA, "6.5m",
	    17, NULL, BETA, "3.7s",
	    18, NULL, BETA, "640ms",
	    19, NULL, BETA, "32ms",
	    20, NULL, BETA, "40ms",
	    21, NULL, BETA, "56ms",
	    22, NULL, BETA, "39ms",
	    23, NULL, BETA, "90ms",
	};
	int primary_isotope = 14;
    },
    new Dictionary {
	String name = "Silicon";
	String symbol = "Si";
	int    Z = 14;
	int    period = 3;

	Array properties = {"14", "p", SEMIMETAL, SOLID, "28.0855(3)", "1.90", "786.5", "110", "111", "1687", "3173", "2330", "12.06", "[Ne]3s\x00B23p\x00B2", NO, NO};

	Array isotopes = {
	    8, NULL, POSITRON, "29ms",
	    9, NULL, POSITRON, "42ms",
	    10, NULL, POSITRON, "140ms",
	    11, NULL, POSITRON, "220ms",
	    12, NULL, POSITRON, "2.23s",
	    13, NULL, POSITRON, "4.14s",
	    14, "92.2297", NULL, NULL,
	    15, "4.6832", NULL, NULL,
	    16, "3.0872", NULL, NULL,
	    17, NULL, BETA, "2.62h",
	    18, NULL, BETA, "160y",
	    19, NULL, BETA, "6.1s",
	    20, NULL, BETA, "2.8s",
	    21, NULL, BETA, "800ms",
	    22, NULL, BETA, "500ms",
	    23, NULL, BETA, "90ms",
	    28, NULL, BETA, "20ms",
	};
	int primary_isotope = 14;
    },
    new Dictionary {
	String name = "Phosphorus";
	String symbol = "P";
	int    Z = 15;
	int    period = 3;

	Array properties = {"15", "p", NONMETAL, SOLID, "30.973762(2)", "2.19", "1011.8", "100", "98", "317.3", "550", "1823", "17.02", "[Ne]3s\x00B23p\x00B3", NO, NO};

	Array isotopes = {
	    11, NULL, POSITRON, "200ms",
	    12, NULL, POSITRON, "300ms",
	    13, NULL, POSITRON, "270ms",
	    14, NULL, POSITRON, "4.14s",
	    15, NULL, POSITRON, "2.50m",
	    16, "100", NULL, NULL,
	    17, NULL, BETA, "14.28d",
	    18, NULL, BETA, "25.3d",
	    19, NULL, BETA, "12.4s",
	    20, NULL, BETA, "47s",
	    21, NULL, BETA, "5.7s",
	    22, NULL, BETA, "2.3s",
	    23, NULL, BETA, "600ms",
	    24, NULL, BETA, "300ms",
	    25, NULL, BETA, "150ms",
	    26, NULL, BETA, "140ms",
	    27, NULL, BETA, "110ms",
	    28, NULL, BETA, "33ms",
	};
	int primary_isotope = 16;
    },
    new Dictionary {
	String name = "Sulfur";
	String symbol = "S";
	int    Z = 16;
	int    period = 3;

	Array properties = {"16", "p", NONMETAL, SOLID, "32.065(5)", "2.58", "999.6", "100", "88", "388.36", "717.87", "1960", "15.53", "[Ne]3s\x00B23p\x2074", NO, NO};

	Array isotopes = {
	    11, NULL, POSITRON, "16ms",
	    12, NULL, POSITRON, "120ms",
	    13, NULL, POSITRON, "188ms",
	    14, NULL, POSITRON, "1.18s",
	    15, NULL, POSITRON, "2.56s",
	    16, "94.93", NULL, NULL,
	    17, "0.76", NULL, NULL,
	    18, "4.29", NULL, NULL,
	    19, NULL, BETA, "87.2d",
	    20, "0.02", NULL, NULL,
	    21, NULL, BETA, "5.05m",
	    22, NULL, BETA, "2.84h",
	    23, NULL, BETA, "11.5s",
	    24, NULL, BETA, "9s",
	    25, NULL, BETA, "2s",
	    26, NULL, BETA, "1s",
	    27, NULL, BETA, "260ms",
	    28, NULL, BETA, "120ms",
	    29, NULL, BETA, "80ms",
	};
	int primary_isotope = 16;
    },
    new Dictionary {
	String name = "Chlorine";
	String symbol = "Cl";
	int    Z = 17;
	int    period = 3;

	Array properties = {"17", "p", NONMETAL, GAS, "35.453(2)", "3.16", "1251.2", "100", "79", "171.6", "239.11", "", "17.39", "[Ne]3s\x00B23p\x2075", NO, NO};

	Array isotopes = {
	    14, NULL, POSITRON, "150ms",
	    15, NULL, POSITRON, "297ms",
	    16, NULL, POSITRON, "2.51s",
	    17, NULL, POSITRON, "32.2m",
	    18, "75.78", NULL, NULL,
	    19, NULL, BETA, "3.01\x00D710\x2075y",
	    20, "24.22", NULL, NULL,
	    21, NULL, BETA, "37.2m",
	    22, NULL, BETA, "55.6m",
	    23, NULL, BETA, "1.38m",
	    24, NULL, BETA, "34s",
	    25, NULL, BETA, "6.8s",
	    26, NULL, BETA, "3.1s",
	    27, NULL, BETA, "560ms",
	    28, NULL, BETA, "410ms",
	    29, NULL, BETA, "220ms",
	};
	int primary_isotope = 18;
    },
    new Dictionary {
	String name = "Argon";
	String symbol = "Ar";
	int    Z = 18;
	int    period = 3;

	Array properties = {"18", "p", NONMETAL, GAS, "39.948(1)", "", "1520.6", "", "71", "83.8", "87.3", "", "22.56", "[Ne]3s\x00B23p\x2076", NO, NO};

	Array isotopes = {
	    13, NULL, POSITRON, "15ms",
	    14, NULL, POSITRON, "98ms",
	    15, NULL, POSITRON, "174ms",
	    16, NULL, POSITRON, "844ms",
	    17, NULL, POSITRON, "1.77s",
	    18, "0.3365", NULL, NULL,
	    19, NULL, EC, "35.0d",
	    20, "0.0632", NULL, NULL,
	    21, NULL, BETA, "269y",
	    22, "99.6003", NULL, NULL,
	    23, NULL, BETA, "1.83h",
	    24, NULL, BETA, "33y",
	    25, NULL, BETA, "5.4m",
	    26, NULL, BETA, "11.9m",
	    27, NULL, BETA, "21.5s",
	    28, NULL, BETA, "8,4s",
	    29, NULL, BETA, "600ms",
	};
	int primary_isotope = 22;
    },
    new Dictionary {
	String name = "Potassium";
	String symbol = "K";
	int    Z = 19;
	int    period = 4;

	Array properties = {"1", "s", METAL, SOLID, "39.0983(1)", "0.82", "418.8", "220", "243", "336.53", "1032", "856", "45.94", "[Ar]4s\x00B9", TRACE, NO};

	Array isotopes = {
	    16, NULL, POSITRON, "190ms",
	    17, NULL, POSITRON, "342ms",
	    18, NULL, POSITRON, "1.23s",
	    19, NULL, POSITRON, "7.63m",
	    20, "93.258", NULL, NULL,
	    21, "0.012", BETA, "1.27\x00D710\x2079y",
	    22, "6.730", NULL, NULL,
	    23, NULL, BETA, "12.36h",
	    24, NULL, BETA, "22.3h",
	    25, NULL, BETA, "22.1m",
	    26, NULL, BETA, "17.8m",
	    27, NULL, BETA, "1.8m",
	    28, NULL, BETA, "18s",
	    29, NULL, BETA, "6.8s",
	    30, NULL, BETA, "1.3s",
	    31, NULL, BETA, "470ms",
	    32, NULL, BETA, "365ms",
	    33, NULL, BETA, "105ms",
	    34, NULL, BETA, "30ms",
	    35, NULL, BETA, "10ms",
	};
	int primary_isotope = 20;
    },
    new Dictionary {
	String name = "Calcium";
	String symbol = "Ca";
	int    Z = 20;
	int    period = 4;

	Array properties = {"2", "s", METAL, SOLID, "40.078(4)", "1.00", "589.8", "180", "194", "1115", "1757", "1550", "26.20", "[Ar]4s\x00B2", NO, NO};

	Array isotopes = {
	    15, NULL, POSITRON, "26ms",
	    16, NULL, POSITRON, "102ms",
	    17, NULL, POSITRON, "181ms",
	    18, NULL, POSITRON, "440ms",
	    19, NULL, POSITRON, "861ms",
	    20, "96.941", NULL, NULL,
	    21, NULL, EC, "1.03\x00D710\x2075y",
	    22, "0.647", NULL, NULL,
	    23, "0.135", NULL, NULL,
	    24, "2.086", NULL, NULL,
	    25, NULL, BETA, "162.7d",
	    26, "0.004", NULL, NULL,
	    27, NULL, BETA, "4.54d",
	    28, "0.187", NULL, NULL,
	    29, NULL, BETA, "8.72m",
	    30, NULL, BETA, "14s",
	    31, NULL, BETA, "10s",
	    32, NULL, BETA, "4.6s",
	    33, NULL, BETA, "90ms",
	};
	int primary_isotope = 20;
    },
    new Dictionary {
	String name = "Scandium";
	String symbol = "Sc";
	int    Z = 21;
	int    period = 4;

	Array properties = {"3", "d", METAL, SOLID, "44.955912(6)", "1.36", "633.1", "160", "184", "1814", "3103", "2985", "15.00", "[Ar]3d\x00B94s\x00B2", NO, NO};

	Array isotopes = {
	    19, NULL, POSITRON, "182ms",
	    20, NULL, POSITRON, "596ms",
	    21, NULL, POSITRON, "682ms",
	    22, NULL, POSITRON, "3.90h",
	    23, NULL, POSITRON, "3.93h",
	    24, "100", NULL, NULL,
	    25, NULL, BETA, "83.8d",
	    26, NULL, BETA, "3.35d",
	    27, NULL, BETA, "43.7h",
	    28, NULL, BETA, "57.3m",
	    29, NULL, BETA, "1.71m",
	    30, NULL, BETA, "12.4s",
	    31, NULL, BETA, "8.2s",
	};
	int primary_isotope = 24;
    },
    new Dictionary {
	String name = "Titanium";
	String symbol = "Ti";
	int    Z = 22;
	int    period = 4;

	Array properties = {"4", "d", METAL, SOLID, "47.867(1)", "1.54", "658.8", "140", "176", "1941", "3560", "4507", "10.64", "[Ar]3d\x00B24s\x00B2", NO, NO};

	Array isotopes = {
	    17, NULL, POSITRON, "29ms",
	    18, NULL, POSITRON, "53ms",
	    19, NULL, POSITRON, "80ms",
	    20, NULL, POSITRON, "200ms",
	    21, NULL, POSITRON, "500ms",
	    22, NULL, POSITRON, "59,9y",
	    23, NULL, POSITRON, "3.08h",
	    24, "8.25", NULL, NULL,
	    25, "7.44", NULL, NULL,
	    26, "73.72", NULL, NULL,
	    27, "5.41", NULL, NULL,
	    28, "5.18", NULL, NULL,
	    29, NULL, BETA, "5.76m",
	    30, NULL, BETA, "1.7m",
	    31, NULL, BETA, "33s",
	    32, NULL, BETA, "1.5s",
	    33, NULL, BETA, "400ms",
	    34, NULL, BETA, "160ms",
	    35, NULL, BETA, "100ms",
	    36, NULL, BETA, "47ms",
	    37, NULL, BETA, "58ms",
	};
	int primary_isotope = 26;
    },
    new Dictionary {
	String name = "Vanadium";
	String symbol = "V";
	int    Z = 23;
	int    period = 4;

	Array properties = {"5", "d", METAL, SOLID, "50.9415(1)", "1.63", "650.9", "135", "171", "2183", "3680", "6110", "8.32", "[Ar]3d\x00B34s\x00B2", TRACE, NO};

	Array isotopes = {
	    20, NULL, POSITRON, "800ms",
	    21, NULL, POSITRON, "150ms",
	    22, NULL, POSITRON, "550ms",
	    23, NULL, POSITRON, "422ms",
	    24, NULL, POSITRON, "32.6m",
	    25, NULL, POSITRON, "15.98d",
	    26, NULL, EC, "331d",
	    27, "0.250", EC, "1.4\x00D710\x00B9\x2077y",
	    28, "99.750", NULL, NULL,
	    29, NULL, BETA, "3.76m",
	    30, NULL, BETA, "1.54m",
	    31, NULL, BETA, "50s",
	    32, NULL, BETA, "6.5s",
	    33, NULL, BETA, "230ms",
	    34, NULL, BETA, "330ms",
	    35, NULL, BETA, "210ms",
	    36, NULL, BETA, "100ms",
	    37, NULL, BETA, "100ms",
	    38, NULL, BETA, "43ms",
	    39, NULL, BETA, "60ms",
	};
	int primary_isotope = 28;
    },
    new Dictionary {
	String name = "Chromium";
	String symbol = "Cr";
	int    Z = 24;
	int    period = 4;

	Array properties = {"6", "d", METAL, SOLID, "51.9961(6)", "1.66", "652.9", "140", "166", "2180", "2944", "7140", "7.23", "[Ar]3d\x20754s\x00B9", NO, NO};

	Array isotopes = {
	    18, NULL, POSITRON, "13ms",
	    19, NULL, POSITRON, "21ms",
	    20, NULL, POSITRON, "53ms",
	    21, NULL, POSITRON, "50ms",
	    22, NULL, POSITRON, "300ms",
	    23, NULL, POSITRON, "500ms",
	    24, NULL, EC, "21.6h",
	    25, NULL, POSITRON, "42.3m",
	    26, "4.345", NULL, NULL,
	    27, NULL, EC, "27.7d",
	    28, "83.789", NULL, NULL,
	    29, "9.501", NULL, NULL,
	    30, "2.365", NULL, NULL,
	    31, NULL, BETA, "3.5m",
	    32, NULL, BETA, "5.9m",
	    33, NULL, BETA, "21s",
	    34, NULL, BETA, "7s",
	    35, NULL, BETA, "500ms",
	    36, NULL, BETA, "600ms",
	    37, NULL, BETA, "260ms",
	    38, NULL, BETA, "190ms",
	    39, NULL, BETA, "110ms",
	    40, NULL, BETA, "400ms",
	};
	int primary_isotope = 28;
    },
    new Dictionary {
	String name = "Manganese";
	String symbol = "Mn";
	int    Z = 25;
	int    period = 4;

	Array properties = {"7", "d", METAL, SOLID, "54.938045(5)", "1.55", "717.3", "140", "161", "1519", "2334", "7470", "7.35", "[Ar]3d\x20754s\x00B2", NO, NO};

	Array isotopes = {
	    21, NULL, POSITRON, "30ms",
	    22, NULL, POSITRON, "100ms",
	    23, NULL, POSITRON, "158ms",
	    24, NULL, POSITRON, "380ms",
	    25, NULL, POSITRON, "1.74m",
	    26, NULL, POSITRON, "46.2m",
	    27, NULL, POSITRON, "21.1m",
	    28, NULL, EC, "3.7\x00D710\x2076y",
	    29, NULL, EC, "312.1d",
	    30, "100", NULL, NULL,
	    31, NULL, BETA, "2.58h",
	    32, NULL, BETA, "1.45m",
	    33, NULL, BETA, "65s",
	    34, NULL, BETA, "4.6s",
	    35, NULL, BETA, "1.8s",
	    36, NULL, BETA, "670ms",
	    37, NULL, BETA, "670ms",
	    38, NULL, BETA, "276ms",
	    39, NULL, BETA, "88ms",
	    40, NULL, BETA, "91ms",
	    41, NULL, BETA, "67ms",
	    42, NULL, BETA, "42ms",
	    43, NULL, BETA, "28ms",
	    44, NULL, BETA, "14ms",
	};
	int primary_isotope = 30;
    },
    new Dictionary {
	String name = "Iron";
	String symbol = "Fe";
	int    Z = 26;
	int    period = 4;

	Array properties = {"8", "d", METAL, SOLID, "55.845(2)", "1.83", "762.5", "140", "156", "1811", "3134", "7874", "7.09", "[Ar]3d\x20764s\x00B2", NO, NO};

	Array isotopes = {
	    19, NULL, POSITRON, "5ms",
	    20, NULL, POSITRON, "12ms",
	    21, NULL, POSITRON, "22ms",
	    22, NULL, POSITRON, "44ms",
	    23, NULL, POSITRON, "70ms",
	    24, NULL, POSITRON, "150ms",
	    25, NULL, POSITRON, "310ms",
	    26, NULL, POSITRON, "46s",
	    27, NULL, POSITRON, "2.6m",
	    28, "5.845", NULL, NULL,
	    29, NULL, EC, "2.73y",
	    30, "91.754", NULL, NULL,
	    31, "2.119", NULL, NULL,
	    32, "0.282", NULL, NULL,
	    33, NULL, BETA, "44.5d",
	    34, NULL, BETA, "1.5\x00D710\x2076y",
	    35, NULL, BETA, "6.0m",
	    36, NULL, BETA, "68s",
	    37, NULL, BETA, "6s",
	    38, NULL, BETA, "2s",
	    39, NULL, BETA, "400ms",
	    40, NULL, BETA, "440ms",
	    41, NULL, BETA, "480ms",
	    42, NULL, BETA, "130ms",
	    43, NULL, BETA, "170ms",
	};
	int primary_isotope = 30;
    },
    new Dictionary {
	String name = "Cobalt";
	String symbol = "Co";
	int    Z = 27;
	int    period = 4;

	Array properties = {"9", "d", METAL, SOLID, "58.933195(5)", "1.88", "760.4", "135", "152", "1768", "3200", "8900", "6.67", "[Ar]3d\x20774s\x00B2", NO, NO};

	Array isotopes = {
	    23, NULL, POSITRON, "44ms",
	    25, NULL, POSITRON, "120s",
	    26, NULL, POSITRON, "0.24s",
	    27, NULL, POSITRON, "193ms",
	    28, NULL, POSITRON, "17.53h",
	    29, NULL, EC, "77.3d",
	    30, NULL, EC, "271.8d",
	    31, NULL, EC, "70.88d",
	    32, "100", NULL, NULL,
	    33, NULL, BETA, "5.271y",
	    34, NULL, BETA, "1.65h",
	    35, NULL, BETA, "1.5m",
	    36, NULL, BETA, "27.5s",
	    37, NULL, BETA, "300ms",
	    38, NULL, BETA, "1.17s",
	    39, NULL, BETA, "190ms",
	    40, NULL, BETA, "430ms",
	    41, NULL, BETA, "200ms",
	    42, NULL, BETA, "220ms",
	    43, NULL, BETA, "130ms",
	    44, NULL, BETA, "210ms",
	    45, NULL, BETA, "90ms",
	};
	int primary_isotope = 32;
    },
    new Dictionary {
	String name = "Nickel";
	String symbol = "Ni";
	int    Z = 28;
	int    period = 4;

	Array properties = {"10", "d", METAL, SOLID, "58.6934(2)", "1.91", "737.1", "135", "149", "1728", "3186", "8908", "6.59", "[Ar]3d\x20784s\x00B2", NO, NO};

	Array isotopes = {
	    24, NULL, POSITRON, "40ms",
	    25, NULL, POSITRON, "50ms",
	    26, NULL, POSITRON, "100ms",
	    27, NULL, POSITRON, "202ms",
	    28, NULL, EC, "5.9d",
	    29, NULL, POSITRON, "35.6h",
	    30, "68.077", NULL, NULL,
	    31, NULL, EC, "7.6\x00D710\x2074y",
	    32, "26.223", NULL, NULL,
	    33, "1.140", NULL, NULL,
	    34, "3.634", NULL, NULL,
	    35, NULL, BETA, "101y",
	    36, "0.926", NULL, NULL,
	    37, NULL, BETA, "2.52h",
	    38, NULL, BETA, "2.28d",
	    39, NULL, BETA, "21s",
	    40, NULL, BETA, "29s",
	    41, NULL, BETA, "3.5s",
	    42, NULL, BETA, "6s",
	    43, NULL, BETA, "2.6s",
	    44, NULL, BETA, "1.6s",
	    45, NULL, BETA, "600ms",
	    46, NULL, BETA, "700ms",
	    47, NULL, BETA, "600ms",
	    48, NULL, BETA, "200ms",
	};
	int primary_isotope = 30;
    },
    new Dictionary {
	String name = "Copper";
	String symbol = "Cu";
	int    Z = 29;
	int    period = 4;

	Array properties = {"11", "d", METAL, SOLID, "63.546(3)", "1.90", "745.5", "135", "145", "1357.77", "3200", "8920", "7.11", "[Ar]3d\x00B9\x20704s\x00B9", NO, NO};

	Array isotopes = {
	    27, NULL, POSITRON, "93ms",
	    28, NULL, POSITRON, "196ms",
	    29, NULL, POSITRON, "3.21s",
	    30, NULL, POSITRON, "1.36m",
	    31, NULL, POSITRON, "23.7m",
	    32, NULL, POSITRON, "3.35h",
	    33, NULL, POSITRON, "9.74m",
	    34, "69.17", NULL, NULL,
	    35, NULL, EC, "12.70h",
	    36, "30.83", NULL, NULL,
	    37, NULL, BETA, "5.10m",
	    38, NULL, BETA, "2.58d",
	    39, NULL, BETA, "31s",
	    40, NULL, BETA, "2.85m",
	    41, NULL, BETA, "5s",
	    42, NULL, BETA, "20s",
	    43, NULL, BETA, "6.6s",
	    44, NULL, BETA, "4.2s",
	    45, NULL, BETA, "1.6s",
	    46, NULL, BETA, "1.2s",
	    47, NULL, BETA, "640ms",
	    48, NULL, BETA, "470ms",
	    49, NULL, BETA, "340ms",
	    50, NULL, BETA, "190ms",
	};
	int primary_isotope = 34;
    },
    new Dictionary {
	String name = "Zinc";
	String symbol = "Zn";
	int    Z = 30;
	int    period = 4;

	Array properties = {"12", "d", METAL, SOLID, "65.409(4)", "1.65", "906.4", "135", "142", "692.68", "1180", "7140", "9.16", "[Ar]3d\x00B9\x20704s\x00B2", NO, NO};

	Array isotopes = {
	    27, NULL, POSITRON, "38ms",
	    28, NULL, POSITRON, "80ms",
	    29, NULL, POSITRON, "183ms",
	    30, NULL, POSITRON, "2.40m",
	    31, NULL, POSITRON, "1.48m",
	    32, NULL, POSITRON, "9.22h",
	    33, NULL, POSITRON, "38.5m",
	    34, "48.63", NULL, NULL,
	    35, NULL, EC, "243.8d",
	    36, "27.90", NULL, NULL,
	    37, "4.10", NULL, NULL,
	    38, "18.75", NULL, NULL,
	    39, NULL, BETA, "56m",
	    40, "0.62", NULL, NULL,
	    41, NULL, BETA, "2.4m",
	    42, NULL, BETA, "46.5h",
	    43, NULL, BETA, "6s",
	    44, NULL, BETA, "1.60m",
	    45, NULL, BETA, "10.2s",
	    46, NULL, BETA, "5.7s",
	    47, NULL, BETA, "2.1s",
	    48, NULL, BETA, "1.5s",
	    49, NULL, BETA, "1.0s",
	    50, NULL, BETA, "540ms",
	    51, NULL, BETA, "290ms",
	};
	int primary_isotope = 34;
    },
    new Dictionary {
	String name = "Gallium";
	String symbol = "Ga";
	int    Z = 31;
	int    period = 4;

	Array properties = {"13", "p", METAL, SOLID, "69.723(1)", "1.81", "578.8", "130", "136", "302.91", "2477", "5904", "11.80", "[Ar]3d\x00B9\x20704s\x00B24p\x00B9", NO, NO};

	Array isotopes = {
	    29, NULL, POSITRON, "70ms",
	    30, NULL, POSITRON, "168ms",
	    31, NULL, POSITRON, "116ms",
	    32, NULL, POSITRON, "32s",
	    33, NULL, POSITRON, "2.63m",
	    34, NULL, POSITRON, "15.2m",
	    35, NULL, POSITRON, "9.5h",
	    36, NULL, EC, "3.26d",
	    37, NULL, POSITRON, "1.13h",
	    38, "60.11", NULL, NULL,
	    39, NULL, BETA, "21.1m",
	    40, "39.89", NULL, NULL,
	    41, NULL, BETA, "14.1h",
	    42, NULL, BETA, "4.87h",
	    43, NULL, BETA, "8.1m",
	    44, NULL, BETA, "2.1m",
	    45, NULL, BETA, "29s",
	    46, NULL, BETA, "13s",
	    47, NULL, BETA, "5.1s",
	    48, NULL, BETA, "2.8s",
	    49, NULL, BETA, "1.7s",
	    50, NULL, BETA, "1.2s",
	    51, NULL, BETA, "600ms",
	    52, NULL, BETA, "310ms",
	    53, NULL, BETA, "90ms",
	};
	int primary_isotope = 38;
    },
    new Dictionary {
	String name = "Germanium";
	String symbol = "Ge";
	int    Z = 32;
	int    period = 4;

	Array properties = {"14", "p", SEMIMETAL, SOLID, "72.64(1)", "2.01", "762", "125", "125", "1211.4", "3093", "5323", "13.63", "[Ar]3d\x00B9\x20704s\x00B24p\x00B2", NO, NO};

	Array isotopes = {
	    29, NULL, POSITRON, "40ms",
	    30, NULL, POSITRON, "130ms",
	    31, NULL, POSITRON, "140ms",
	    32, NULL, POSITRON, "1.06m",
	    33, NULL, POSITRON, "31s",
	    34, NULL, POSITRON, "2.26h",
	    35, NULL, POSITRON, "19.0m",
	    36, NULL, EC, "270.8d",
	    37, NULL, EC, "1.63d",
	    38, "20.84", NULL, NULL,
	    39, NULL, EC, "11.4d",
	    40, "27.54", NULL, NULL,
	    41, "7.73", NULL, NULL,
	    42, "36.28", NULL, NULL,
	    43, NULL, BETA, "1.38d",
	    44, "7.61", NULL, NULL,
	    45, NULL, BETA, "53s",
	    46, NULL, BETA, "1.45h",
	    47, NULL, BETA, "19s",
	    48, NULL, BETA, "29.5s",
	    49, NULL, BETA, "7.6s",
	    50, NULL, BETA, "4.6s",
	    51, NULL, BETA, "1.9s",
	    52, NULL, BETA, "960ms",
	    53, NULL, BETA, "540ms",
	};
	int primary_isotope = 42;
    },
    new Dictionary {
	String name = "Arsenic";
	String symbol = "As";
	int    Z = 33;
	int    period = 4;

	Array properties = {"15", "p", SEMIMETAL, SOLID, "74.92160(2)", "2.18", "947.0", "115", "114", "1090", "887", "5727", "12.95", "[Ar]3d\x00B9\x20704s\x00B24p\x00B3", NO, NO};

	Array isotopes = {
	    31, NULL, POSITRON, "18ms",
	    32, NULL, POSITRON, "130ms",
	    33, NULL, POSITRON, "96ms",
	    34, NULL, POSITRON, "42s",
	    35, NULL, POSITRON, "2.53m",
	    36, NULL, POSITRON, "15.2m",
	    37, NULL, POSITRON, "52.6m",
	    38, NULL, EC, "2.72d",
	    39, NULL, EC, "26.0h",
	    40, NULL, EC, "80.3d",
	    41, NULL, EC, "17.78d",
	    42, "100", NULL, NULL,
	    43, NULL, BETA, "26.3h",
	    44, NULL, BETA, "38.8h",
	    45, NULL, BETA, "1.51h",
	    46, NULL, BETA, "9.0m",
	    47, NULL, BETA, "16s",
	    48, NULL, BETA, "33s",
	    49, NULL, BETA, "13.7s",
	    50, NULL, BETA, "13.4s",
	    51, NULL, BETA, "600ms",
	    52, NULL, BETA, "2.03s",
	    53, NULL, BETA, "900ms",
	    54, NULL, BETA, "600ms",
	};
	int primary_isotope = 42;
    },
    new Dictionary {
	String name = "Selenium";
	String symbol = "Se";
	int    Z = 34;
	int    period = 4;

	Array properties = {"16", "p", NONMETAL, SOLID, "78.96(3)", "2.55", "941.0", "115", "103", "494", "958", "4819", "16.42", "[Ar]3d\x00B9\x20704s\x00B24p\x2074", NO, NO};

	Array isotopes = {
	    32, NULL, POSITRON, "300ms",
	    33, NULL, POSITRON, "130ms",
	    34, NULL, POSITRON, "36s",
	    35, NULL, POSITRON, "27.4s",
	    36, NULL, POSITRON, "41.1m",
	    37, NULL, POSITRON, "4.7m",
	    38, NULL, EC, "8.5d",
	    39, NULL, POSITRON, "40m",
	    40, "0.89", NULL, NULL,
	    41, NULL, EC, "119.8d",
	    42, "9.37", NULL, NULL,
	    43, "7.63", NULL, NULL,
	    44, "23.77", NULL, NULL,
	    45, NULL, BETA, "2.9\x00D710\x2075y",
	    46, "49.61", NULL, NULL,
	    47, NULL, BETA, "18.5m",
	    48, "8.73", NULL, NULL,
	    49, NULL, BETA, "1.17m",
	    50, NULL, BETA, "3.2m",
	    51, NULL, BETA, "32s",
	    52, NULL, BETA, "15s",
	    53, NULL, BETA, "5.8s",
	    54, NULL, BETA, "1.5s",
	    55, NULL, BETA, "410ms",
	    57, NULL, BETA, "270ms",
	};
	int primary_isotope = 46;
    },
    new Dictionary {
	String name = "Bromine";
	String symbol = "Br";
	int    Z = 35;
	int    period = 4;

	Array properties = {"17", "p", NONMETAL, LIQUID, "79.904(1)", "2.96", "1139.9", "115", "94", "265.8", "332", "", "19.78", "[Ar]3d\x00B9\x20704s\x00B24p\x2075", NO, NO};

	Array isotopes = {
	    34, NULL, POSITRON, "1.21m",
	    35, NULL, POSITRON, "1.21m",
	    36, NULL, POSITRON, "1.21m",
	    37, NULL, POSITRON, "1.21m",
	    38, NULL, POSITRON, "3.3m",
	    39, NULL, POSITRON, "4m",
	    40, NULL, POSITRON, "97m",
	    41, NULL, POSITRON, "15.9h",
	    42, NULL, EC, "34.9h",
	    43, NULL, POSITRON, "6.4m",
	    44, "50.69", NULL, NULL,
	    45, NULL, BETA, "17.4m",
	    46, "49.31", NULL, NULL,
	    47, NULL, BETA, "35.4h",
	    48, NULL, BETA, "2.40h",
	    49, NULL, BETA, "6.0m",
	    50, NULL, BETA, "2.87m",
	    51, NULL, BETA, "55s",
	    52, NULL, BETA, "55.7s",
	    53, NULL, BETA, "15.9s",
	    54, NULL, BETA, "4.5s",
	    55, NULL, BETA, "1.6s",
	    56, NULL, BETA, "0.6s",
	    57, NULL, BETA, "0.3s",
	};
	int primary_isotope = 44;
    },
    new Dictionary {
	String name = "Krypton";
	String symbol = "Kr";
	int    Z = 36;
	int    period = 4;

	Array properties = {"18", "p", NONMETAL, GAS, "83.798(2)", "3.00", "1350.8", "", "88", "115.79", "119.93", "", "27.99", "[Ar]3d\x00B9\x20704s\x00B24p\x2076", NO, NO};

	Array isotopes = {
	    33, NULL, POSITRON, "30ms",
	    34, NULL, POSITRON, "60ms",
	    35, NULL, POSITRON, "100ms",
	    36, NULL, POSITRON, "17s",
	    37, NULL, POSITRON, "28s",
	    38, NULL, POSITRON, "11.4m",
	    39, NULL, POSITRON, "4.3m",
	    40, NULL, POSITRON, "14.8h",
	    41, NULL, POSITRON, "1.24h",
	    42, "0.35", NULL, NULL,
	    43, NULL, POSITRON, "1.45d",
	    44, "2.28", NULL, NULL,
	    45, NULL, EC, "2.3\x00D710\x2075y",
	    46, "11.58", NULL, NULL,
	    47, "11.49", NULL, NULL,
	    48, "57.00", NULL, NULL,
	    49, NULL, BETA, "4.48h",
	    50, "17.30", NULL, NULL,
	    51, NULL, BETA, "1.27h",
	    52, NULL, BETA, "2.84h",
	    53, NULL, BETA, "3.15m",
	    54, NULL, BETA, "32.3s",
	    55, NULL, BETA, "8.6s",
	    56, NULL, BETA, "1.84s",
	    57, NULL, BETA, "1.29s",
	    58, NULL, BETA, "210ms",
	    59, NULL, BETA, "780ms",
	    61, NULL, BETA, "100ms",
	};
	int primary_isotope = 48;
    },
    new Dictionary {
	String name = "Rubidium";
	String symbol = "Rb";
	int    Z = 37;
	int    period = 5;

	Array properties = {"1", "s", METAL, SOLID, "85.4678(3)", "0.82", "403.0", "235", "265", "312.46", "961", "1532", "55.76", "[Kr]5s\x00B9", YES, NO};

	Array isotopes = {
	    37, NULL, POSITRON, "65ms",
	    38, NULL, POSITRON, "19s",
	    39, NULL, POSITRON, "37s",
	    40, NULL, POSITRON, "3.78m",
	    41, NULL, POSITRON, "5.7m",
	    42, NULL, POSITRON, "23.2m",
	    43, NULL, POSITRON, "33s",
	    44, NULL, POSITRON, "4.57h",
	    45, NULL, POSITRON, "1.26m",
	    46, NULL, EC, "86.2d",
	    47, NULL, EC, "32.9d",
	    48, "72.17", NULL, NULL,
	    49, NULL, BETA, "18.65d",
	    50, "27.83", BETA, "4.88\x00D710\x00B9\x2070y",
	    51, NULL, BETA, "17.7m",
	    52, NULL, BETA, "15.4m",
	    53, NULL, BETA, "2.6m",
	    54, NULL, BETA, "58s",
	    55, NULL, BETA, "4.48s",
	    56, NULL, BETA, "5.85s",
	    57, NULL, BETA, "2.71s",
	    58, NULL, BETA, "377ms",
	    59, NULL, BETA, "199ms",
	    60, NULL, BETA, "169ms",
	    61, NULL, BETA, "107ms",
	    62, NULL, BETA, "55ms",
	    63, NULL, BETA, "53ms",
	    64, NULL, BETA, "30ms",
	    65, NULL, BETA, "40ms",
	};
	int primary_isotope = 48;
    },
    new Dictionary {
	String name = "Strontium";
	String symbol = "Sr";
	int    Z = 38;
	int    period = 5;

	Array properties = {"2", "s", METAL, SOLID, "87.62(1)", "0.95", "549.5", "200", "219", "1050", "1655", "2630", "33.94", "[Kr]5s\x00B2", NO, NO};

	Array isotopes = {
	    37, NULL, POSITRON, "70ms",
	    38, NULL, POSITRON, "8.9s",
	    39, NULL, POSITRON, "9.0s",
	    40, NULL, POSITRON, "2.6m",
	    41, NULL, POSITRON, "2.1m",
	    42, NULL, POSITRON, "1.77h",
	    43, NULL, POSITRON, "22.3m",
	    44, NULL, EC, "25.4d",
	    45, NULL, EC, "1.35d",
	    46, "0.56", NULL, NULL,
	    47, NULL, EC, "64.8d",
	    48, "9.86", NULL, NULL,
	    49, "7.00", NULL, NULL,
	    50, "82.58", NULL, NULL,
	    51, NULL, BETA, "50.5d",
	    52, NULL, BETA, "28.78y",
	    53, NULL, BETA, "9.5h",
	    54, NULL, BETA, "2.71h",
	    55, NULL, BETA, "7.4m",
	    56, NULL, BETA, "1.25m",
	    57, NULL, BETA, "25s",
	    58, NULL, BETA, "1.1s",
	    59, NULL, BETA, "430ms",
	    60, NULL, BETA, "650ms",
	    61, NULL, BETA, "260ms",
	    62, NULL, BETA, "201ms",
	    63, NULL, BETA, "116ms",
	    64, NULL, BETA, "68ms",
	};
	int primary_isotope = 50;
    },
    new Dictionary {
	String name = "Yttrium";
	String symbol = "Y";
	int    Z = 39;
	int    period = 5;

	Array properties = {"3", "d", METAL, SOLID, "88.90585(2)", "1.22", "600", "180", "212", "1799", "3609", "4472", "19.88", "[Kr]4d\x00B95s\x00B2", NO, NO};

	Array isotopes = {
	    38, NULL, POSITRON, "60ms",
	    39, NULL, POSITRON, "50ms",
	    40, NULL, POSITRON, "15s",
	    41, NULL, POSITRON, "30s",
	    42, NULL, POSITRON, "1.21m",
	    43, NULL, POSITRON, "8.6s",
	    44, NULL, POSITRON, "2.85m",
	    45, NULL, POSITRON, "4.6s",
	    46, NULL, POSITRON, "2.6h",
	    47, NULL, EC, "14.74h",
	    48, NULL, EC, "13.4h",
	    49, NULL, EC, "106.65d",
	    50, "100", NULL, NULL,
	    51, NULL, BETA, "3.19h",
	    52, NULL, BETA, "58.5d",
	    53, NULL, BETA, "3.54h",
	    54, NULL, BETA, "10.2h",
	    55, NULL, BETA, "18.7m",
	    56, NULL, BETA, "10.3m",
	    57, NULL, BETA, "5.3s",
	    58, NULL, BETA, "1.21s",
	    59, NULL, BETA, "590ms",
	    60, NULL, BETA, "1.5s",
	    61, NULL, BETA, "730ms",
	    62, NULL, BETA, "430ms",
	    63, NULL, BETA, "300ms",
	    64, NULL, BETA, "220ms",
	    65, NULL, BETA, "200ms",
	};
	int primary_isotope = 50;
    },
    new Dictionary {
	String name = "Zirconium";
	String symbol = "Zr";
	int    Z = 40;
	int    period = 5;

	Array properties = {"4", "d", METAL, SOLID, "91.224(2)", "1.33", "640.1", "155", "206", "2128", "4682", "6511", "14.02", "[Kr]4d\x00B25s\x00B2", NO, NO};

	Array isotopes = {
	    39, NULL, POSITRON, "60ms",
	    40, NULL, POSITRON, "5s",
	    41, NULL, POSITRON, "5.5s",
	    42, NULL, POSITRON, "32s",
	    43, NULL, POSITRON, "44s",
	    44, NULL, POSITRON, "26m",
	    45, NULL, POSITRON, "10.9s",
	    46, NULL, EC, "16.5h",
	    47, NULL, POSITRON, "1.71h",
	    48, NULL, EC, "83.4d",
	    49, NULL, EC, "3.27d",
	    50, "51.45", NULL, NULL,
	    51, "11.22", NULL, NULL,
	    52, "17.15", NULL, NULL,
	    53, NULL, BETA, "1.5\x00D710\x2076y",
	    54, "17.38", NULL, NULL,
	    55, NULL, BETA, "64.0d",
	    56, "2.80", NULL, NULL,
	    57, NULL, BETA, "16.8h",
	    58, NULL, BETA, "30.7s",
	    59, NULL, BETA, "2.2s",
	    60, NULL, BETA, "7.1s",
	    61, NULL, BETA, "2.4s",
	    62, NULL, BETA, "2.9s",
	    63, NULL, BETA, "1.3s",
	    64, NULL, BETA, "1.2s",
	    65, NULL, BETA, "600ms",
	};
	int primary_isotope = 50;
    },
    new Dictionary {
	String name = "Niobium";
	String symbol = "Nb";
	int    Z = 41;
	int    period = 5;

	Array properties = {"5", "d", METAL, SOLID, "92.90638(2)", "1.6", "652.1", "145", "198", "2750", "5017", "8570", "10.83", "[Kr]4d\x20745s\x00B9", NO, NO};

	Array isotopes = {
	    41, NULL, POSITRON, "50ms",
	    42, NULL, POSITRON, "4.1s",
	    43, NULL, POSITRON, "12s",
	    44, NULL, POSITRON, "21s",
	    45, NULL, POSITRON, "56s",
	    46, NULL, POSITRON, "2.6m",
	    47, NULL, POSITRON, "7.7m",
	    48, NULL, POSITRON, "1.1h",
	    49, NULL, POSITRON, "14.6h",
	    50, NULL, EC, "62d",
	    51, NULL, EC, "10.1d",
	    52, "100", NULL, NULL,
	    53, NULL, BETA, "6.26m",
	    54, NULL, BETA, "3.61d",
	    55, NULL, BETA, "23.4h",
	    56, NULL, BETA, "1.23h",
	    57, NULL, BETA, "2.9s",
	    58, NULL, BETA, "15s",
	    59, NULL, BETA, "1.5s",
	    60, NULL, BETA, "7.1s",
	    61, NULL, BETA, "1.3s",
	    62, NULL, BETA, "1.5s",
	    63, NULL, BETA, "920ms",
	    64, NULL, BETA, "2.9s",
	    65, NULL, BETA, "920ms",
	    66, NULL, BETA, "310ms",
	    67, NULL, BETA, "190ms",
	    68, NULL, BETA, "190ms",
	    69, NULL, BETA, "170ms",
	};
	int primary_isotope = 52;
    },
    new Dictionary {
	String name = "Molybdenum";
	String symbol = "Mo";
	int    Z = 42;
	int    period = 5;

	Array properties = {"6", "d", METAL, SOLID, "95.94(2)", "2.16", "684.3", "145", "190", "2896", "4912", "10280", "9.38", "[Kr]4d\x20755s\x00B9", NO, NO};

	Array isotopes = {
	    41, NULL, POSITRON, "6ms",
	    42, NULL, POSITRON, "3.7s",
	    43, NULL, POSITRON, "3.2s",
	    44, NULL, POSITRON, "20s",
	    45, NULL, POSITRON, "14s",
	    46, NULL, POSITRON, "8.0m",
	    47, NULL, POSITRON, "2.0m",
	    48, NULL, POSITRON, "5.7h",
	    49, NULL, POSITRON, "15.5m",
	    50, "14.84", NULL, NULL,
	    51, NULL, EC, "3500y",
	    52, "9.25", NULL, NULL,
	    53, "15.92", NULL, NULL,
	    54, "16.68", NULL, NULL,
	    55, "9.55", NULL, NULL,
	    56, "24.13", NULL, NULL,
	    57, NULL, BETA, "2.75d",
	    58, "9.63", NULL, NULL,
	    59, NULL, BETA, "14.6m",
	    60, NULL, BETA, "11.3m",
	    61, NULL, BETA, "1.13m",
	    62, NULL, BETA, "1.0m",
	    63, NULL, BETA, "36s",
	    64, NULL, BETA, "8.7s",
	    65, NULL, BETA, "3.5s",
	    66, NULL, BETA, "1.1s",
	    67, NULL, BETA, "500ms",
	    68, NULL, BETA, "300ms",
	};
	int primary_isotope = 56;
    },
    new Dictionary {
	String name = "Technetium";
	String symbol = "Tc";
	int    Z = 43;
	int    period = 5;

	Array properties = {"7", "d", METAL, SOLID, "[98]", "1.9", "702", "135", "183", "2430", "4538", "11500", "8.63", "[Kr]4d\x20765s\x00B9", YES, NO};

	Array isotopes = {
	    43, NULL, POSITRON, "50ms",
	    44, NULL, POSITRON, "2.2s",
	    45, NULL, POSITRON, "5.8s",
	    46, NULL, POSITRON, "13s",
	    47, NULL, POSITRON, "8.3s",
	    48, NULL, POSITRON, "3.14m",
	    49, NULL, POSITRON, "4.2m",
	    50, NULL, EC, "2.73h",
	    51, NULL, POSITRON, "52m",
	    52, NULL, EC, "20.0h",
	    53, NULL, EC, "52m",
	    54, NULL, EC, "4.2\x00D710\x2076y",
	    55, NULL, BETA, "4.2\x00D710\x2076y",
	    56, NULL, BETA, "2.13\x00D710\x2075y",
	    57, NULL, POSITRON, "15.8s",
	    58, NULL, BETA, "14.2m",
	    59, NULL, BETA, "4.4s",
	    60, NULL, BETA, "54s",
	    61, NULL, BETA, "18.2m",
	    62, NULL, BETA, "7.6m",
	    63, NULL, BETA, "36s",
	    64, NULL, BETA, "21s",
	    65, NULL, BETA, "5.1s",
	    66, NULL, BETA, "870ms",
	    67, NULL, BETA, "870ms",
	    68, NULL, BETA, "300ms",
	    69, NULL, BETA, "260ms",
	    70, NULL, BETA, "150ms",
	    71, NULL, BETA, "150ms",
	};
	int primary_isotope = 54;
    },
    new Dictionary {
	String name = "Ruthenium";
	String symbol = "Ru";
	int    Z = 44;
	int    period = 5;

	Array properties = {"8", "d", METAL, SOLID, "101.07(2)", "2.2", "710.2", "130", "178", "2607", "4423", "12370", "8.17", "[Kr]4d\x20775s\x00B9", NO, NO};

	Array isotopes = {
	    44, NULL, POSITRON, "1.2s",
	    45, NULL, POSITRON, "1.3s",
	    46, NULL, POSITRON, "11s",
	    47, NULL, POSITRON, "9s",
	    48, NULL, POSITRON, "3.7m",
	    49, NULL, POSITRON, "10.8s",
	    50, NULL, EC, "52m",
	    51, NULL, EC, "1.64h",
	    52, "5.54", NULL, NULL,
	    53, NULL, EC, "2.89d",
	    54, "1.87", NULL, NULL,
	    55, "12.76", NULL, NULL,
	    56, "12.60", NULL, NULL,
	    57, "17.06", NULL, NULL,
	    58, "31.55", NULL, NULL,
	    59, NULL, BETA, "39.3d",
	    60, "18.62", NULL, NULL,
	    61, NULL, BETA, "4.44h",
	    62, NULL, BETA, "1.02y",
	    63, NULL, BETA, "3.8m",
	    64, NULL, BETA, "4.5m",
	    65, NULL, BETA, "34.5s",
	    66, NULL, BETA, "12s",
	    67, NULL, BETA, "2.1s",
	    68, NULL, BETA, "1.8s",
	    69, NULL, BETA, "510ms",
	    70, NULL, BETA, "570ms",
	    71, NULL, BETA, "740ms",
	};
	int primary_isotope = 58;
    },
    new Dictionary {
	String name = "Rhodium";
	String symbol = "Rh";
	int    Z = 45;
	int    period = 5;

	Array properties = {"9", "d", METAL, SOLID, "102.90550(2)", "2.28", "719.7", "135", "173", "2237", "3968", "12450", "8.28", "[Kr]4d\x20785s\x00B9", NO, NO};

	Array isotopes = {
	    45, NULL, POSITRON, "120ms",
	    46, NULL, POSITRON, "1.7s",
	    47, NULL, POSITRON, "5s",
	    48, NULL, POSITRON, "14s",
	    49, NULL, POSITRON, "25.8s",
	    50, NULL, POSITRON, "1.96m",
	    51, NULL, POSITRON, "1.51m",
	    52, NULL, POSITRON, "31m",
	    53, NULL, POSITRON, "3.5m",
	    54, NULL, EC, "4.7h",
	    55, NULL, EC, "20.8h",
	    56, NULL, EC, "4.35d",
	    57, NULL, EC, "207d",
	    58, "100", NULL, NULL,
	    59, NULL, BETA, "42.3s",
	    60, NULL, BETA, "35.4h",
	    61, NULL, BETA, "29.9s",
	    62, NULL, BETA, "21.7m",
	    63, NULL, BETA, "17s",
	    64, NULL, BETA, "1.34m",
	    65, NULL, BETA, "3.1s",
	    66, NULL, BETA, "11s",
	    67, NULL, BETA, "2.1s",
	    68, NULL, BETA, "2.8s",
	    69, NULL, BETA, "1.8s",
	    70, NULL, BETA, "990ms",
	    71, NULL, BETA, "600ms",
	    72, NULL, BETA, "440ms",
	    73, NULL, BETA, "300ms",
	};
	int primary_isotope = 58;
    },
    new Dictionary {
	String name = "Palladium";
	String symbol = "Pd";
	int    Z = 46;
	int    period = 5;

	Array properties = {"10", "d", METAL, SOLID, "106.42(1)", "2.20", "804.4", "140", "169", "1828.05", "3236", "12023", "8.56", "[Kr]4d\x00B9\x2070", NO, NO};

	Array isotopes = {
	    46, NULL, POSITRON, "1.0s",
	    47, NULL, POSITRON, "1.1s",
	    48, NULL, EC, "9s",
	    49, NULL, EC, "4s",
	    50, NULL, EC, "2.03m",
	    51, NULL, POSITRON, "3.1m",
	    52, NULL, EC, "17.7m",
	    53, NULL, POSITRON, "21.4m",
	    54, NULL, EC, "3.7d",
	    55, NULL, EC, "8.4h",
	    56, "1.02", NULL, NULL,
	    57, NULL, EC, "17.0d",
	    58, "11.14", NULL, NULL,
	    59, "22.33", NULL, NULL,
	    60, "27.33", NULL, NULL,
	    61, NULL, BETA, "6.5\x00D710\x2076y",
	    62, "26.46", NULL, NULL,
	    63, NULL, BETA, "13.46h",
	    64, "11.72", NULL, NULL,
	    65, NULL, BETA, "23.4m",
	    66, NULL, BETA, "21.04h",
	    67, NULL, BETA, "1.53m",
	    68, NULL, BETA, "2.48m",
	    69, NULL, BETA, "25s",
	    70, NULL, BETA, "12s",
	    71, NULL, BETA, "4.4s",
	    72, NULL, BETA, "2.1s",
	    73, NULL, BETA, "900ms",
	    74, NULL, BETA, "500ms",
	};
	int primary_isotope = 60;
    },
    new Dictionary {
	String name = "Silver";
	String symbol = "Ag";
	int    Z = 47;
	int    period = 5;

	Array properties = {"11", "d", METAL, SOLID, "107.8682(2)", "1.93", "731.0", "160", "165", "1234.93", "2435", "10490", "10.27", "[Kr]4d\x00B9\x20705s\x00B9", NO, NO};

	Array isotopes = {
	    47, NULL, POSITRON, "300ms",
	    48, NULL, POSITRON, "1.9s",
	    49, NULL, POSITRON, "5.1s",
	    50, NULL, POSITRON, "25.4s",
	    51, NULL, POSITRON, "47.4s",
	    52, NULL, POSITRON, "2.07m",
	    53, NULL, POSITRON, "2.0m",
	    54, NULL, POSITRON, "11.1m",
	    55, NULL, POSITRON, "7.8m",
	    56, NULL, EC, "1.10h",
	    57, NULL, POSITRON, "33m",
	    58, NULL, EC, "41.3d",
	    59, NULL, EC, "24.0m",
	    60, "51.84", NULL, NULL,
	    61, NULL, BETA, "2.39m",
	    62, "48.16", NULL, NULL,
	    63, NULL, BETA, "24.6s",
	    64, NULL, BETA, "1.08m",
	    65, NULL, BETA, "3.13h",
	    66, NULL, BETA, "1.14m",
	    67, NULL, BETA, "4.6s",
	    68, NULL, BETA, "18.7s",
	    69, NULL, BETA, "9s",
	    70, NULL, BETA, "5.3s",
	    71, NULL, BETA, "2.4s",
	    72, NULL, BETA, "6s",
	    73, NULL, BETA, "320ms",
	    74, NULL, BETA, "780ms",
	    75, NULL, BETA, "530ms",
	    76, NULL, BETA, "300ms",
	    77, NULL, BETA, "170ms",
	    78, NULL, BETA, "170ms",
	    79, NULL, BETA, "100ms",
	    80, NULL, BETA, "790ms",
	    81, NULL, BETA, "60ms",
	    82, NULL, BETA, "50ms",
	};
	int primary_isotope = 60;
    },
    new Dictionary {
	String name = "Cadmium";
	String symbol = "Cd";
	int    Z = 48;
	int    period = 5;

	Array properties = {"12", "d", METAL, SOLID, "112.411(8)", "1.69", "867.8", "155", "161", "594.22", "1040", "8650", "13.00", "[Kr]4d\x00B9\x20705s\x00B2", TRACE, NO};

	Array isotopes = {
	    49, NULL, POSITRON, "3s",
	    50, NULL, POSITRON, "9.2s",
	    51, NULL, POSITRON, "16s",
	    52, NULL, POSITRON, "49.1s",
	    53, NULL, POSITRON, "1.36m",
	    54, NULL, POSITRON, "5.8m",
	    55, NULL, POSITRON, "7.5m",
	    56, NULL, EC, "58m",
	    57, NULL, EC, "55.5m",
	    58, "1.25", NULL, NULL,
	    59, NULL, EC, "6.52h",
	    60, "0.89", NULL, NULL,
	    61, NULL, EC, "1.26y",
	    62, "12.49", NULL, NULL,
	    63, "12.80", NULL, NULL,
	    64, "24.13", NULL, NULL,
	    65, "12.22", BETA, "7.7\x00D710\x00B9\x2075y",
	    66, "28.73", NULL, NULL,
	    67, NULL, BETA, "2.23d",
	    68, "7.49", BETA, "3\x00D710\x00B9\x2079y",
	    69, NULL, BETA, "3.4h",
	    70, NULL, BETA, "50.3m",
	    71, NULL, BETA, "2.2m",
	    72, NULL, BETA, "50.8s",
	    73, NULL, BETA, "8s",
	    74, NULL, BETA, "5.3s",
	    75, NULL, BETA, "1.84s",
	    76, NULL, BETA, "1.24s",
	    77, NULL, BETA, "600ms",
	    78, NULL, BETA, "520ms",
	    79, NULL, BETA, "400ms",
	    80, NULL, BETA, "280ms",
	    81, NULL, BETA, "270ms",
	    82, NULL, BETA, "160ms",
	    83, NULL, BETA, "68ms",
	    84, NULL, BETA, "10ms",
	};
	int primary_isotope = 66;
    },
    new Dictionary {
	String name = "Indium";
	String symbol = "In";
	int    Z = 49;
	int    period = 5;

	Array properties = {"13", "p", METAL, SOLID, "114.818(3)", "1.78", "558.3", "155", "156", "429.75", "2345", "7310", "15.76", "[Kr]4d\x00B9\x20705s\x00B25p\x00B9", TRACE, NO};

	Array isotopes = {
	    49, NULL, POSITRON, "1s",
	    50, NULL, POSITRON, "3s",
	    51, NULL, POSITRON, "6s",
	    52, NULL, POSITRON, "15s",
	    53, NULL, POSITRON, "22s",
	    54, NULL, POSITRON, "34s",
	    55, NULL, POSITRON, "16s",
	    56, NULL, POSITRON, "43s",
	    57, NULL, POSITRON, "5.3m",
	    58, NULL, POSITRON, "32.4m",
	    59, NULL, POSITRON, "40m",
	    60, NULL, EC, "4.2h",
	    61, NULL, POSITRON, "1.15h",
	    62, NULL, EC, "2.80d",
	    63, NULL, BETA, "14.4m",
	    64, "4.29", NULL, NULL,
	    65, NULL, BETA, "1.2m",
	    66, "95.71", BETA, "5.4\x00D710\x00B9\x2074y",
	    67, NULL, BETA, "14.1s",
	    68, NULL, BETA, "44m",
	    69, NULL, BETA, "5.0s",
	    70, NULL, BETA, "2.3m",
	    71, NULL, BETA, "3.1s",
	    72, NULL, BETA, "23s",
	    73, NULL, BETA, "1.5s",
	    74, NULL, BETA, "6.0s",
	    75, NULL, BETA, "3.18s",
	    76, NULL, BETA, "2.36s",
	    77, NULL, BETA, "1.53s",
	    78, NULL, BETA, "1.14s",
	    79, NULL, BETA, "700ms",
	    80, NULL, BETA, "630ms",
	    81, NULL, BETA, "290ms",
	    82, NULL, BETA, "280ms",
	    83, NULL, BETA, "200ms",
	    84, NULL, BETA, "165ms",
	    85, NULL, BETA, "140ms",
	    86, NULL, BETA, "90ms",
	};
	int primary_isotope = 66;
    },
    new Dictionary {
	String name = "Tin";
	String symbol = "Sn";
	int    Z = 50;
	int    period = 5;

	Array properties = {"14", "p", METAL, SOLID, "118.710(7)", "1.96", "708.6", "145", "145", "505.08", "2875", "7310", "16.29", "[Kr]4d\x00B9\x20705s\x00B25p\x00B2", NO, NO};

	Array isotopes = {
	    50, NULL, POSITRON, "1s",
	    51, NULL, POSITRON, "3s",
	    52, NULL, POSITRON, "4.5s",
	    53, NULL, POSITRON, "7s",
	    54, NULL, POSITRON, "20.8s",
	    55, NULL, POSITRON, "34s",
	    56, NULL, EC, "2.0m",
	    57, NULL, POSITRON, "2.9m",
	    58, NULL, EC, "10.3m",
	    59, NULL, POSITRON, "18m",
	    60, NULL, EC, "4.1h",
	    61, NULL, EC, "35m",
	    62, "0.97", NULL, NULL,
	    63, NULL, EC, "115.1d",
	    64, "0.66", NULL, NULL,
	    65, "0.34", NULL, NULL,
	    66, "14.54", NULL, NULL,
	    67, "7.68", NULL, NULL,
	    68, "24.22", NULL, NULL,
	    69, "8.59", NULL, NULL,
	    70, "32.58", NULL, NULL,
	    71, NULL, BETA, "1.13d",
	    72, "4.63", NULL, NULL,
	    73, NULL, BETA, "129.2d",
	    74, "5.79", NULL, NULL,
	    75, NULL, BETA, "9.5m",
	    76, NULL, BETA, "2.3\x00D710\x2075y",
	    77, NULL, BETA, "4.15m",
	    78, NULL, BETA, "59.1m",
	    79, NULL, BETA, "2.4m",
	    80, NULL, BETA, "1.7m",
	    81, NULL, BETA, "56s",
	    82, NULL, BETA, "40s",
	    83, NULL, BETA, "1.44s",
	    84, NULL, BETA, "1.04s",
	    85, NULL, BETA, "530ms",
	    86, NULL, BETA, "260ms",
	    87, NULL, BETA, "240ms",
	};
	int primary_isotope = 70;
    },
    new Dictionary {
	String name = "Antimony";
	String symbol = "Sb";
	int    Z = 51;
	int    period = 5;

	Array properties = {"15", "p", SEMIMETAL, SOLID, "121.760(1)", "2.05", "834", "145", "133", "903.78", "1860", "6697", "18.19", "[Kr]4d\x00B9\x20705s\x00B25p\x00B3", NO, NO};

	Array isotopes = {
	    53, NULL, POSITRON, "400ms",
	    54, NULL, POSITRON, "1.3s",
	    55, NULL, POSITRON, "600ms",
	    56, NULL, POSITRON, "4.0s",
	    57, NULL, POSITRON, "7.4s",
	    58, NULL, POSITRON, "17s",
	    59, NULL, POSITRON, "24s",
	    60, NULL, EC, "1.25m",
	    61, NULL, POSITRON, "51.4s",
	    62, NULL, POSITRON, "6.7m",
	    63, NULL, POSITRON, "3.5m",
	    64, NULL, EC, "32.1m",
	    65, NULL, EC, "16m",
	    66, NULL, EC, "2.80h",
	    67, NULL, POSITRON, "3.6m",
	    68, NULL, EC, "38.1h",
	    69, NULL, EC, "15.9m",
	    70, "57.21", NULL, NULL,
	    71, NULL, BETA, "2.72d",
	    72, "42.79", NULL, NULL,
	    73, NULL, BETA, "60.2d",
	    74, NULL, BETA, "2.76y",
	    75, NULL, BETA, "12.4d",
	    76, NULL, BETA, "3.84d",
	    77, NULL, BETA, "10.1m",
	    78, NULL, BETA, "17.7m",
	    79, NULL, BETA, "6.3m",
	    80, NULL, BETA, "23.0m",
	    81, NULL, BETA, "2.8m",
	    82, NULL, BETA, "2.5m",
	    83, NULL, BETA, "800ms",
	    84, NULL, BETA, "1.7s",
	    85, NULL, BETA, "920ms",
	    86, NULL, BETA, "900ms",
	};
	int primary_isotope = 70;
    },
    new Dictionary {
	String name = "Tellurium";
	String symbol = "Te";
	int    Z = 52;
	int    period = 5;

	Array properties = {"16", "p", SEMIMETAL, SOLID, "127.60(3)", "2.1", "869.3", "140", "123", "722.66", "1261", "6240", "20.46", "[Kr]4d\x00B9\x20705s\x00B25p\x2074", NO, NO};

	Array isotopes = {
	    54, NULL, ALPHA, "0.06ms",
	    55, NULL, ALPHA, "3.1ms",
	    56, NULL, ALPHA, "2.1s",
	    57, NULL, POSITRON, "4.6s",
	    58, NULL, POSITRON, "19s",
	    59, NULL, POSITRON, "19.3s",
	    60, NULL, POSITRON, "2.0m",
	    61, NULL, POSITRON, "1.7m",
	    62, NULL, POSITRON, "15m",
	    63, NULL, POSITRON, "5.8m",
	    64, NULL, EC, "2.49h",
	    65, NULL, EC, "1.03h",
	    66, NULL, EC, "6.00d",
	    67, NULL, EC, "16h",
	    68, "0.09", NULL, NULL,
	    69, NULL, EC, "16.8d",
	    70, "2.55", NULL, NULL,
	    71, "0.89", NULL, NULL,
	    72, "4.74", NULL, NULL,
	    73, "7.07", NULL, NULL,
	    74, "18.84", NULL, NULL,
	    75, NULL, BETA, "9.4h",
	    76, "31.74", NULL, NULL,
	    77, NULL, BETA, "1.16h",
	    78, "34.08", NULL, NULL,
	    79, NULL, BETA, "25.0m",
	    80, NULL, BETA, "3.20d",
	    81, NULL, BETA, "12.4m",
	    82, NULL, BETA, "42m",
	    83, NULL, BETA, "19.0s",
	    84, NULL, BETA, "17.5s",
	    85, NULL, BETA, "2.5s",
	    86, NULL, BETA, "1.4s",
	};
	int primary_isotope = 78;
    },
    new Dictionary {
	String name = "Iodine";
	String symbol = "I";
	int    Z = 53;
	int    period = 5;

	Array properties = {"17", "p", NONMETAL, SOLID, "126.90447(3)", "2.66", "1008.4", "140", "115", "386.85", "457.4", "4940", "25.72", "[Kr]4d\x00B9\x20705s\x00B25p\x2075", NO, NO};

	Array isotopes = {
	    55, NULL, ALPHA, "36ms",
	    56, NULL, PROTON, "0.1ms",
	    57, NULL, EC, "650ms",
	    58, NULL, EC, "2.5s",
	    59, NULL, EC, "3.4s",
	    60, NULL, EC, "5.9s",
	    61, NULL, EC, "2.1s",
	    62, NULL, EC, "1.3m",
	    63, NULL, POSITRON, "2.9s",
	    64, NULL, POSITRON, "2.22m",
	    65, NULL, EC, "8.5m",
	    66, NULL, POSITRON, "19.1m",
	    67, NULL, POSITRON, "53m",
	    68, NULL, EC, "2.12h",
	    69, NULL, POSITRON, "3.6m",
	    70, NULL, EC, "13.2h",
	    71, NULL, EC, "4.176d",
	    72, NULL, EC, "59.4d",
	    73, NULL, EC, "13.0d",
	    74, "100", NULL, NULL,
	    75, NULL, BETA, "25.0m",
	    76, NULL, BETA, "1.57\x00D710\x2077y",
	    77, NULL, BETA, "12.36h",
	    78, NULL, BETA, "8.02d",
	    79, NULL, BETA, "2.285h",
	    80, NULL, BETA, "20.8h",
	    81, NULL, BETA, "3.7m",
	    82, NULL, BETA, "6.57h",
	    83, NULL, BETA, "47s",
	    84, NULL, BETA, "24.5s",
	    85, NULL, BETA, "6.5s",
	    86, NULL, BETA, "2.3s",
	    87, NULL, BETA, "860ms",
	    88, NULL, BETA, "450ms",
	    89, NULL, BETA, "200ms",
	};
	int primary_isotope = 74;
    },
    new Dictionary {
	String name = "Xenon";
	String symbol = "Xe";
	int    Z = 54;
	int    period = 5;

	Array properties = {"18", "p", NONMETAL, GAS, "131.293(6)", "2.6", "1170.4", "", "108", "161.4", "165.1", "", "35.92", "[Kr]4d\x00B9\x20705s\x00B25p\x2076", NO, NO};

	Array isotopes = {
	    56, NULL, EC, "200ms",
	    57, NULL, EC, "700ms",
	    58, NULL, EC, "3s",
	    59, NULL, EC, "2.8s",
	    60, NULL, EC, "10.0s",
	    61, NULL, EC, "18s",
	    62, NULL, EC, "56s",
	    63, NULL, EC, "1.02m",
	    64, NULL, EC, "4m",
	    65, NULL, EC, "5.8m",
	    66, NULL, EC, "40m",
	    67, NULL, POSITRON, "39m",
	    68, NULL, EC, "20.1h",
	    69, NULL, EC, "2.0h",
	    70, "0.09", NULL, NULL,
	    71, NULL, EC, "17.1h",
	    72, "0.09", NULL, NULL,
	    73, NULL, EC, "36.4d",
	    74, "1.92", NULL, NULL,
	    75, "26.44", NULL, NULL,
	    76, "4.08", NULL, NULL,
	    77, "21.18", NULL, NULL,
	    78, "26.89", NULL, NULL,
	    79, NULL, BETA, "5.24d",
	    80, "10.44", NULL, NULL,
	    81, NULL, BETA, "9.1h",
	    82, "8.87", NULL, NULL,
	    83, NULL, BETA, "3.82m",
	    84, NULL, BETA, "14.1m",
	    85, NULL, BETA, "39.7s",
	    86, NULL, BETA, "13.6s",
	    87, NULL, BETA, "1.72s",
	    88, NULL, BETA, "1.22s",
	    89, NULL, BETA, "300ms",
	    90, NULL, BETA, "1.2s",
	    91, NULL, BETA, "900ms",
	};
	int primary_isotope = 78;
    },
    new Dictionary {
	String name = "Caesium";
	String symbol = "Cs";
	int    Z = 55;
	int    period = 6;

	Array properties = {"1", "s", METAL, SOLID, "132.9054519(2)", "0.79", "375.7", "260", "298", "301.59", "944", "1879", "70.94", "[Xe]6s\x00B9", NO, NO};

	Array isotopes = {
	    57, NULL, PROTON, "0.5ms",
	    58, NULL, PROTON, "17us",
	    59, NULL, POSITRON, "580s",
	    60, NULL, EC, "1.4s",
	    61, NULL, POSITRON, "700ms",
	    62, NULL, POSITRON, "6.5s",
	    63, NULL, POSITRON, "14s",
	    64, NULL, POSITRON, "30.4s",
	    65, NULL, POSITRON, "57s",
	    66, NULL, POSITRON, "2.0m",
	    67, NULL, POSITRON, "21s",
	    68, NULL, POSITRON, "5.94m",
	    69, NULL, POSITRON, "30s",
	    70, NULL, EC, "45m",
	    71, NULL, POSITRON, "1.64m",
	    72, NULL, EC, "6.2h",
	    73, NULL, POSITRON, "3.62m",
	    74, NULL, EC, "1.34d",
	    75, NULL, EC, "29.2m",
	    76, NULL, EC, "9.69d",
	    77, NULL, EC, "6.48d",
	    78, "100", NULL, NULL,
	    79, NULL, BETA, "2.065y",
	    80, NULL, BETA, "2.3\x00D710\x2076y",
	    81, NULL, BETA, "13.2d",
	    82, NULL, BETA, "30.1y",
	    83, NULL, BETA, "32.2m",
	    84, NULL, BETA, "9.3m",
	    85, NULL, BETA, "1.06m",
	    86, NULL, BETA, "25s",
	    87, NULL, BETA, "1.8s",
	    88, NULL, BETA, "1.8s",
	    89, NULL, BETA, "1.01s",
	    90, NULL, BETA, "590ms",
	    91, NULL, BETA, "322ms",
	    92, NULL, BETA, "227ms",
	    93, NULL, BETA, "150ms",
	};
	int primary_isotope = 78;
    },
    new Dictionary {
	String name = "Barium";
	String symbol = "Ba";
	int    Z = 56;
	int    period = 6;

	Array properties = {"2", "s", METAL, SOLID, "137.327(7)", "0.89", "502.9", "215", "253", "1000", "2143", "3510", "38.16", "[Xe]6s\x00B2", NO, NO};

	Array isotopes = {
	    58, NULL, POSITRON, "400ms",
	    59, NULL, POSITRON, "450ms",
	    60, NULL, POSITRON, "1.3s",
	    61, NULL, POSITRON, "1.8s",
	    62, NULL, POSITRON, "5.2s",
	    63, NULL, POSITRON, "5.4s",
	    64, NULL, POSITRON, "24s",
	    65, NULL, POSITRON, "30s",
	    66, NULL, POSITRON, "2.0m",
	    67, NULL, POSITRON, "2.7m",
	    68, NULL, EC, "12m",
	    69, NULL, POSITRON, "3.5m",
	    70, NULL, EC, "1.65h",
	    71, NULL, POSITRON, "12.9m",
	    72, NULL, EC, "2.43d",
	    73, NULL, POSITRON, "2.2h",
	    74, "0.106", NULL, NULL,
	    75, NULL, EC, "11.5d",
	    76, "0.101", NULL, NULL,
	    77, NULL, EC, "10.53y",
	    78, "2.417", NULL, NULL,
	    79, "6.592", NULL, NULL,
	    80, "7.854", NULL, NULL,
	    81, "11.232", NULL, NULL,
	    82, "71.698", NULL, NULL,
	    83, NULL, BETA, "1.4h",
	    84, NULL, BETA, "12.75d",
	    85, NULL, BETA, "18.3m",
	    86, NULL, BETA, "10.7m",
	    87, NULL, BETA, "14.3s",
	    88, NULL, BETA, "11.4s",
	    89, NULL, BETA, "4.0s",
	    90, NULL, BETA, "2.2s",
	    91, NULL, BETA, "892ms",
	    92, NULL, BETA, "640ms",
	    93, NULL, BETA, "340ms",
	    94, NULL, BETA, "300ms",
	};
	int primary_isotope = 82;
    },
    new Dictionary {
	String name = "Lanthanum";
	String symbol = "La";
	int    Z = 57;
	int    period = 6;

	Array properties = {"3", "d", METAL, SOLID, "138.90547(7)", "1.10", "538.1", "195", "", "1193", "3743", "6146", "22.39", "[Xe]5d\x00B96s\x00B2", TRACE, NO};

	Array isotopes = {
	    63, NULL, EC, "2.8s",
	    64, NULL, POSITRON, "5.3s",
	    65, NULL, EC, "9s",
	    66, NULL, EC, "17s",
	    67, NULL, POSITRON, "21s",
	    68, NULL, POSITRON, "1.2m",
	    69, NULL, POSITRON, "50s",
	    70, NULL, POSITRON, "3.7m",
	    71, NULL, POSITRON, "4.6m",
	    72, NULL, POSITRON, "11.6m",
	    73, NULL, POSITRON, "8.7m",
	    74, NULL, EC, "59m",
	    75, NULL, POSITRON, "4.8h",
	    76, NULL, EC, "3.9h",
	    77, NULL, POSITRON, "6.5m",
	    78, NULL, EC, "19.5h",
	    79, NULL, EC, "9.87m",
	    80, NULL, POSITRON, "6\x00D710\x2074y",
	    81, "0.090", EC, "1.05\x00D710\x00B9\x00B9y",
	    82, "99.910", NULL, NULL,
	    83, NULL, BETA, "1.68d",
	    84, NULL, BETA, "3.90h",
	    85, NULL, BETA, "1.54h",
	    86, NULL, BETA, "14.2m",
	    87, NULL, BETA, "40.7s",
	    88, NULL, BETA, "24s",
	    89, NULL, BETA, "6.3s",
	    90, NULL, BETA, "4.02s",
	    91, NULL, BETA, "1.1s",
	    92, NULL, BETA, "1.05s",
	    93, NULL, BETA, "510ms",
	};
	int primary_isotope = 82;
    },
    new Dictionary {
	String name = "Cerium";
	String symbol = "Ce";
	int    Z = 58;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "140.116(1)", "1.12", "534.4", "185", "", "1068", "3633", "6689", "20.69", "[Xe]4f\x00B95d\x00B96s\x00B2", NO, NO};

	Array isotopes = {
	    63, NULL, POSITRON, "1.1s",
	    65, NULL, EC, "3.8s",
	    66, NULL, EC, "6s",
	    67, NULL, EC, "9s",
	    68, NULL, EC, "50s",
	    69, NULL, POSITRON, "34s",
	    70, NULL, EC, "4m",
	    71, NULL, EC, "3.5m",
	    72, NULL, EC, "23m",
	    73, NULL, EC, "5m",
	    74, NULL, EC, "3.5h",
	    75, NULL, EC, "1.6h",
	    76, NULL, EC, "3.16d",
	    77, NULL, EC, "17.7h",
	    78, "0.185", NULL, NULL,
	    79, NULL, EC, "9.0h",
	    80, "0.251", NULL, NULL,
	    81, NULL, EC, "137.6d",
	    82, "88.450", NULL, NULL,
	    83, NULL, BETA, "32.5d",
	    84, "11.114", NULL, NULL,
	    85, NULL, BETA, "1.38d",
	    86, NULL, BETA, "284.6d",
	    87, NULL, BETA, "3.0m",
	    88, NULL, BETA, "13.5m",
	    89, NULL, BETA, "56s",
	    90, NULL, BETA, "56s",
	    91, NULL, BETA, "5.2s",
	    92, NULL, BETA, "4.4s",
	    93, NULL, BETA, "1.0s",
	    94, NULL, BETA, "1.4s",
	};
	int primary_isotope = 82;
    },
    new Dictionary {
	String name = "Praseodymium";
	String symbol = "Pr";
	int    Z = 59;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "140.90765(2)", "1.13", "527", "185", "247", "1208", "3563", "6640", "20.80", "[Xe]4f\x00B36s\x00B2", NO, NO};

	Array isotopes = {
	    65, NULL, EC, "1.2s",
	    66, NULL, POSITRON, "3s",
	    67, NULL, EC, "3.1s",
	    68, NULL, EC, "8s",
	    69, NULL, POSITRON, "2.8s",
	    70, NULL, POSITRON, "30s",
	    71, NULL, POSITRON, "40s",
	    72, NULL, POSITRON, "1.53m",
	    73, NULL, POSITRON, "1.7m",
	    74, NULL, POSITRON, "6.5m",
	    75, NULL, POSITRON, "11m",
	    76, NULL, POSITRON, "24m",
	    77, NULL, EC, "13.1m",
	    78, NULL, EC, "1.28h",
	    79, NULL, POSITRON, "1.45m",
	    80, NULL, EC, "4.41h",
	    81, NULL, EC, "3.39m",
	    82, "100", NULL, NULL,
	    83, NULL, BETA, "19.12h",
	    84, NULL, BETA, "13.57d",
	    85, NULL, BETA, "17.28m",
	    86, NULL, BETA, "5.98h",
	    87, NULL, BETA, "24.2m",
	    88, NULL, BETA, "13.4m",
	    89, NULL, BETA, "2.0m",
	    90, NULL, BETA, "2.3m",
	    91, NULL, BETA, "6.2s",
	    92, NULL, BETA, "19s",
	    93, NULL, BETA, "3.2s",
	    94, NULL, BETA, "4.3s",
	    95, NULL, BETA, "2.3s",
	};
	int primary_isotope = 82;
    },
    new Dictionary {
	String name = "Neodymium";
	String symbol = "Nd";
	int    Z = 60;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "144.242(3)", "1.14", "533.1", "185", "206", "1297", "3373", "6800", "20.59", "[Xe]4f\x20746s\x00B2", TRACE, NO};

	Array isotopes = {
	    65, NULL, POSITRON, "600ms",
	    67, NULL, EC, "1.8s",
	    69, NULL, EC, "4.9s",
	    70, NULL, POSITRON, "21s",
	    71, NULL, EC, "28s",
	    72, NULL, POSITRON, "1.5m",
	    73, NULL, POSITRON, "1.2m",
	    74, NULL, EC, "8.5m",
	    75, NULL, POSITRON, "5.5m",
	    76, NULL, EC, "50.6m",
	    77, NULL, EC, "38m",
	    78, NULL, EC, "5.1h",
	    79, NULL, EC, "30m",
	    80, NULL, EC, "3.37d",
	    81, NULL, EC, "2.49h",
	    82, "27.2", NULL, NULL,
	    83, "12.2", NULL, NULL,
	    84, "23.8", ALPHA, "2.4\x00D710\x00B9\x2075y",
	    85, "8.3", NULL, NULL,
	    86, "17.2", NULL, NULL,
	    87, NULL, BETA, "10.98d",
	    88, "5.7", NULL, NULL,
	    89, NULL, BETA, "1.73h",
	    90, "5.6", NULL, NULL,
	    91, NULL, BETA, "12.4m",
	    92, NULL, BETA, "11.4m",
	    93, NULL, BETA, "32s",
	    94, NULL, BETA, "26s",
	    95, NULL, BETA, "8.9s",
	    96, NULL, BETA, "5.5s",
	};
	int primary_isotope = 82;
    },
    new Dictionary {
	String name = "Promethium";
	String symbol = "Pm";
	int    Z = 61;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "[145]", "", "540", "185", "205", "1373", "3273", "7264", "20.23", "[Xe]4f\x20756s\x00B2", YES, NO};

	Array isotopes = {
	    67, NULL, POSITRON, "1.0s",
	    69, NULL, POSITRON, "2.5s",
	    70, NULL, POSITRON, "6s",
	    71, NULL, POSITRON, "6s",
	    72, NULL, POSITRON, "14s",
	    73, NULL, POSITRON, "5s",
	    74, NULL, POSITRON, "45s",
	    75, NULL, POSITRON, "47s",
	    76, NULL, POSITRON, "2.4m",
	    77, NULL, POSITRON, "10s",
	    78, NULL, POSITRON, "4.14m",
	    79, NULL, EC, "9.2s",
	    80, NULL, EC, "20.9m",
	    81, NULL, POSITRON, "40.5s",
	    82, NULL, EC, "265d",
	    83, NULL, EC, "360d",
	    84, NULL, EC, "17.7y",
	    85, NULL, EC, "5.53y",
	    86, NULL, BETA, "2.62y",
	    87, NULL, BETA, "5.37d",
	    88, NULL, BETA, "2.21d",
	    89, NULL, BETA, "2.68h",
	    90, NULL, BETA, "1.18d",
	    91, NULL, BETA, "4.1m",
	    92, NULL, BETA, "5.4m",
	    93, NULL, BETA, "1.7m",
	    94, NULL, BETA, "42s",
	    95, NULL, BETA, "26.7s",
	    96, NULL, BETA, "10.9s",
	    97, NULL, BETA, "5s",
	    98, NULL, BETA, "2s",
	};
	int primary_isotope = 84;
    },
    new Dictionary {
	String name = "Samarium";
	String symbol = "Sm";
	int    Z = 62;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "150.36(2)", "1.17", "544.5", "185", "238", "1345", "2076", "7353", "19.98", "[Xe]4f\x20766s\x00B2", TRACE, NO};

	Array isotopes = {
	    67, NULL, POSITRON, "600ms",
	    69, NULL, POSITRON, "1.6s",
	    71, NULL, EC, "2.9s",
	    72, NULL, POSITRON, "11s",
	    73, NULL, POSITRON, "10s",
	    74, NULL, POSITRON, "47s",
	    75, NULL, POSITRON, "45s",
	    76, NULL, POSITRON, "3.1m",
	    77, NULL, POSITRON, "2.6m",
	    78, NULL, EC, "14.8m",
	    79, NULL, POSITRON, "10.2m",
	    80, NULL, EC, "1.21h",
	    81, NULL, EC, "8.83m",
	    82, "3.07", NULL, NULL,
	    83, NULL, EC, "340d",
	    84, NULL, ALPHA, "1.0\x00D710\x2078y",
	    85, "14.99", ALPHA, "1.1\x00D710\x00B9\x00B9y",
	    86, "11.24", ALPHA, "7\x00D710\x00B9\x2075y",
	    87, "13.82", NULL, NULL,
	    88, "7.38", NULL, NULL,
	    89, NULL, BETA, "90y",
	    90, "26.75", NULL, NULL,
	    91, NULL, BETA, "1.93d",
	    92, "22.75", NULL, NULL,
	    93, NULL, BETA, "22.2m",
	    94, NULL, BETA, "9.4h",
	    95, NULL, BETA, "8m",
	    96, NULL, BETA, "5.3m",
	    97, NULL, BETA, "11.4s",
	    98, NULL, BETA, "9.6s",
	    99, NULL, BETA, "5s",
	};
	int primary_isotope = 90;
    },
    new Dictionary {
	String name = "Europium";
	String symbol = "Eu";
	int    Z = 63;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "151.964(1)", "", "547.1", "185", "231", "1099", "1800", "5244", "28.97", "[Xe]4f\x20776s\x00B2", TRACE, NO};

	Array isotopes = {
	    71, NULL, EC, "500ms",
	    72, NULL, EC, "1.5s",
	    73, NULL, EC, "3.7s",
	    75, NULL, EC, "12.1s",
	    76, NULL, POSITRON, "18s",
	    77, NULL, EC, "1.51s",
	    78, NULL, POSITRON, "40s",
	    79, NULL, POSITRON, "2.4s",
	    80, NULL, POSITRON, "2.62m",
	    81, NULL, POSITRON, "10.2s",
	    82, NULL, EC, "5.93d",
	    83, NULL, EC, "4.57d",
	    84, NULL, EC, "24.4d",
	    85, NULL, EC, "54.5d",
	    86, NULL, EC, "93.1d",
	    87, NULL, BETA, "12.8h",
	    88, "47.81", ALPHA, "5\x00D710\x00B9\x2078y",
	    89, NULL, EC, "13.54y",
	    90, "52.19", NULL, NULL,
	    91, NULL, BETA, "8.59y",
	    92, NULL, BETA, "4.75y",
	    93, NULL, BETA, "15.2d",
	    94, NULL, BETA, "15.18h",
	    95, NULL, BETA, "45.9m",
	    96, NULL, BETA, "18.1m",
	    97, NULL, BETA, "38s",
	    98, NULL, BETA, "26s",
	    99, NULL, BETA, "11s",
	};
	int primary_isotope = 90;
    },
    new Dictionary {
	String name = "Gadolinium";
	String symbol = "Gd";
	int    Z = 64;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "157.25(3)", "1.20", "593.4", "180", "233", "1585", "3523", "7901", "19.90", "[Xe]4f\x20775d\x00B96s\x00B2", TRACE, NO};

	Array isotopes = {
	    71, NULL, POSITRON, "1.1s",
	    73, NULL, EC, "2.2s",
	    74, NULL, EC, "5s",
	    75, NULL, EC, "5s",
	    76, NULL, EC, "16.2s",
	    77, NULL, EC, "14s",
	    78, NULL, POSITRON, "1.17m",
	    79, NULL, POSITRON, "39s",
	    80, NULL, POSITRON, "4.5m",
	    81, NULL, EC, "23.4m",
	    82, NULL, EC, "48.3d",
	    83, NULL, EC, "1.59d",
	    84, NULL, ALPHA, "75y",
	    85, NULL, EC, "9.3d",
	    86, NULL, ALPHA, "1.8\x00D710\x2076y",
	    87, NULL, EC, "124d",
	    88, "0.20", ALPHA, "1.1\x00D710\x00B9\x2074y",
	    89, NULL, EC, "241.6d",
	    90, "2.18", NULL, NULL,
	    91, "14.80", NULL, NULL,
	    92, "20.47", NULL, NULL,
	    93, "15.65", NULL, NULL,
	    94, "24.84", NULL, NULL,
	    95, NULL, BETA, "18.5h",
	    96, "21.86", NULL, NULL,
	    97, NULL, BETA, "3.66m",
	    98, NULL, BETA, "8.4m",
	    99, NULL, BETA, "1.13m",
	    100, NULL, BETA, "45s",
	    101, NULL, BETA, "10s",
	};
	int primary_isotope = 94;
    },
    new Dictionary {
	String name = "Terbium";
	String symbol = "Tb";
	int    Z = 65;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "158.92535(2)", "", "565.8", "175", "225", "1629", "3503", "8219", "19.30", "[Xe]4f\x20796s\x00B2", NO, NO};

	Array isotopes = {
	    74, NULL, EC, "1.6s",
	    75, NULL, EC, "2.2s",
	    76, NULL, EC, "3.5s",
	    77, NULL, POSITRON, "600ms",
	    78, NULL, EC, "12s",
	    79, NULL, EC, "1s",
	    80, NULL, POSITRON, "30s",
	    81, NULL, POSITRON, "8s",
	    82, NULL, POSITRON, "1.8m",
	    83, NULL, EC, "2.3m",
	    84, NULL, EC, "4.16m",
	    85, NULL, POSITRON, "6.0m",
	    86, NULL, EC, "17.6h",
	    87, NULL, EC, "4.2m",
	    88, NULL, EC, "2.34d",
	    89, NULL, EC, "21.5h",
	    90, NULL, EC, "5.3d",
	    91, NULL, EC, "5.3d",
	    92, NULL, EC, "70y",
	    93, NULL, EC, "180y",
	    94, "100", NULL, NULL,
	    95, NULL, BETA, "72.3d",
	    96, NULL, BETA, "6.91d",
	    97, NULL, BETA, "7.6m",
	    98, NULL, BETA, "19.5m",
	    99, NULL, BETA, "3.0m",
	    100, NULL, BETA, "2.1m",
	    101, NULL, BETA, "20s",
	    102, NULL, BETA, "19s",
	    103, NULL, BETA, "8s",
	};
	int primary_isotope = 94;
    },
    new Dictionary {
	String name = "Dysprosium";
	String symbol = "Dy";
	int    Z = 66;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "162.500(1)", "1.22", "573.0", "175", "228", "1680", "2840", "8551", "19.01", "[Xe]4f\x00B9\x20706s\x00B2", NO, NO};

	Array isotopes = {
	    73, NULL, POSITRON, "600ms",
	    75, NULL, EC, "900ms",
	    76, NULL, POSITRON, "2.3s",
	    77, NULL, EC, "3.9s",
	    78, NULL, EC, "9.1s",
	    79, NULL, EC, "14s",
	    80, NULL, EC, "33.2s",
	    81, NULL, EC, "56s",
	    82, NULL, EC, "3.1m",
	    83, NULL, EC, "4.2m",
	    84, NULL, POSITRON, "7.18m",
	    85, NULL, POSITRON, "18m",
	    86, NULL, EC, "2.37h",
	    87, NULL, EC, "6.3h",
	    88, NULL, ALPHA, "3\x00D710\x2076y",
	    89, NULL, POSITRON, "9.9h",
	    90, "0.06", NULL, NULL,
	    91, NULL, EC, "8.1h",
	    92, "0.10", NULL, NULL,
	    93, NULL, EC, "144.4d",
	    94, "2.34", NULL, NULL,
	    95, "18.91", NULL, NULL,
	    96, "25.51", NULL, NULL,
	    97, "24.90", NULL, NULL,
	    98, "28.18", NULL, NULL,
	    99, NULL, BETA, "2.33h",
	    100, NULL, BETA, "3.40d",
	    101, NULL, BETA, "6.2m",
	    102, NULL, BETA, "8.8m",
	    103, NULL, BETA, "39s",
	};
	int primary_isotope = 98;
    },
    new Dictionary {
	String name = "Holmium";
	String symbol = "Ho";
	int    Z = 67;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "164.93032(2)", "1.23", "581.0", "175", "226", "1734", "2993", "8795", "18.74", "[Xe]4f\x00B9\x00B96s\x00B2", NO, NO};

	Array isotopes = {
	    73, NULL, PROTON, "6ms",
	    74, NULL, PROTON, "7us",
	    75, NULL, POSITRON, "400ms",
	    77, NULL, EC, "700ms",
	    78, NULL, EC, "2.4s",
	    79, NULL, EC, "3.3s",
	    80, NULL, EC, "5.8s",
	    81, NULL, POSITRON, "2s",
	    82, NULL, POSITRON, "21.1s",
	    83, NULL, POSITRON, "23.3s",
	    84, NULL, POSITRON, "35.2s",
	    85, NULL, POSITRON, "50.3s",
	    86, NULL, EC, "2.0m",
	    87, NULL, EC, "3.1m",
	    88, NULL, EC, "48m",
	    89, NULL, EC, "5.8m",
	    90, NULL, EC, "12.6m",
	    91, NULL, EC, "11.3m",
	    92, NULL, EC, "33m",
	    93, NULL, EC, "25.6m",
	    94, NULL, EC, "2.48h",
	    95, NULL, EC, "15m",
	    96, NULL, EC, "4570y",
	    97, NULL, BETA, "29m",
	    98, "100", NULL, NULL,
	    99, NULL, BETA, "1200y",
	    100, NULL, BETA, "3.1h",
	    101, NULL, BETA, "3.0m",
	    102, NULL, BETA, "4.7m",
	    103, NULL, BETA, "43s",
	    104, NULL, BETA, "53s",
	    105, NULL, BETA, "25s",
	};
	int primary_isotope = 98;
    },
    new Dictionary {
	String name = "Erbium";
	String symbol = "Er";
	int    Z = 68;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "167.259(3)", "1.24", "589.3", "175", "226", "1770", "3141", "9066", "18.46", "[Xe]4f\x00B9\x00B26s\x00B2", NO, NO};

	Array isotopes = {
	    78, NULL, EC, "2s",
	    79, NULL, POSITRON, "2.5s",
	    80, NULL, POSITRON, "4.7s",
	    81, NULL, EC, "4s",
	    82, NULL, EC, "18s",
	    83, NULL, POSITRON, "23s",
	    84, NULL, ALPHA, "10.3s",
	    85, NULL, ALPHA, "37.1s",
	    86, NULL, EC, "3.7m",
	    87, NULL, EC, "5.3m",
	    88, NULL, EC, "20m",
	    89, NULL, EC, "18.6m",
	    90, NULL, EC, "2.29h",
	    91, NULL, EC, "36m",
	    92, NULL, EC, "1.19d",
	    93, NULL, EC, "3.21h",
	    94, "0.14", NULL, NULL,
	    95, NULL, EC, "1.25h",
	    96, "1.61", NULL, NULL,
	    97, NULL, EC, "10.36h",
	    98, "33.61", NULL, NULL,
	    99, "22.93", NULL, NULL,
	    100, "26.78", NULL, NULL,
	    101, NULL, BETA, "9.4d",
	    102, "14.93", NULL, NULL,
	    103, NULL, BETA, "7.52h",
	    104, NULL, BETA, "2.05d",
	    105, NULL, BETA, "1.4m",
	    106, NULL, BETA, "3.2m",
	    107, NULL, BETA, "1.2m",
	};
	int primary_isotope = 98;
    },
    new Dictionary {
	String name = "Thulium";
	String symbol = "Tm";
	int    Z = 69;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "168.93421(2)", "1.25", "596.7", "175", "222", "1818", "2223", "9321", "19.1", "[Xe]4f\x00B9\x00B36s\x00B2", NO, NO};

	Array isotopes = {
	    77, NULL, EC, "240ms",
	    78, NULL, EC, "580ms",
	    79, NULL, EC, "700ms",
	    80, NULL, EC, "900ms",
	    81, NULL, EC, "2.2s",
	    82, NULL, EC, "4.1s",
	    83, NULL, EC, "5s",
	    84, NULL, ALPHA, "1.5s",
	    85, NULL, ALPHA, "3.3s",
	    86, NULL, POSITRON, "22s",
	    87, NULL, POSITRON, "1.4m",
	    88, NULL, POSITRON, "3.6m",
	    89, NULL, POSITRON, "4m",
	    90, NULL, EC, "9.1m",
	    91, NULL, EC, "9.4m",
	    92, NULL, EC, "31m",
	    93, NULL, EC, "21.7m",
	    94, NULL, EC, "1.8h",
	    95, NULL, EC, "2.0m",
	    96, NULL, EC, "1.25d",
	    97, NULL, EC, "7.70h",
	    98, NULL, EC, "9.24d",
	    99, NULL, EC, "93.1d",
	    100, "100", NULL, NULL,
	    101, NULL, BETA, "128.6d",
	    102, NULL, BETA, "1.92y",
	    103, NULL, BETA, "2.65d",
	    104, NULL, BETA, "8.2h",
	    105, NULL, BETA, "5.4m",
	    106, NULL, BETA, "15m",
	    107, NULL, BETA, "1.9m",
	    108, NULL, BETA, "1.4m",
	};
	int primary_isotope = 100;
    },
    new Dictionary {
	String name = "Ytterbium";
	String symbol = "Yb";
	int    Z = 70;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "173.04(3)", "", "603.4", "175", "222", "1097", "1469", "6570", "24.84", "[Xe]4f\x00B9\x20746s\x00B2", NO, NO};

	Array isotopes = {
	    81, NULL, POSITRON, "1.6s",
	    82, NULL, POSITRON, "3.1s",
	    83, NULL, ALPHA, "4s",
	    84, NULL, ALPHA, "409ms",
	    85, NULL, ALPHA, "1.7s",
	    86, NULL, EC, "26s",
	    87, NULL, EC, "39s",
	    88, NULL, EC, "1.5m",
	    89, NULL, EC, "1.5m",
	    90, NULL, EC, "4.8m",
	    91, NULL, EC, "4.2m",
	    92, NULL, EC, "18.9m",
	    93, NULL, EC, "11.1m",
	    94, NULL, EC, "1.26h",
	    95, NULL, EC, "9.9m",
	    96, NULL, EC, "2.36d",
	    97, NULL, EC, "17.5m",
	    98, "0.13", NULL, NULL,
	    99, NULL, EC, "32.0d",
	    100, "3.04", NULL, NULL,
	    101, "14.28", NULL, NULL,
	    102, "21.83", NULL, NULL,
	    103, "16.13", NULL, NULL,
	    104, "31.83", NULL, NULL,
	    105, NULL, BETA, "4.19d",
	    106, "12.76", NULL, NULL,
	    107, NULL, BETA, "1.9h",
	    108, NULL, BETA, "1.23h",
	    109, NULL, BETA, "8m",
	    110, NULL, BETA, "2m",
	};
	int primary_isotope = 104;
    },
    new Dictionary {
	String name = "Lutetium";
	String symbol = "Lu";
	int    Z = 71;
	int    period = 6;

	Array properties = {"", "f", METAL, SOLID, "174.967(1)", "1.27", "523.5", "175", "217", "1925", "3675", "9841", "17.78", "[Xe]4f\x00B9\x20745d\x00B96s\x00B2", TRACE, NO};

	Array isotopes = {
	    81, NULL, EC, "700ms",
	    82, NULL, POSITRON, "900ms",
	    83, NULL, EC, "1.1s",
	    84, NULL, ALPHA, "69ms",
	    85, NULL, ALPHA, "198ms",
	    86, NULL, ALPHA, "10s",
	    87, NULL, EC, "10.4s",
	    88, NULL, EC, "12.3s",
	    89, NULL, EC, "36.1s",
	    90, NULL, EC, "1.28m",
	    91, NULL, EC, "1.37m",
	    92, NULL, POSITRON, "4.0m",
	    93, NULL, EC, "3.14m",
	    94, NULL, EC, "10.7m",
	    95, NULL, EC, "2.1m",
	    96, NULL, EC, "52m",
	    97, NULL, EC, "5.5m",
	    98, NULL, EC, "1.42d",
	    99, NULL, EC, "2.01d",
	    100, NULL, EC, "8.24d",
	    101, NULL, EC, "6.70d",
	    102, NULL, EC, "1.37y",
	    103, NULL, EC, "3.3y",
	    104, "97.41", NULL, NULL,
	    105, "2.59", BETA, "3.7\x00D710\x00B9\x2070y",
	    106, NULL, BETA, "6.65d",
	    107, NULL, BETA, "23.1m",
	    108, NULL, BETA, "4.6h",
	    109, NULL, BETA, "5.7m",
	    110, NULL, BETA, "3.5m",
	    111, NULL, BETA, "2.0m",
	    112, NULL, BETA, "58s",
	    113, NULL, BETA, "20s",
	};
	int primary_isotope = 104;
    },
    new Dictionary {
	String name = "Hafnium";
	String symbol = "Hf";
	int    Z = 72;
	int    period = 6;

	Array properties = {"4", "d", METAL, SOLID, "178.49(2)", "1.3", "658.5", "155", "208", "2506", "4876", "13310", "13.44", "[Xe]4f\x00B9\x20745d\x00B26s\x00B2", TRACE, NO};

	Array isotopes = {
	    82, NULL, EC, "2s",
	    83, NULL, EC, "900ms",
	    84, NULL, ALPHA, "500us",
	    85, NULL, ALPHA, "115ms",
	    86, NULL, EC, "2.86s",
	    87, NULL, EC, "5.2s",
	    88, NULL, EC, "13s",
	    89, NULL, ALPHA, "17s",
	    90, NULL, EC, "38s",
	    91, NULL, EC, "40s",
	    92, NULL, EC, "1.9m",
	    93, NULL, EC, "1.26m",
	    94, NULL, EC, "6.8m",
	    95, NULL, EC, "2.0m",
	    96, NULL, EC, "25.9m",
	    97, NULL, EC, "3.25m",
	    98, NULL, EC, "16.0h",
	    99, NULL, EC, "12.2h",
	    100, NULL, EC, "1.87y",
	    101, NULL, EC, "23.6h",
	    102, "0.16", ALPHA, "2\x00D710\x00B9\x2075y",
	    103, NULL, EC, "70d",
	    104, "5.26", NULL, NULL,
	    105, "18.60", NULL, NULL,
	    106, "27.28", NULL, NULL,
	    107, "13.62", NULL, NULL,
	    108, "35.08", NULL, NULL,
	    109, NULL, BETA, "42.4d",
	    110, NULL, BETA, "62m",
	    111, NULL, BETA, "1.07h",
	    112, NULL, BETA, "4.1h",
	    113, NULL, BETA, "3.5m",
	    114, NULL, BETA, "2.6m",
	};
	int primary_isotope = 108;
    },
    new Dictionary {
	String name = "Tantalum";
	String symbol = "Ta";
	int    Z = 73;
	int    period = 6;

	Array properties = {"5", "d", METAL, SOLID, "180.94788(2)", "1.5", "761", "145", "200", "3290", "5731", "16650", "10.85", "[Xe]4f\x00B9\x20745d\x00B36s\x00B2", TRACE, NO};

	Array isotopes = {
	    82, NULL, PROTON, "12us",
	    83, NULL, PROTON, "300ms",
	    84, NULL, ALPHA, "1.7ms",
	    85, NULL, ALPHA, "36ms",
	    86, NULL, ALPHA, "520ms",
	    87, NULL, EC, "1.55s",
	    88, NULL, EC, "2.9s",
	    89, NULL, EC, "3.5s",
	    90, NULL, EC, "10.6s",
	    91, NULL, POSITRON, "14.2s",
	    92, NULL, EC, "31s",
	    93, NULL, POSITRON, "34s",
	    94, NULL, EC, "1.4m",
	    95, NULL, POSITRON, "2.4m",
	    96, NULL, EC, "4.9m",
	    97, NULL, POSITRON, "6.8m",
	    98, NULL, EC, "23.3m",
	    99, NULL, EC, "36.8m",
	    100, NULL, EC, "3.4h",
	    101, NULL, EC, "1.14h",
	    102, NULL, EC, "10.5h",
	    103, NULL, EC, "8.1h",
	    104, NULL, EC, "2.36d",
	    105, NULL, EC, "9.29m",
	    106, NULL, EC, "1.82y",
	    107, "0.012", EC, "1.2\x00D710\x00B9\x2075y",
	    108, "99.988", NULL, NULL,
	    109, NULL, BETA, "114.4d",
	    110, NULL, BETA, "5.1d",
	    111, NULL, BETA, "8.7h",
	    112, NULL, BETA, "49m",
	    113, NULL, BETA, "10.4m",
	};
	int primary_isotope = 108;
    },
    new Dictionary {
	String name = "Tungsten";
	String symbol = "W";
	int    Z = 74;
	int    period = 6;

	Array properties = {"6", "d", METAL, SOLID, "183.84(1)", "2.36", "770", "135", "193", "3695", "5828", "19250", "9.47", "[Xe]4f\x00B9\x20745d\x20746s\x00B2", NO, NO};

	Array isotopes = {
	    84, NULL, ALPHA, "150us",
	    85, NULL, ALPHA, "8ms",
	    86, NULL, ALPHA, "91ms",
	    87, NULL, ALPHA, "410ms",
	    88, NULL, EC, "1.39s",
	    89, NULL, EC, "2.8s",
	    90, NULL, EC, "7s",
	    91, NULL, EC, "5.1s",
	    92, NULL, EC, "19.9s",
	    93, NULL, EC, "20s",
	    94, NULL, EC, "52s",
	    95, NULL, EC, "1.3m",
	    96, NULL, EC, "2.4m",
	    97, NULL, EC, "2.4m",
	    98, NULL, EC, "6.6m",
	    99, NULL, EC, "7m",
	    100, NULL, EC, "34m",
	    101, NULL, EC, "35m",
	    102, NULL, EC, "2.5h",
	    103, NULL, EC, "2.2h",
	    104, NULL, EC, "21.6d",
	    105, NULL, EC, "37.8m",
	    106, "0.12", NULL, NULL,
	    107, NULL, EC, "121.2d",
	    108, "26.50", NULL, NULL,
	    109, "14.31", NULL, NULL,
	    110, "30.64", NULL, NULL,
	    111, NULL, BETA, "74.8d",
	    112, "28.43", NULL, NULL,
	    113, NULL, BETA, "23.9h",
	    114, NULL, BETA, "69.8d",
	    115, NULL, BETA, "11.6m",
	    116, NULL, BETA, "30m",
	};
	int primary_isotope = 110;
    },
    new Dictionary {
	String name = "Rhenium";
	String symbol = "Re";
	int    Z = 75;
	int    period = 6;

	Array properties = {"7", "d", METAL, SOLID, "186.207(1)", "1.9", "760", "135", "188", "3459", "5869", "21020", "8.86", "[Xe]4f\x00B9\x20745d\x20756s\x00B2", TRACE, NO};

	Array isotopes = {
	    85, NULL, PROTON, "800us",
	    86, NULL, ALPHA, "15ms",
	    87, NULL, ALPHA, "76ms",
	    88, NULL, ALPHA, "214ms",
	    89, NULL, ALPHA, "500ms",
	    90, NULL, EC, "2s",
	    91, NULL, EC, "2.4s",
	    92, NULL, ALPHA, "3.4s",
	    93, NULL, EC, "4s",
	    94, NULL, EC, "8.1s",
	    95, NULL, POSITRON, "9.2s",
	    96, NULL, EC, "15.2s",
	    97, NULL, POSITRON, "15s",
	    98, NULL, EC, "2.0m",
	    99, NULL, POSITRON, "2.4m",
	    100, NULL, EC, "5.9m",
	    101, NULL, EC, "5.3m",
	    102, NULL, EC, "14m",
	    103, NULL, EC, "13.2m",
	    104, NULL, EC, "19.6m",
	    105, NULL, EC, "2.45m",
	    106, NULL, EC, "20h",
	    107, NULL, EC, "12.7h",
	    108, NULL, EC, "70d",
	    109, NULL, EC, "38d",
	    110, "37.40", NULL, NULL,
	    111, NULL, BETA, "3.72d",
	    112, "62.60", BETA, "4.1\x00D710\x00B9\x2070y",
	    113, NULL, BETA, "17.0h",
	    114, NULL, BETA, "24h",
	    115, NULL, BETA, "3.0m",
	    116, NULL, BETA, "9.7m",
	    117, NULL, BETA, "16s",
	};
	int primary_isotope = 112;
    },
    new Dictionary {
	String name = "Osmium";
	String symbol = "Os";
	int    Z = 76;
	int    period = 6;

	Array properties = {"8", "d", METAL, SOLID, "190.23(3)", "2.2", "840", "130", "185", "3306", "5285", "22610", "8.42", "[Xe]4f\x00B9\x20745d\x20766s\x00B2", TRACE, NO};

	Array isotopes = {
	    86, NULL, ALPHA, "1.9ms",
	    87, NULL, ALPHA, "6ms",
	    88, NULL, ALPHA, "21ms",
	    89, NULL, ALPHA, "71ms",
	    90, NULL, ALPHA, "220ms",
	    91, NULL, ALPHA, "800ms",
	    92, NULL, EC, "2.1s",
	    93, NULL, EC, "3.3s",
	    94, NULL, EC, "7.1s",
	    95, NULL, EC, "8s",
	    96, NULL, EC, "18s",
	    97, NULL, EC, "16s",
	    98, NULL, EC, "44s",
	    99, NULL, EC, "1.4m",
	    100, NULL, EC, "3.6m",
	    101, NULL, EC, "2.8m",
	    102, NULL, EC, "5.0m",
	    103, NULL, EC, "6.5m",
	    104, NULL, EC, "21.5m",
	    105, NULL, EC, "2.7m",
	    106, NULL, EC, "21.5h",
	    107, NULL, EC, "9.9h",
	    108, "0.02", NULL, NULL,
	    109, NULL, EC, "93.6d",
	    110, "1.59", ALPHA, "2\x00D710\x00B9\x2075y",
	    111, "1.96", NULL, NULL,
	    112, "13.24", NULL, NULL,
	    113, "16.15", NULL, NULL,
	    114, "26.26", NULL, NULL,
	    115, NULL, BETA, "15.4d",
	    116, "40.78", NULL, NULL,
	    117, NULL, BETA, "30.1h",
	    118, NULL, BETA, "6.0y",
	    119, NULL, BETA, "6.5m",
	    120, NULL, BETA, "34.9m",
	};
	int primary_isotope = 116;
    },
    new Dictionary {
	String name = "Iridium";
	String symbol = "Ir";
	int    Z = 77;
	int    period = 6;

	Array properties = {"9", "d", METAL, SOLID, "192.217(3)", "2.20", "880", "135", "180", "2739", "4701", "22650", "8.52", "[Xe]4f\x00B9\x20745d\x20776s\x00B2", NO, NO};

	Array isotopes = {
	    88, NULL, ALPHA, "30ms",
	    89, NULL, ALPHA, "12ms",
	    90, NULL, ALPHA, "30ms",
	    91, NULL, ALPHA, "125ms",
	    92, NULL, ALPHA, "300ms",
	    93, NULL, ALPHA, "400ms",
	    94, NULL, ALPHA, "1.4s",
	    95, NULL, EC, "2.0s",
	    96, NULL, EC, "2.3s",
	    97, NULL, EC, "4.9s",
	    98, NULL, EC, "8s",
	    99, NULL, EC, "8s",
	    100, NULL, POSITRON, "30s",
	    101, NULL, EC, "12s",
	    102, NULL, EC, "1.32m",
	    103, NULL, EC, "1.5m",
	    104, NULL, EC, "4.9m",
	    105, NULL, EC, "15m",
	    106, NULL, EC, "57m",
	    107, NULL, EC, "3.04h",
	    108, NULL, EC, "14.4h",
	    109, NULL, EC, "1.9h",
	    110, NULL, EC, "10.5h",
	    111, NULL, EC, "1.72d",
	    112, NULL, EC, "13.2d",
	    113, NULL, EC, "3.2h",
	    114, "37.3", NULL, NULL,
	    115, NULL, BETA, "73.83d",
	    116, "62.7", NULL, NULL,
	    117, NULL, BETA, "19.3h",
	    118, NULL, BETA, "2.5h",
	    119, NULL, BETA, "52s",
	    120, NULL, BETA, "5.8m",
	    121, NULL, BETA, "8s",
	};
	int primary_isotope = 116;
    },
    new Dictionary {
	String name = "Platinum";
	String symbol = "Pt";
	int    Z = 78;
	int    period = 6;

	Array properties = {"10", "d", METAL, SOLID, "195.084(9)", "2.28", "870", "135", "177", "2041.4", "4098", "21090", "9.09", "[Xe]4f\x00B9\x20745d\x20796s\x00B9", TRACE, NO};

	Array isotopes = {
	    88, NULL, ALPHA, "300us",
	    89, NULL, ALPHA, "700us",
	    90, NULL, ALPHA, "2.0ms",
	    91, NULL, ALPHA, "4ms",
	    92, NULL, ALPHA, "14ms",
	    93, NULL, ALPHA, "44ms",
	    94, NULL, ALPHA, "98ms",
	    95, NULL, ALPHA, "370ms",
	    96, NULL, ALPHA, "890ms",
	    97, NULL, ALPHA, "2.5s",
	    98, NULL, EC, "6.5s",
	    99, NULL, EC, "11s",
	    100, NULL, EC, "21s",
	    101, NULL, EC, "21.2s",
	    102, NULL, EC, "52s",
	    103, NULL, EC, "52s",
	    104, NULL, EC, "2.7m",
	    105, NULL, EC, "43s",
	    106, NULL, EC, "17.3m",
	    107, NULL, EC, "33m",
	    108, NULL, EC, "2.08h",
	    109, NULL, POSITRON, "2.35h",
	    110, NULL, EC, "10.2d",
	    111, NULL, EC, "10.9h",
	    112, "0.014", ALPHA, "6.5\x00D710\x00B9\x00B9y",
	    113, NULL, EC, "2.88d",
	    114, "0.782", NULL, NULL,
	    115, NULL, EC, "50y",
	    116, "32.967", NULL, NULL,
	    117, "33.832", NULL, NULL,
	    118, "25.242", NULL, NULL,
	    119, NULL, BETA, "19.96h",
	    120, "7.163", NULL, NULL,
	    121, NULL, BETA, "30.8m",
	    122, NULL, BETA, "12.5h",
	    123, NULL, BETA, "2.5m",
	};
	int primary_isotope = 117;
    },
    new Dictionary {
	String name = "Gold";
	String symbol = "Au";
	int    Z = 79;
	int    period = 6;

	Array properties = {"11", "d", METAL, SOLID, "196.966569(4)", "2.54", "890.1", "135", "174", "1337.33", "3129", "19300", "10.21", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B9", NO, NO};

	Array isotopes = {
	    92, NULL, PROTON, "17us",
	    93, NULL, ALPHA, "5ms",
	    94, NULL, ALPHA, "14ms",
	    95, NULL, ALPHA, "140ms",
	    96, NULL, ALPHA, "160ms",
	    97, NULL, ALPHA, "900ms",
	    98, NULL, ALPHA, "1.22s",
	    99, NULL, EC, "2.6s",
	    100, NULL, EC, "7.1s",
	    101, NULL, EC, "8.1s",
	    102, NULL, EC, "14s",
	    103, NULL, EC, "21s",
	    104, NULL, EC, "42s",
	    105, NULL, EC, "49s",
	    106, NULL, EC, "4.3m",
	    107, NULL, EC, "10.7m",
	    108, NULL, EC, "8.3m",
	    109, NULL, EC, "8.8m",
	    110, NULL, EC, "4.6m",
	    111, NULL, EC, "43m",
	    112, NULL, EC, "3.2h",
	    113, NULL, EC, "4.9h",
	    114, NULL, EC, "17.6h",
	    115, NULL, EC, "1.58d",
	    116, NULL, EC, "186.1d",
	    117, NULL, EC, "6.17d",
	    118, "100", NULL, NULL,
	    119, NULL, BETA, "2.695d",
	    120, NULL, BETA, "3.14d",
	    121, NULL, BETA, "48.4m",
	    122, NULL, BETA, "26m",
	    123, NULL, BETA, "29s",
	    124, NULL, BETA, "56s",
	    125, NULL, BETA, "40s",
	    126, NULL, BETA, "31s",
	};
	int primary_isotope = 118;
    },
    new Dictionary {
	String name = "Mercury";
	String symbol = "Hg";
	int    Z = 80;
	int    period = 6;

	Array properties = {"12", "d", METAL, LIQUID, "200.59(2)", "2.00", "1007.1", "150", "171", "234.32", "629.88", "", "14.09", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B2", NO, NO};

	Array isotopes = {
	    92, NULL, ALPHA, "250us",
	    93, NULL, ALPHA, "930us",
	    94, NULL, ALPHA, "1.9ms",
	    95, NULL, ALPHA, "11ms",
	    96, NULL, ALPHA, "20ms",
	    97, NULL, ALPHA, "127ms",
	    98, NULL, ALPHA, "270ms",
	    99, NULL, ALPHA, "1.0s",
	    100, NULL, EC, "2.6s",
	    101, NULL, POSITRON, "3.6s",
	    102, NULL, EC, "10.8s",
	    103, NULL, EC, "9s",
	    104, NULL, EC, "30.9s",
	    105, NULL, EC, "51s",
	    106, NULL, EC, "1.38m",
	    107, NULL, EC, "1.7m",
	    108, NULL, EC, "3.2m",
	    109, NULL, EC, "7.6m",
	    110, NULL, EC, "20m",
	    111, NULL, EC, "50m",
	    112, NULL, EC, "5.0h",
	    113, NULL, EC, "3.8h",
	    114, NULL, EC, "520y",
	    115, NULL, EC, "10.5h",
	    116, "0.15", NULL, NULL,
	    117, NULL, EC, "2.67d",
	    118, "9.97", NULL, NULL,
	    119, "16.87", NULL, NULL,
	    120, "23.10", NULL, NULL,
	    121, "13.18", NULL, NULL,
	    122, "29.86", NULL, NULL,
	    123, NULL, BETA, "46.6d",
	    124, "6.87", NULL, NULL,
	    125, NULL, BETA, "5.2m",
	    126, NULL, BETA, "8.2m",
	    127, NULL, BETA, "3.0m",
	    128, NULL, BETA, "41m",
	    129, NULL, BETA, "35s",
	};
	int primary_isotope = 122;
    },
    new Dictionary {
	String name = "Thallium";
	String symbol = "Tl";
	int    Z = 81;
	int    period = 6;

	Array properties = {"13", "p", METAL, SOLID, "204.3833(2)", "1.62", "589.4", "190", "156", "577", "1746", "11850", "17.22", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B26p\x00B9", NO, NO};

	Array isotopes = {
	    96, NULL, ALPHA, "230us",
	    97, NULL, ALPHA, "254ms",
	    98, NULL, ALPHA, "1.6ms",
	    99, NULL, EC, "700ms",
	    100, NULL, ALPHA, "1.4ms",
	    101, NULL, EC, "3s",
	    102, NULL, ALPHA, "60ms",
	    103, NULL, POSITRON, "11s",
	    104, NULL, EC, "19.5s",
	    105, NULL, EC, "28s",
	    106, NULL, EC, "50s",
	    107, NULL, EC, "1.18m",
	    108, NULL, EC, "1.4m",
	    109, NULL, EC, "3.7m",
	    110, NULL, EC, "5.2m",
	    111, NULL, EC, "9.6m",
	    112, NULL, EC, "22m",
	    113, NULL, EC, "32.8m",
	    114, NULL, EC, "1.16h",
	    115, NULL, EC, "1.41h",
	    116, NULL, EC, "2.83h",
	    117, NULL, EC, "1.87h",
	    118, NULL, EC, "7.4h",
	    119, NULL, EC, "1.087d",
	    120, NULL, EC, "3.039d",
	    121, NULL, EC, "12.23d",
	    122, "29.524", NULL, NULL,
	    123, NULL, BETA, "3.78y",
	    124, "70.476", NULL, NULL,
	    125, NULL, BETA, "4.20m",
	    126, NULL, BETA, "4.77m",
	    127, NULL, BETA, "3.05m",
	    128, NULL, BETA, "2.16m",
	    129, NULL, BETA, "1.30m",
	};
	int primary_isotope = 124;
    },
    new Dictionary {
	String name = "Lead";
	String symbol = "Pb";
	int    Z = 82;
	int    period = 6;

	Array properties = {"14", "p", METAL, SOLID, "207.2(1)", "2.33", "715.6", "180", "154", "600.61", "2022", "11340", "18.26", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B26p\x00B2", NO, NO};

	Array isotopes = {
	    98, NULL, ALPHA, "4ms",
	    99, NULL, ALPHA, "50ms",
	    100, NULL, ALPHA, "55ms",
	    101, NULL, ALPHA, "420ms",
	    102, NULL, ALPHA, "490ms",
	    103, NULL, ALPHA, "4.2s",
	    104, NULL, ALPHA, "4.83s",
	    105, NULL, EC, "15.2s",
	    106, NULL, EC, "25.5s",
	    107, NULL, EC, "51s",
	    108, NULL, EC, "1.2m",
	    109, NULL, EC, "1.3m",
	    110, NULL, EC, "3.5m",
	    111, NULL, EC, "2m",
	    112, NULL, EC, "12m",
	    113, NULL, EC, "15m",
	    114, NULL, EC, "37m",
	    115, NULL, EC, "8m",
	    116, NULL, EC, "2.4h",
	    117, NULL, EC, "1.5h",
	    118, NULL, EC, "21.5h",
	    119, NULL, EC, "9.33h",
	    120, NULL, EC, "5.3\x00D710\x2074y",
	    121, NULL, EC, "2.162d",
	    122, "1.4", NULL, NULL,
	    123, NULL, EC, "1.5\x00D710\x2077y",
	    124, "24.1", NULL, NULL,
	    125, "22.1", NULL, NULL,
	    126, "52.4", NULL, NULL,
	    127, NULL, BETA, "3.25h",
	    128, NULL, BETA, "22.3y",
	    129, NULL, BETA, "36.1m",
	    130, NULL, BETA, "10.64h",
	    131, NULL, BETA, "10.2m",
	    132, NULL, BETA, "27m",
	    133, NULL, BETA, "36.5m",
	};
	int primary_isotope = 126;
    },
    new Dictionary {
	String name = "Bismuth";
	String symbol = "Bi";
	int    Z = 83;
	int    period = 6;

	Array properties = {"15", "p", METAL, SOLID, "208.98040(1)", "2.02", "703", "160", "143", "544.4", "1837", "9780", "21.31", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B26p\x00B3", NO, NO};

	Array isotopes = {
	    102, NULL, PROTON, "44us",
	    103, NULL, ALPHA, "10ms",
	    104, NULL, ALPHA, "33ms",
	    105, NULL, ALPHA, "220ms",
	    106, NULL, ALPHA, "5ms",
	    107, NULL, ALPHA, "6.3s",
	    108, NULL, ALPHA, "150ms",
	    109, NULL, EC, "37s",
	    110, NULL, ALPHA, "3.2s",
	    111, NULL, EC, "1.58m",
	    112, NULL, EC, "1.45m",
	    113, NULL, EC, "4m",
	    114, NULL, EC, "5.0m",
	    115, NULL, EC, "10.3m",
	    116, NULL, ALPHA, "24.7m",
	    117, NULL, EC, "36m",
	    118, NULL, EC, "59m",
	    119, NULL, EC, "1.72h",
	    120, NULL, EC, "11.8h",
	    121, NULL, EC, "11.2h",
	    122, NULL, EC, "15.31d",
	    123, NULL, EC, "6.243d",
	    124, NULL, EC, "32y",
	    125, NULL, EC, "3.68\x00D710\x2075y",
	    126, "100", NULL, NULL,
	    127, NULL, BETA, "5.01d",
	    128, NULL, ALPHA, "2.14m",
	    129, NULL, BETA, "7m",
	    130, NULL, BETA, "45.6m",
	    131, NULL, BETA, "19.9m",
	    132, NULL, BETA, "7.6m",
	    133, NULL, BETA, "2.18m",
	    134, NULL, BETA, "93s",
	};
	int primary_isotope = 126;
    },
    new Dictionary {
	String name = "Polonium";
	String symbol = "Po";
	int    Z = 84;
	int    period = 6;

	Array properties = {"16", "p", METAL, SOLID, "[209]", "2.0", "812.1", "190", "135", "527", "1235", "9196", "22.97", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B26p\x2074", YES, NO};

	Array isotopes = {
	    104, NULL, ALPHA, "400us",
	    105, NULL, ALPHA, "5ms",
	    106, NULL, ALPHA, "2.4ms",
	    107, NULL, ALPHA, "22ms",
	    108, NULL, ALPHA, "34ms",
	    109, NULL, ALPHA, "300ms",
	    110, NULL, ALPHA, "390ms",
	    111, NULL, ALPHA, "1.92s",
	    112, NULL, ALPHA, "5.5s",
	    113, NULL, ALPHA, "29s",
	    114, NULL, ALPHA, "1.78m",
	    115, NULL, EC, "4.20m",
	    116, NULL, EC, "11.5m",
	    117, NULL, EC, "8.9m",
	    118, NULL, EC, "44.7m",
	    119, NULL, EC, "35m",
	    120, NULL, EC, "3.53h",
	    121, NULL, EC, "1.7h",
	    122, NULL, EC, "8.8d",
	    123, NULL, EC, "5.8h",
	    124, NULL, ALPHA, "2.898y",
	    125, NULL, ALPHA, "102y",
	    126, NULL, ALPHA, "138.38d",
	    127, NULL, ALPHA, "516ms",
	    128, NULL, ALPHA, "0.3us",
	    129, NULL, ALPHA, "3.8us",
	    130, NULL, ALPHA, "163.7us",
	    131, NULL, ALPHA, "1.78ms",
	    132, NULL, ALPHA, "145ms",
	    133, NULL, ALPHA, "1.46s",
	    134, NULL, ALPHA, "3.10m",
	};
	int primary_isotope = 125;
    },
    new Dictionary {
	String name = "Astatine";
	String symbol = "At";
	int    Z = 85;
	int    period = 6;

	Array properties = {"17", "p", SEMIMETAL, SOLID, "[210]", "2.2", "920", "", "127", "575", "", "", "", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B26p\x2075", YES, NO};

	Array isotopes = {
	    109, NULL, ALPHA, "200ms",
	    110, NULL, ALPHA, "120ms",
	    111, NULL, ALPHA, "390ms",
	    112, NULL, ALPHA, "350ms",
	    113, NULL, ALPHA, "1.2s",
	    114, NULL, ALPHA, "7.3s",
	    115, NULL, ALPHA, "3.7s",
	    116, NULL, ALPHA, "1.41m",
	    117, NULL, ALPHA, "460ms",
	    118, NULL, EC, "7.4m",
	    119, NULL, EC, "9.1m",
	    120, NULL, EC, "26m",
	    121, NULL, EC, "29.4m",
	    122, NULL, EC, "1.81h",
	    123, NULL, EC, "1.63h",
	    124, NULL, EC, "5.4h",
	    125, NULL, EC, "8.1h",
	    126, NULL, EC, "7.21h",
	    127, NULL, ALPHA, "119ms",
	    128, NULL, ALPHA, "0.12us",
	    129, NULL, ALPHA, "0.6us",
	    130, NULL, ALPHA, "100us",
	    131, NULL, ALPHA, "300us",
	    132, NULL, ALPHA, "32ms",
	    133, NULL, ALPHA, "1.5s",
	    134, NULL, ALPHA, "56s",
	    135, NULL, ALPHA, "3.71m",
	    136, NULL, ALPHA, "2.3m",
	    137, NULL, ALPHA, "54s",
	    138, NULL, ALPHA, "50s",
	};
	int primary_isotope = 125;
    },
    new Dictionary {
	String name = "Radon";
	String symbol = "Rn";
	int    Z = 86;
	int    period = 6;

	Array properties = {"18", "p", NONMETAL, GAS, "[222]", "", "1037", "", "120", "202", "211.3", "", "50.50", "[Xe]4f\x00B9\x20745d\x00B9\x20706s\x00B26p\x2076", YES, NO};

	Array isotopes = {
	    109, NULL, ALPHA, "5ms",
	    110, NULL, ALPHA, "4ms",
	    111, NULL, ALPHA, "60ms",
	    112, NULL, ALPHA, "64ms",
	    113, NULL, ALPHA, "320ms",
	    114, NULL, ALPHA, "1.01s",
	    115, NULL, ALPHA, "3.8s",
	    116, NULL, ALPHA, "9.7s",
	    117, NULL, ALPHA, "26.8s",
	    118, NULL, ALPHA, "1.23m",
	    119, NULL, EC, "2.8m",
	    120, NULL, ALPHA, "5.7m",
	    121, NULL, EC, "9.3m",
	    122, NULL, ALPHA, "24.3m",
	    123, NULL, EC, "29m",
	    124, NULL, ALPHA, "2.4h",
	    125, NULL, EC, "14.6h",
	    126, NULL, ALPHA, "24m",
	    127, NULL, ALPHA, "26ms",
	    128, NULL, ALPHA, "0.27us",
	    129, NULL, ALPHA, "2.3us",
	    130, NULL, ALPHA, "45us",
	    131, NULL, ALPHA, "600us",
	    132, NULL, ALPHA, "35ms",
	    133, NULL, ALPHA, "3.96s",
	    134, NULL, ALPHA, "55.6s",
	    135, NULL, BETA, "25m",
	    136, NULL, ALPHA, "3.824d",
	    137, NULL, BETA, "23m",
	    138, NULL, BETA, "1.8h",
	    139, NULL, BETA, "4.5m",
	    140, NULL, BETA, "7.4m",
	    141, NULL, BETA, "21s",
	    142, NULL, BETA, "65s",
	};
	int primary_isotope = 136;
    },
    new Dictionary {
	String name = "Francium";
	String symbol = "Fr";
	int    Z = 87;
	int    period = 7;

	Array properties = {"1", "s", METAL, SOLID, "[223]", "0.7", "380", "", "", "", "", "", "", "[Rn]7s\x00B9", YES, NO};

	Array isotopes = {
	    112, NULL, ALPHA, "12ms",
	    113, NULL, ALPHA, "19ms",
	    114, NULL, ALPHA, "60ms",
	    115, NULL, ALPHA, "340ms",
	    116, NULL, ALPHA, "550ms",
	    117, NULL, ALPHA, "1s",
	    118, NULL, ALPHA, "3.9s",
	    119, NULL, ALPHA, "16.0s",
	    120, NULL, ALPHA, "14.8s",
	    121, NULL, ALPHA, "9.1s",
	    122, NULL, ALPHA, "50s",
	    123, NULL, ALPHA, "3.2m",
	    124, NULL, ALPHA, "3.1m",
	    125, NULL, EC, "20m",
	    126, NULL, ALPHA, "34.6s",
	    127, NULL, ALPHA, "3.4ms",
	    128, NULL, ALPHA, "0.9us",
	    129, NULL, ALPHA, "0.07us",
	    130, NULL, ALPHA, "18us",
	    131, NULL, ALPHA, "1ms",
	    132, NULL, ALPHA, "21ms",
	    133, NULL, ALPHA, "27.4s",
	    134, NULL, ALPHA, "4.8m",
	    135, NULL, BETA, "14.3m",
	    136, NULL, BETA, "21.8m",
	    137, NULL, BETA, "3.0m",
	    138, NULL, BETA, "3.9m",
	    139, NULL, BETA, "49s",
	    140, NULL, BETA, "2.48m",
	    141, NULL, BETA, "39s",
	    142, NULL, BETA, "50s",
	    143, NULL, BETA, "19s",
	    144, NULL, BETA, "17.6s",
	    145, NULL, BETA, "5s",
	};
	int primary_isotope = 136;
    },
    new Dictionary {
	String name = "Radium";
	String symbol = "Ra";
	int    Z = 88;
	int    period = 7;

	Array properties = {"2", "s", METAL, SOLID, "[226]", "0.9", "509.3", "215", "", "973", "2010", "5000", "41.09", "[Rn]7s\x00B2", YES, NO};

	Array isotopes = {
	    114, NULL, ALPHA, "700us",
	    115, NULL, ALPHA, "1.1ms",
	    116, NULL, ALPHA, "58ms",
	    117, NULL, ALPHA, "195ms",
	    118, NULL, ALPHA, "240ms",
	    119, NULL, ALPHA, "57ms",
	    120, NULL, ALPHA, "1.4s",
	    121, NULL, ALPHA, "4.6s",
	    122, NULL, ALPHA, "3.7s",
	    123, NULL, ALPHA, "13s",
	    124, NULL, ALPHA, "13s",
	    125, NULL, ALPHA, "2.7m",
	    126, NULL, ALPHA, "2.46s",
	    127, NULL, ALPHA, "1.68ms",
	    128, NULL, ALPHA, "0.18us",
	    129, NULL, ALPHA, "1.6us",
	    130, NULL, ALPHA, "26us",
	    131, NULL, ALPHA, "10ms",
	    132, NULL, ALPHA, "18ms",
	    133, NULL, ALPHA, "29s",
	    134, NULL, ALPHA, "38s",
	    135, NULL, ALPHA, "11.435d",
	    136, NULL, ALPHA, "3.66d",
	    137, NULL, BETA, "14.9d",
	    138, "100", ALPHA, "1599y",
	    139, NULL, BETA, "42m",
	    140, NULL, BETA, "5.76y",
	    141, NULL, BETA, "4m",
	    142, NULL, BETA, "1.5h",
	    143, NULL, BETA, "1.7m",
	    144, NULL, BETA, "4m",
	    145, NULL, BETA, "30s",
	    146, NULL, BETA, "30s",
	};
	int primary_isotope = 138;
    },
    new Dictionary {
	String name = "Actinium";
	String symbol = "Ac";
	int    Z = 89;
	int    period = 7;

	Array properties = {"3", "d", METAL, SOLID, "[227]", "1.1", "499", "195", "", "1323", "3573", "10070", "22.55", "[Rn]6d\x00B97s\x00B2", YES, NO};

	Array isotopes = {
	    117, NULL, ALPHA, "22ms",
	    118, NULL, ALPHA, "20ms",
	    119, NULL, ALPHA, "30ms",
	    120, NULL, ALPHA, "80ms",
	    121, NULL, ALPHA, "340ms",
	    122, NULL, ALPHA, "210ms",
	    123, NULL, ALPHA, "920ms",
	    124, NULL, ALPHA, "740ms",
	    125, NULL, ALPHA, "8.2s",
	    126, NULL, ALPHA, "170ms",
	    127, NULL, ALPHA, "440us",
	    128, NULL, ALPHA, "0.07us",
	    129, NULL, ALPHA, "1.1us",
	    130, NULL, ALPHA, "11us",
	    131, NULL, ALPHA, "26.4ms",
	    132, NULL, ALPHA, "52ms",
	    133, NULL, ALPHA, "5s",
	    134, NULL, ALPHA, "2.1m",
	    135, NULL, EC, "2.7h",
	    136, NULL, ALPHA, "10.0d",
	    137, NULL, BETA, "1.224d",
	    138, NULL, BETA, "21.77y",
	    139, NULL, BETA, "6.15h",
	    140, NULL, BETA, "1.04h",
	    141, NULL, BETA, "2.03m",
	    142, NULL, BETA, "7.5m",
	    143, NULL, BETA, "2m",
	    144, NULL, BETA, "2.4m",
	    145, NULL, BETA, "40s",
	};
	int primary_isotope = 138;
    },
    new Dictionary {
	String name = "Thorium";
	String symbol = "Th";
	int    Z = 90;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "232.03806(2)", "1.3", "587", "180", "", "2115", "5093", "11724", "19.80", "[Rn]6d\x00B27s\x00B2", YES, NO};

	Array isotopes = {
	    119, NULL, ALPHA, "3.8ms",
	    120, NULL, ALPHA, "11ms",
	    121, NULL, ALPHA, "37ms",
	    122, NULL, ALPHA, "30ms",
	    123, NULL, ALPHA, "140ms",
	    124, NULL, ALPHA, "100ms",
	    125, NULL, ALPHA, "1.2s",
	    126, NULL, ALPHA, "140us",
	    127, NULL, ALPHA, "250us",
	    128, NULL, ALPHA, "0.11us",
	    129, NULL, ALPHA, "1.05us",
	    130, NULL, ALPHA, "10us",
	    131, NULL, ALPHA, "1.7ms",
	    132, NULL, ALPHA, "2.2ms",
	    133, NULL, ALPHA, "650ms",
	    134, NULL, ALPHA, "1.05s",
	    135, NULL, ALPHA, "8.72m",
	    136, NULL, ALPHA, "30.6m",
	    137, NULL, ALPHA, "18.68d",
	    138, NULL, ALPHA, "1.912y",
	    139, NULL, ALPHA, "7300y",
	    140, NULL, ALPHA, "7.54\x00D710\x2074y",
	    141, NULL, BETA, "1.063d",
	    142, "100", ALPHA, "1.40\x00D710\x00B9\x2070y",
	    143, NULL, BETA, "21.8m",
	    144, NULL, BETA, "24.1d",
	    145, NULL, BETA, "7.2m",
	    146, NULL, BETA, "37.5m",
	    147, NULL, BETA, "4.8m",
	    148, NULL, BETA, "9.4m",
	};
	int primary_isotope = 142;
    },
    new Dictionary {
	String name = "Protactinium";
	String symbol = "Pa";
	int    Z = 91;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "231.03588(2)", "1.5", "568", "180", "", "1841", "", "15370", "15.18", "[Rn]5f\x00B26d\x00B97s\x00B2", YES, NO};

	Array isotopes = {
	    121, NULL, ALPHA, "5.1ms",
	    122, NULL, ALPHA, "5ms",
	    123, NULL, ALPHA, "17ms",
	    124, NULL, ALPHA, "14ms",
	    125, NULL, ALPHA, "190ms",
	    126, NULL, ALPHA, "1.5ms",
	    127, NULL, ALPHA, "113us",
	    128, NULL, ALPHA, "0.05us",
	    130, NULL, ALPHA, "6us",
	    131, NULL, ALPHA, "3ms",
	    132, NULL, ALPHA, "5.1ms",
	    133, NULL, ALPHA, "850ms",
	    134, NULL, ALPHA, "1.8s",
	    135, NULL, ALPHA, "1.8m",
	    136, NULL, ALPHA, "38.3m",
	    137, NULL, EC, "22h",
	    138, NULL, EC, "1.5d",
	    139, NULL, EC, "17.4d",
	    140, "100", ALPHA, "3.28\x00D710\x2074y",
	    141, NULL, BETA, "1.31d",
	    142, NULL, BETA, "26.97d",
	    143, NULL, BETA, "1.17h",
	    144, NULL, BETA, "24.4m",
	    145, NULL, BETA, "9.1m",
	    146, NULL, BETA, "8.7m",
	    147, NULL, BETA, "2.3m",
	};
	int primary_isotope = 140;
    },
    new Dictionary {
	String name = "Uranium";
	String symbol = "U";
	int    Z = 92;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "238.02891(3)", "1.38", "597.6", "175", "", "1405.3", "4200", "19050", "12.49", "[Rn]5f\x00B36d\x00B97s\x00B2", YES, NO};

	Array isotopes = {
	    125, NULL, ALPHA, "16ms",
	    126, NULL, ALPHA, "2ms",
	    127, NULL, ALPHA, "42us",
	    130, NULL, ALPHA, "1us",
	    131, NULL, ALPHA, "18us",
	    133, NULL, ALPHA, "59ms",
	    134, NULL, ALPHA, "270ms",
	    135, NULL, ALPHA, "1.1m",
	    136, NULL, ALPHA, "9.1m",
	    137, NULL, EC, "58m",
	    138, NULL, ALPHA, "20.8d",
	    139, NULL, EC, "4.2d",
	    140, NULL, ALPHA, "69.8y",
	    141, NULL, ALPHA, "1.59\x00D710\x2075y",
	    142, "0.0055", ALPHA, "2.46\x00D710\x2075y",
	    143, "0.7200", ALPHA, "7.04\x00D710\x2078y",
	    144, NULL, ALPHA, "2.34\x00D710\x2077y",
	    145, NULL, BETA, "6.75d",
	    146, "99.2745", ALPHA, "4.47\x00D710\x2079y",
	    147, NULL, BETA, "23.5m",
	    148, NULL, BETA, "14.1h",
	    150, NULL, BETA, "16.8m",
	};
	int primary_isotope = 146;
    },
    new Dictionary {
	String name = "Neptunium";
	String symbol = "Np";
	int    Z = 93;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[237]", "1.36", "604.5", "175", "", "910", "4273", "20450", "11.59", "[Rn]5f\x20746d\x00B97s\x00B2", YES, NO};

	Array isotopes = {
	    133, NULL, ALPHA, "30ms",
	    134, NULL, ALPHA, "500ms",
	    135, NULL, ALPHA, "1.0m",
	    136, NULL, ALPHA, "4.0m",
	    137, NULL, ALPHA, "4.6m",
	    138, NULL, ALPHA, "48.8m",
	    139, NULL, EC, "14.7m",
	    140, NULL, EC, "36.2m",
	    141, NULL, EC, "4.4d",
	    142, NULL, EC, "1.085y",
	    143, NULL, BETA, "22.5h",
	    144, NULL, ALPHA, "2.14\x00D710\x2076y",
	    145, NULL, BETA, "2.12d",
	    146, NULL, BETA, "2.36d",
	    147, NULL, BETA, "7.2m",
	    148, NULL, BETA, "13.9m",
	    149, NULL, BETA, "2.2m",
	};
	int primary_isotope = 144;
    },
    new Dictionary {
	String name = "Plutonium";
	String symbol = "Pu";
	int    Z = 94;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[244]", "1.28", "584.7", "175", "", "912.5", "3503", "19816", "12.29", "[Rn]5f\x20767s\x00B2", YES, NO};

	Array isotopes = {
	    137, NULL, EC, "8.6m",
	    138, NULL, EC, "34m",
	    139, NULL, EC, "20.9m",
	    140, NULL, EC, "8.8h",
	    141, NULL, EC, "25.3m",
	    142, NULL, ALPHA, "2.87y",
	    143, NULL, EC, "45.2d",
	    144, NULL, ALPHA, "87.7y",
	    145, NULL, ALPHA, "2.41\x00D710\x2074y",
	    146, NULL, ALPHA, "6560y",
	    147, NULL, BETA, "14.4y",
	    148, NULL, ALPHA, "3.75\x00D710\x2075y",
	    149, NULL, BETA, "4.96h",
	    150, NULL, ALPHA, "8.0\x00D710\x2077y",
	    151, NULL, BETA, "10.5h",
	    152, NULL, BETA, "10.9d",
	    153, NULL, BETA, "2.3d",
	};
	int primary_isotope = 150;
    },
    new Dictionary {
	String name = "Americium";
	String symbol = "Am";
	int    Z = 95;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[243]", "1.3", "578", "175", "", "1449", "2880", "", "17.63", "[Rn]5f\x20777s\x00B2", YES, NO};

	Array isotopes = {
	    137, NULL, EC, "79s",
	    138, NULL, EC, "3m",
	    139, NULL, EC, "2.3m",
	    140, NULL, EC, "15m",
	    141, NULL, EC, "4m",
	    142, NULL, EC, "1.22h",
	    143, NULL, EC, "1.63h",
	    144, NULL, EC, "11.9h",
	    145, NULL, EC, "2.12d",
	    146, NULL, ALPHA, "432.7y",
	    147, NULL, BETA, "16.0h",
	    148, NULL, ALPHA, "7370y",
	    149, NULL, BETA, "26m",
	    150, NULL, ALPHA, "2.05h",
	    151, NULL, BETA, "25m",
	    152, NULL, ALPHA, "23m",
	};
	int primary_isotope = 148;
    },
    new Dictionary {
	String name = "Curium";
	String symbol = "Cm";
	int    Z = 96;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[247]", "1.3", "581", "", "", "1613", "3383", "13510", "18.05", "[Rn]5f\x20776d\x00B97s\x00B2", YES, NO};

	Array isotopes = {
	    142, NULL, EC, "2.4h",
	    143, NULL, EC, "3h",
	    144, NULL, ALPHA, "27d",
	    145, NULL, EC, "32.8d",
	    146, NULL, ALPHA, "162.8d",
	    147, NULL, ALPHA, "29.1y",
	    148, NULL, ALPHA, "18.1y",
	    149, NULL, ALPHA, "8500y",
	    150, NULL, ALPHA, "4760y",
	    151, NULL, ALPHA, "1.56\x00D710\x2077y",
	    152, NULL, ALPHA, "3.48\x00D710\x2075y",
	    153, NULL, BETA, "1.07h",
	    154, NULL, ALPHA, "8300y",
	    155, NULL, BETA, "16.8m",
	};
	int primary_isotope = 151;
    },
    new Dictionary {
	String name = "Berkelium";
	String symbol = "Bk";
	int    Z = 97;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[247]", "1.3", "601", "", "", "1259", "", "14780", "16.84", "[Rn]5f\x20797s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Californium";
	String symbol = "Cf";
	int    Z = 98;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[251]", "1.3", "608", "", "", "1173", "", "15100", "16.50", "[Rn]5f\x00B9\x20707s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Einsteinium";
	String symbol = "Es";
	int    Z = 99;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[252]", "1.3", "619", "", "", "1133", "", "", "28.52", "[Rn]5f\x00B9\x00B97s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Fermium";
	String symbol = "Fm";
	int    Z = 100;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[257]", "1.3", "627", "", "", "1800", "", "", "", "[Rn]5f\x00B9\x00B27s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Mendelevium";
	String symbol = "Md";
	int    Z = 101;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[258]", "1.3", "635", "", "", "1100", "", "", "", "[Rn]5f\x00B9\x00B37s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Nobelium";
	String symbol = "No";
	int    Z = 102;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[259]", "1.3", "642", "", "", "1100", "", "", "", "[Rn]5f\x00B9\x20747s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Lawrencium";
	String symbol = "Lr";
	int    Z = 103;
	int    period = 7;

	Array properties = {"", "f", METAL, SOLID, "[262]", "", "", "", "", "1900", "", "", "", "[Rn]5f\x00B9\x20746d\x00B97s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Rutherfordium";
	String symbol = "Rf";
	int    Z = 104;
	int    period = 7;

	Array properties = {"4", "d", METAL, SOLID, "[261]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B27s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Dubnium";
	String symbol = "Db";
	int    Z = 105;
	int    period = 7;

	Array properties = {"5", "d", METAL, SOLID, "[262]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B37s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Seaborgium";
	String symbol = "Sg";
	int    Z = 106;
	int    period = 7;

	Array properties = {"6", "d", METAL, SOLID, "[266]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x20747s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Bohrium";
	String symbol = "Bh";
	int    Z = 107;
	int    period = 7;

	Array properties = {"7", "d", METAL, SOLID, "[264]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x20757s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Hassium";
	String symbol = "Hs";
	int    Z = 108;
	int    period = 7;

	Array properties = {"8", "d", METAL, SOLID, "[269]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x20767s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Meitnerium";
	String symbol = "Mt";
	int    Z = 109;
	int    period = 7;

	Array properties = {"9", "d", METAL, SOLID, "[268]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x20777s\x00B2", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Darmstadtium";
	String symbol = "Ds";
	int    Z = 110;
	int    period = 7;

	Array properties = {"10", "d", METAL, SOLID, "[281]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x20797s\x00B9", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Roentgenium";
	String symbol = "Rg";
	int    Z = 111;
	int    period = 7;

	Array properties = {"11", "d", METAL, SOLID, "[272]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B9", YES, NO};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununbium";
	String symbol = "Uub";
	int    Z = 112;
	int    period = 7;

	Array properties = {"12", "d", METAL, LIQUID, "[285]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B2", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununtrium";
	String symbol = "Uut";
	int    Z = 113;
	int    period = 7;

	Array properties = {"13", "p", METAL, SOLID, "[284]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B27p\x00B9", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununquadium";
	String symbol = "Uuq";
	int    Z = 114;
	int    period = 7;

	Array properties = {"14", "p", METAL, SOLID, "[289]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B27p\x00B2", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununpentium";
	String symbol = "Uup";
	int    Z = 115;
	int    period = 7;

	Array properties = {"15", "p", METAL, SOLID, "[288]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B27p\x00B3", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununhexium";
	String symbol = "Uuh";
	int    Z = 116;
	int    period = 7;

	Array properties = {"16", "p", METAL, SOLID, "[292]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B27p\x2074", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununseptium";
	String symbol = "Uus";
	int    Z = 117;
	int    period = 7;

	Array properties = {"17", "p", UNKNOWN, SOLID, "", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B27p\x2075", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
    new Dictionary {
	String name = "Ununoctium";
	String symbol = "Uuo";
	int    Z = 118;
	int    period = 7;

	Array properties = {"18", "p", NONMETAL, GAS, "[294]", "", "", "", "", "", "", "", "", "[Rn]5f\x00B9\x20746d\x00B9\x20707s\x00B27p\x2076", YES, YES};

	Array isotopes = NULL;
	int primary_isotope = -1;
    },
};

final Dictionary ChartData = {
    //
    // Constants that identify kind of tables that we support. They're used
    // to make decisions in the code and also appear in labels and menus in
    // the screen that displays the table.
    //

    final String PERIODIC_TABLE_STANDARD = "Periodic Table - Standard Version";
    final String PERIODIC_TABLE_WIDE = "Periodic Table - Wide Version";
    final String PERIODIC_PUZZLE = "Periodic Puzzle";
    final String ISOTOPE_TABLE = "Naturally Occurring Isotopes";
    final String NUCLIDE_TABLE = "Chart Of The Nuclides";

    //
    // Constants used to make coloring decisions.
    //

    final String COLORBY_CHECKERBOARD = "Checkerboard";
    final String COLORBY_COLOR_TAN = "Tan";
    final String COLORBY_COLOR_BROWN = "Brown";

    final String COLORBY_ATOMIC_RADIUS = "Atomic Radius";
    final String COLORBY_BLOCK = "Block";
    final String COLORBY_BOILING_POINT = "Boiling Point";
    final String COLORBY_CLASSIFICATION = "Classification";
    final String COLORBY_DECAY_MODE = "Decay Mode";
    final String COLORBY_ELECTRONEGATIVITY = "Electronegativity";
    final String COLORBY_HALF_LIFE = "Half Life";
    final String COLORBY_MELTING_POINT = "Melting Point";
    final String COLORBY_RADIOACTIVE = "Radioactive";
    final String COLORBY_STATE = "State";

    //
    // Constants used to make filtering decisions.
    //

    final String FILTERBY_CLASSIFICATION = "Classification";
    final String FILTERBY_STATE = "State";
    final String FILTERBY_TEMPORARYNAMES = "Temporary Names";

    //
    // Custom sorting constants.
    //

    final String SORTBY_GROUP = "Sort by Group";

    //
    // A cache for cell detail
    //

    Dictionary CellDetailCache = NULL;

    ////////////////////////////
    //
    // Application Functions
    //
    ////////////////////////////

    GetCellBackground(Dictionary cell, Dictionary dict) {
	Object colors;
	Object color;
	Object value;
	int    index;
	int    n;

	if (cell != NULL && dict != NULL) {		// probably unnecessary tests
	    colors = dict.colors;
	    if ((index = dict.index) >= 0) {
		switch (chartmodel) {
		    case ISOTOPE_TABLE:
		    case NUCLIDE_TABLE:
			switch (dict.text) {
			    case COLORBY_DECAY_MODE:
				if (value = cell.etc[DECAY_MODE])
				    color = defined(value, colors) ? colors[value] : colors[UNKNOWN];
				else color = colors[STABLE];
				break;

			    case COLORBY_RADIOACTIVE:
				color = cell.etc[DECAY_MODE] ? colors[YES] : colors[NO];
				break;

			    case COLORBY_HALF_LIFE:
				if (value = cell.etc[HALF_LIFE]) {
				    value += value@sizeof - 1;		// point to last character
				    color = defined(value, colors) ? colors[value] : colors[UNKNOWN];
				} else color = colors[STABLE];
				break;
			}
			break;

		    case PERIODIC_PUZZLE:
		    case PERIODIC_TABLE_STANDARD:
		    case PERIODIC_TABLE_WIDE:
			if (colors instanceof Array) {
			    if ((value = atof(cell.data.properties[index])) > 0) {
				for (n = 2; n < colors@sizeof - 2 && colors[n] < value; n += 2) ;
				color = colors[n+1];
			    } else color = colors[1];
			} else color = colors[cell.data.properties[index]];
			break;
		}
	    } else {
		switch (dict.text) {
		    case COLORBY_CHECKERBOARD:
			color = colors[((cell.index/columns)%2 + cell.index%columns)%colors@sizeof];
			break;

		    case COLORBY_COLOR_TAN:
		    case COLORBY_COLOR_BROWN:
			color = colors;
			break;
		}
	    }
	}
	return(color);
    }

    GetCellDetail(Dictionary cell) {
	Dictionary element;
	Array      properties;
	String     result;

	String template = @<<<HTML>
	    <HEAD>
	    <TITLE>%s</TITLE>
	    </HEAD>
	    <BODY>
	    <table cellspacing=0 cellpadding=3 border=0 align=center>
	    <tr>
	    <td colspan=2 align=center><span style='font-size:150%%'><b>%s</b></span></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center><span style='font-size:200%%'><b>%s</b></span></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center><span style='font-size:160%%'><b>%s</b></span></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center><b>%s</b></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center>%s</td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center>Group <b>%s</b> Period <b>%s</b> Block <b>%s</b></td>
	    </tr>
	    <tr>
	    <td colspan=2><hr></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center><b>Radii</b></td>
	    </tr>
	    <tr>
	    <td align='right'><b>Empirical</b> (picometers):</td><td>%s</td>
	    </tr>
	    <tr>
	    <td align='right'><b>Calculated</b> (picometers):</td><td>%s</td>
	    </tr>
	    <tr>
	    <td colspan=2><hr></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center><b>Ionization Energies</b> (kJ/mole)</td>
	    </tr>
	    %s
	    <tr>
	    <td colspan=2><hr></td>
	    </tr>
	    <tr>
	    <td colspan=2 align=center><b>Electronegativities</b></td>
	    </tr>
	    <tr>
	    <td align='right'><b>Pauling</b>:</td><td>%s</td>
	    </tr>
	    <tr>
	    <td colspan=2><hr></td>
	    </tr>
	    <tr>
	    <td align='right'><b>State</b> (at STP):</td><td>%s</td>
	    </tr>
	    <tr>
	    <td align='right'><b>Melting Point</b> (&deg;K):</td><td>%s</td>
	    </tr>
	    <tr>
	    <td align='right'><b>Boiling Point</b> (&deg;K):</td><td>%s</td>
	    </tr>
	    <tr>
	    <td align='right'><b>Density</b> (kg/cm<sup>3</sup>):</td><td valign="bottom">%s</td>
	    </tr>
	    <tr>
	    <td align='right'><b>Classification</b>:</td><td>%s</td>
	    </tr>
	    <tr>
	    <td align='right'><b>Radioactive</b>:</td><td>%s</td>
	    </tr>
	    </table>
	    </BODY>
	</HTML>%s>>@;

	IonizationPotentials(String list) {
	    Array ordinals = {"First", "Second", "Third", "Fourth", "Fifth", "Sixth", "Seventh", "Eighth"};
	    Array values = strsplit(list, ",");

	    for (ptr in values) {
		if (ptr@offset < ordinals@length)
		    *ptr = strfmt("  <tr>\n    <td align='right'><b>%s Electron</b>:</td><td>%s</td>\n  </tr>", ordinals[ptr@offset], *ptr);
	    }
	    return(strjoin(values, "\n"));
	}

	if (cell != NULL) {
	    if (!defined(cell.name, CellDetailCache)) {
		if (CellDetailCache == NULL)
		    CellDetailCache = new Dictionary[cellcount, ...];
		element = cell.data;
		properties = element.properties;
		CellDetailCache[cell.name] = strfmt(template,
		    element.name,
		    element.name,
		    element.symbol,
		    toString(element.Z),
		    properties[ATOMIC_WEIGHT],
		    properties[ELECTRON_CONFIGURATION],
		    properties[GROUP] === "" ? "n/a" : properties[GROUP],
		    toString(element.period),
		    properties[BLOCK],

		    properties[ATOMIC_RADIUS],
		    properties[ATOMIC_RADIUS_CALCULATED],

		    IonizationPotentials(properties[IONIZATION_ENERGY]),

		    properties[ELECTRONEGATIVITY],
		    properties[STATE],
		    properties[MELTING_POINT],
		    properties[BOILING_POINT],
		    properties[DENSITY],
		    properties[CLASSIFICATION],
		    properties[RADIOACTIVE],
		    "\n"
		);
	    }
	    result = CellDetailCache[cell.name];
	}
	return(result);
    }

    GetCellDetailDividerModel() {
	int model;

	switch (chartmodel) {
	    case PERIODIC_TABLE_STANDARD:
		model = 1;
		break;

	    default:
		model = 2;
		break;
	}
	return(model);
    }

    GetCellLabelGenerators() {
	Array generators;

	switch (chartmodel) {
	    case PERIODIC_TABLE_STANDARD:
	    case PERIODIC_TABLE_WIDE:
		generators = new Array {
		    new Dictionary {
			Font font = GetSmallCellFont();
			int  baseline = TOP;

			GetBackground(Dictionary cell) {
			    Object color;
			    switch (cell.data.properties[CLASSIFICATION]) {
				case METAL:
				    color = CellColors.LIGHTGRAY;
				    break;

				case NONMETAL:
				    color = CellColors.DARKGRAY;
				    break;

				case SEMIMETAL:
				    color = CellColors.GRAY;
				    break;

				default:
				    color = NULL;
				    break;
			    }
			    return(color);
			}

			Array layout = {
			    new Dictionary {
				int alignment = CENTER;

				GetText(Dictionary cell) = cell.name;
				GetMinimumSize() = GetFieldBounds(ElementData, "name");
			    },
			};
		    },
		    new Dictionary {
			Font font = GetSmallCellFont();
			int  baseline = BOTTOM;

			GetBackground(Dictionary cell) = CellColors.GOLD;

			Array layout = {
			    new Dictionary {
				int alignment = LEFT;

				GetText(Dictionary cell) = toString(cell.data.Z);
				GetTipText(Dictionary cell) = "Atomic Number = " + toString(cell.data.Z);
				GetMinimumSize() = GetFieldBounds(ElementData, "Z");
			    },
			    new Dictionary {
				int alignment = CENTER;

				GetMinimumSize() = GetLineBounds(72.0/8);
			    },
			    new Dictionary {
				int alignment = RIGHT;

				GetText(Dictionary cell) {
				    String text = cell.data.properties[ATOMIC_WEIGHT];
				    int    index;

				    if ((index = indexOf(text, "(")) > 0)
					text = substring(text, 0, index);
				    return(text);
				}

				GetTipText(Dictionary cell) = "Atomic Weight = " + toString(cell.data.properties[ATOMIC_WEIGHT]);
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", ATOMIC_WEIGHT);
			    },
			};
		    },
		    new Dictionary {
			//
			// Displaying values in Centigrade would save a little
			// space, but it's not a big deal if we're displaying
			// the temps at the right an left sides of the "line".
			//
			Font font = GetTinyCellFont();
			int  baseline = BOTTOM;

			Array layout = {
			    new Dictionary {
				int alignment = LEFT;

				GetText(Dictionary cell) = cell.data.properties[MELTING_POINT]@sizeof ? cell.data.properties[MELTING_POINT] + DEGREESKELVIN : "";
				GetTipText(Dictionary cell) = cell.data.properties[MELTING_POINT]@sizeof ? "Melting Point = " + cell.data.properties[MELTING_POINT] + DEGREESKELVIN : "";
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", MELTING_POINT);
			    },
			    new Dictionary {
				int alignment = RIGHT;

				GetText(Dictionary cell) = cell.data.properties[BOILING_POINT]@sizeof ? cell.data.properties[BOILING_POINT] + DEGREESKELVIN : "";
				GetTipText(Dictionary cell) = cell.data.properties[BOILING_POINT]@sizeof ? "Boiling Point = " + cell.data.properties[BOILING_POINT] + DEGREESKELVIN : "";
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", BOILING_POINT);
			    },
			};
		    },
		    new Dictionary {
			Font font = GetTinyCellFont();
			int  baseline = BOTTOM;

			Array layout = {
			    new Dictionary {
				int alignment = LEFT;

				GetText(Dictionary cell) = cell.data.properties[ELECTRONEGATIVITY];
				GetTipText(Dictionary cell) = "Electronegativity (Pauling) = " + cell.data.properties[ELECTRONEGATIVITY];
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", ELECTRONEGATIVITY);
			    },
			    new Dictionary {
				int alignment = RIGHT;

				GetText(Dictionary cell) = cell.data.properties[ATOMIC_RADIUS_CALCULATED]@sizeof ? cell.data.properties[ATOMIC_RADIUS_CALCULATED] + PICOMETER : "";
				GetTipText(Dictionary cell) = cell.data.properties[ATOMIC_RADIUS_CALCULATED]@sizeof ? "Atomic Radius (calculated) = " + cell.data.properties[ATOMIC_RADIUS_CALCULATED] + PICOMETER : "";
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", ATOMIC_RADIUS_CALCULATED);
			    },
			};
		    },
		    new Dictionary {
			double leading = 1.0;
			Font   font = GetTinyCellFont();
			int    baseline = BOTTOM;

			Array layout = {
			    new Dictionary {
				int alignment = CENTER;

				GetText(Dictionary cell) = cell.data.properties[ELECTRON_CONFIGURATION];
				GetTipText(Dictionary cell) = "Electron Configuration = " + cell.data.properties[ELECTRON_CONFIGURATION];
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", ELECTRON_CONFIGURATION);
			    },
			};
		    },
		    new Dictionary {
			Font font = GetLargeCellFont();
			int  baseline = CENTER;

			Array layout = {
			    new Dictionary {
				int  alignment = CENTER;

				GetText(Dictionary cell) = cell.data.symbol;
				GetMinimumSize() = GetFieldBounds(ElementData, "symbol");
			    },
			};
		    },
		};
		break;

	    case ISOTOPE_TABLE:
	    case NUCLIDE_TABLE:
		generators = new Array {
		    new Dictionary {
			Font font = GetSmallCellFont();
			int  baseline = TOP;

			Array layout = {
			    new Dictionary {
				int alignment = LEFT;

				GetText(Dictionary cell) = toString(cell.data.Z + cell.etc[NEUTRON_NUMBER]);
				GetTipText(Dictionary cell) = "Mass Number = " + toString(cell.data.Z + cell.etc[NEUTRON_NUMBER]);
				GetMinimumSize() = GetLineBounds("000");
			    },

			    new Dictionary {
				int alignment = RIGHT;
				int selectable = TRUE;

				GetText(Dictionary cell) = CHECKMARK;
				GetMinimumSize() = GetLineBounds(CHECKMARK);
			    },
			};
		    },
		    new Dictionary {
			Font font = GetSmallCellFont();
			int  baseline = BOTTOM;

			GetBackground(Dictionary cell) = CellColors.GOLD;

			Array layout = {
			    new Dictionary {
				int alignment = LEFT;

				GetText(Dictionary cell) = toString(cell.data.Z);
				GetTipText(Dictionary cell) = "Atomic Number = " + toString(cell.data.Z);
				GetMinimumSize() = GetFieldBounds(ElementData, "Z");
			    },
			    new Dictionary {
				int alignment = CENTER;

				GetMinimumSize() = GetLineBounds(72.0/8);
			    },
			    new Dictionary {
				int alignment = RIGHT;

				//
				// Using ATOMIC_WEIGHT for our minimum size even though
				// it's much bigger than we really need because it makes
				// our cells more compatible with the standard periodic
				// table cells.
				//

				GetText(Dictionary cell) = toString(cell.etc[NEUTRON_NUMBER]);
				GetTipText(Dictionary cell) = "Neutron Number = " + toString(cell.etc[NEUTRON_NUMBER]);
				GetMinimumSize() = GetArrayElementBounds(ElementData, "properties", ATOMIC_WEIGHT);	// bigger than we need
			    },
			};
		    },
		    new Dictionary {
			Font font = GetSmallCellFont();
			int  baseline = BOTTOM;

			Array layout = {
			    new Dictionary {
				int alignment = LEFT;

				GetText(Dictionary cell) = cell.etc[DECAY_MODE];
				GetTipText(Dictionary cell) = "Decay Mode = " + DecayModeTips[cell.etc[DECAY_MODE]];
				GetMinimumSize() = GetArrayOverlayBounds(ElementData, "isotopes", DECAY_MODE, FIELDS_PER_ISOTOPE);
			    },
			    new Dictionary {
				int alignment = CENTER;

				GetMinimumSize() = GetLineBounds(72.0/8);
			    },
			    new Dictionary {
				int alignment = RIGHT;

				GetText(Dictionary cell) = cell.etc[HALF_LIFE];
				GetTipText(Dictionary cell) = cell.etc[HALF_LIFE] ? "Half Life = " + cell.etc[HALF_LIFE] : NULL;
				GetMinimumSize() = GetArrayOverlayBounds(ElementData, "isotopes", HALF_LIFE, FIELDS_PER_ISOTOPE);
			    },
			};
		    },
		    new Dictionary {
			double leading = 1.0;
			Font   font = GetSmallCellFont();
			int    baseline = BOTTOM;

			Array layout = {
			    new Dictionary {
				int alignment = CENTER;

				GetText(Dictionary cell) = cell.etc[ABUNDANCE] ? cell.etc[ABUNDANCE] + "%" : NULL;
				GetTipText(Dictionary cell) = cell.etc[ABUNDANCE] ? "Abundance = " + cell.etc[ABUNDANCE] + "%" : NULL;
				GetMinimumSize() = GetLineBounds(GetArrayOverlayBounds(ElementData, "isotopes", ABUNDANCE, FIELDS_PER_ISOTOPE), "%");
			    },
			};
		    },
		    new Dictionary {
			Font font = GetLargeCellFont();
			int  baseline = CENTER;

			Array layout = {
			    new Dictionary {
				int  alignment = CENTER;

				GetText(Dictionary cell) = cell.data.symbol;
				GetMinimumSize() = GetFieldBounds(ElementData, "symbol");
			    },
			};
		    },
		};
		break;

	    case PERIODIC_PUZZLE:
		generators = new Array {
		    new Dictionary {
			Font font = GetSmallCellFont();
			int  baseline = TOP;

			GetBackground(Dictionary cell) = CellColors.LIGHTGRAY;

			Array layout = {
			    new Dictionary {
				int alignment = CENTER;

				GetText(Dictionary cell) = cell.name;
				GetMinimumSize() = GetFieldBounds(ElementData, "name");
			    },
			};
		    },
		    new Dictionary {
			Font font = GetLargeCellFont();
			int  baseline = CENTER;

			Array layout = {
			    new Dictionary {
				int  alignment = CENTER;

				GetText(Dictionary cell) = cell.data.symbol;
				GetMinimumSize() = GetFieldBounds(ElementData, "symbol");
			    },
			};
		    },
		};
		break;
	}
	return(generators);
    }

    GetColorMenuData() {
	Array data;

	switch (chartmodel) {
	    case ISOTOPE_TABLE:
	    case NUCLIDE_TABLE:
		data = new Array[0, ...] {
		    new Dictionary {
			String text = COLORBY_RADIOACTIVE;
			Object colors = PickColorsFor(COLORBY_RADIOACTIVE);
			int    index = DECAY_MODE;
		    },
		    new Dictionary {
			String text = COLORBY_DECAY_MODE;
			Object colors = PickColorsFor(COLORBY_DECAY_MODE);
			int    state = !puzzle;
			int    index = DECAY_MODE;
		    },
		    new Dictionary {
			String text = COLORBY_HALF_LIFE;
			Object colors = PickColorsFor(COLORBY_HALF_LIFE);
			int    index = HALF_LIFE;
		    },
		};
		break;

	    case PERIODIC_PUZZLE:
	    case PERIODIC_TABLE_STANDARD:
	    case PERIODIC_TABLE_WIDE:
		data = new Array[0, ...] {
		    new Dictionary {
			String text = COLORBY_ATOMIC_RADIUS;
			Object colors = PickColorsFor(COLORBY_ATOMIC_RADIUS);
			int    index = ATOMIC_RADIUS_CALCULATED;
			String suffix = PICOMETER;
		    },
		    new Dictionary {
			String text = COLORBY_BLOCK;
			Object colors = PickColorsFor(COLORBY_BLOCK);
			int    state = !puzzle;
			int    index = BLOCK;
		    },
		    new Dictionary {
			String text = COLORBY_ELECTRONEGATIVITY;
			Object colors = PickColorsFor(COLORBY_ELECTRONEGATIVITY);
			int    index = ELECTRONEGATIVITY;
		    },
		    new Dictionary {
			String text = COLORBY_RADIOACTIVE;
			Object colors = PickColorsFor(COLORBY_RADIOACTIVE);
			int    index = RADIOACTIVE;
		    },
		    NULL,
		    new Dictionary {
			String text = COLORBY_STATE;
			Object colors = PickColorsFor(COLORBY_STATE);
			int    index = STATE;
		    },
		    new Dictionary {
			String text = COLORBY_MELTING_POINT;
			Object colors = PickColorsFor(COLORBY_MELTING_POINT);
			int    index = MELTING_POINT;
			String suffix = DEGREESKELVIN;
		    },
		    new Dictionary {
			String text = COLORBY_BOILING_POINT;
			Object colors = PickColorsFor(COLORBY_BOILING_POINT);
			int    index = BOILING_POINT;
			String suffix = DEGREESKELVIN;
		    },
		    new Dictionary {
			String text = COLORBY_CLASSIFICATION;
			Object colors = PickColorsFor(COLORBY_CLASSIFICATION);
			int    index = CLASSIFICATION;
		    },
		};
		break;
	}

	if (data@sizeof > 0)
	    data[data@sizeof] = NULL;	// means add separator to menu
	else data = new Array[0, ...];

	data[data@sizeof] = new Dictionary {
	    String text = COLORBY_COLOR_TAN;
	    Object colors = PickColorsFor(COLORBY_COLOR_TAN);
	    int    state = puzzle;
	    int    index = -1;
	};
	data[data@sizeof] = new Dictionary {
	    String text = COLORBY_COLOR_BROWN;
	    Object colors = PickColorsFor(COLORBY_COLOR_BROWN);
	    int    index = -1;
	};
	data[data@sizeof] = new Dictionary {
	    String text = COLORBY_CHECKERBOARD;
	    Object colors = PickColorsFor(COLORBY_CHECKERBOARD);
	    int    index = -1;
	};
	return(data);
    }

    GetColorTipText(Dictionary cell, Dictionary dict) {
	String text;
	Object colors;
	Object value;
	String suffix;
	int    index;
	int    limit;
	int    n;

	if (dict != NULL) {
	    text = dict.text;
	    index = dict.index;
	    if (cell != NULL && index >= 0) {
		colors = dict.colors;
		suffix = defined("suffix", dict) ? dict.suffix : "";
		switch (chartmodel) {
		    case ISOTOPE_TABLE:
		    case NUCLIDE_TABLE:
			value = cell.etc[index];
			switch (dict.text) {
			    case COLORBY_DECAY_MODE:
				text += value ? " = " + DecayModeTips[value] : " = " + STABLE;
				break;

			    case COLORBY_HALF_LIFE:
				text += value ? " = " + value : " = " + STABLE;
				break;

			    case COLORBY_RADIOACTIVE:
				text += value ? " = TRUE" : " = FALSE";
				break;
			}
			break;

		    case PERIODIC_PUZZLE:
		    case PERIODIC_TABLE_STANDARD:
		    case PERIODIC_TABLE_WIDE:
			if (colors instanceof Array) {
			    if ((value = atof(cell.data.properties[index])) > 0) {
				colors = dict.colors;
				limit = colors@sizeof - 2;
				for (n = 2; n < limit && colors[n] < value; n += 2) ;
				text += strfmt(" = %s%s, Color Range = [%d, %d)", cell.data.properties[index], suffix, colors[n - 2], colors[n]);
			    } else text += " = UNKNOWN";
			} else if (cell.data.properties[index]@sizeof > 0)
			    text += " = " + cell.data.properties[index] + suffix;
			break;
		}
	    }
	}
	return(text + " ");
    }

    GetExternalSiteData() {
	Array items;

	switch (chartmodel) {
	    case ISOTOPE_TABLE:
	    case NUCLIDE_TABLE:
	    case PERIODIC_PUZZLE:
	    case PERIODIC_TABLE_STANDARD:
	    case PERIODIC_TABLE_WIDE:
		items = new Array {
		    "Wikipedia", "wikipedia",
		    "WebElements", "webelements",
		};
		break;
	}
	return(items);
    }

    GetExternalSiteURL(Dictionary cell, String site) {
	String url;

	if (cell != NULL) {
	    switch (site) {
		case "webelements":
		    url = "http://www.webelements.com/webelements/elements/text/" + cell.data.symbol + "/index.html";
		    break;

		case "wikipedia":
		    url = "http://en.wikipedia.org/wiki/" + cell.name;
		    break;
	    }
	}
	return(url);
    }

    GetFilterMenuData() {
	Array data = NULL;

	switch (chartmodel) {
	    case PERIODIC_PUZZLE:
	    case PERIODIC_TABLE_STANDARD:
	    case PERIODIC_TABLE_WIDE:
		data = new Array {
		    FILTERBY_CLASSIFICATION, new Array {
			new Dictionary {
			    String text = ALL_ON;
			    String key = FILTERBY_CLASSIFICATION;
			},
			new Dictionary {
			    String text = ALL_OFF;
			    String key = FILTERBY_CLASSIFICATION;
			},
			NULL,
	 		new Dictionary {
			    String text = METAL;
			    String key = FILTERBY_CLASSIFICATION;
			    String value = METAL;
			},
			new Dictionary {
			    String text = SEMIMETAL;
			    String key = FILTERBY_CLASSIFICATION;
			    String value = SEMIMETAL;
			},
			new Dictionary {
			    String text = NONMETAL;
			    String key = FILTERBY_CLASSIFICATION;
			    String value = NONMETAL;
			},
			new Dictionary {
			    String text = UNKNOWN;
			    String key = FILTERBY_CLASSIFICATION;
			    String value = UNKNOWN;
			},
		    },
		    FILTERBY_STATE, new Array {
			new Dictionary {
			    String text = ALL_ON;
			    String key = FILTERBY_STATE;
			},
			new Dictionary {
			    String text = ALL_OFF;
			    String key = FILTERBY_STATE;
			},
			NULL,
	 		new Dictionary {
			    String text = SOLID;
			    String key = FILTERBY_STATE;
			    String value = SOLID;
			},
			new Dictionary {
			    String text = LIQUID;
			    String key = FILTERBY_STATE;
			    String value = LIQUID;
			},
			new Dictionary {
			    String text = GAS;
			    String key = FILTERBY_STATE;
			    String value = GAS;
			},
		    },
		    NULL,
		    new Dictionary {
			String text = FILTERBY_TEMPORARYNAMES;
			String key = FILTERBY_TEMPORARYNAMES;
			String value = YES;
		    },
		};
		break;
	}
	return(data);
    }

    GetFilterValue(Dictionary cell, String key) {
	int index = -1;

	switch (key) {
	    case FILTERBY_CLASSIFICATION:
		index = CLASSIFICATION;
		break;

	    case FILTERBY_STATE:
		index = STATE;
		break;

	    case FILTERBY_TEMPORARYNAMES:
		index = TEMPORARYNAME;
		break;
	}
	return(index >= 0 ? cell.data.properties[index] : NULL);
    }

    GetSelectionForCell(Dictionary cell, Array namevalues, int nameindex, Array neutronvalues, int neutronindex, ...) {
	Array selection[0, ...] = {0, 0};

	if (namevalues@sizeof > 0) {
	    if (cell != NULL) {
		selection[0] = indexOfObject(namevalues, cell.name);
		if (neutronvalues != NULL)
		    selection[1] = indexOfObject(neutronvalues, toString(cell.etc[0]));
	    }
	}
	return(selection);
    }

    GetSelectionForRotation(Array namevalues, int nameindex, int namedirection, Array neutronvalues, int neutronindex, int neutrondirection, ...) {
	Dictionary cell;
	Array      selection[0, ...] = {0, 0};
	int        length;
	int        checked;
	int        incr;
	int        n;

	if (namevalues@sizeof > 0) {
	    if (namedirection != 0) {
		incr = (namedirection > 0) ? 1 : -1;
		length = namevalues@sizeof;
		for (n = nameindex + incr, checked = 0; checked < length; n += incr, checked++) {
		    if (n >= length)
			n = 0;
		    else if (n < 0)
			n = length - 1;
		    if (neutronvalues@sizeof > 0) {
			if ((cell = GetSelectableCellNamed(namevalues[n])) != NULL) {
			    selection[0] = n;
			    selection[1] = indexOfObject(neutronvalues, toString(cell.etc[0]));
			    break;
			}
		    } else {
			if ((cell = GetSelectionAsVisibleCell(namevalues, n)) != NULL) {
			    selection[0] = n;
			    break;
			}
		    }
		}
	    } else if (neutrondirection != 0) {
		selection[0] = nameindex;
		if (neutronvalues@sizeof > 0) {
		    if ((cell = GetNextSelectableCellNamed(namevalues[nameindex], neutrondirection)) != NULL)
			selection[1] = indexOfObject(neutronvalues, toString(cell.etc[0]));
		    else selection[0] = 0;
		}
	    }
	}
	return(selection);
    }

    GetSelectionForStateChanged(Array namevalues, int nameindex, int namechanged, Array neutronvalues, int neutronindex, int neutronchanged, ...) {
	Dictionary cell;
	Object     cells;
	Array      selection[0, ...] = {0, 0};
	int        neutrons;

	if (namevalues@sizeof > 0) {
	    if (namechanged) {
		selection[0] = nameindex;
		if (neutronvalues@sizeof > 0) {
		    if ((cell = GetSelectableCellNamed(namevalues[nameindex])) != NULL)
			selection[1] = indexOfObject(neutronvalues, toString(cell.etc[0]));
		    else selection[0] = 0;
		}
	    } else if (neutronchanged) {
		if (defined(namevalues[nameindex], namemap)) {
		    if ((neutrons = atoi(neutronvalues[neutronindex], 10, -1)) >= 0) {
			if ((cells = namemap[namevalues[nameindex]]) != NULL) {
			    if (cells instanceof Array) {
				for (ptr in cells) {
				    if (ptr[0].etc[0] == neutrons) {
					cell = ptr[0];
					break;
				    }
				}
			    } else if (cells.etc[0] == neutrons)
				cell = cells;
			    if (cell) {
				MakeCellSelectable(cell);
				selection[0] = nameindex;
				selection[1] = indexOfObject(neutronvalues, toString(cell.etc[0]));
			    }
			}
		    }
		}
	    }
	    if ((cell = GetSelectionAsVisibleCell(namevalues, selection[0], neutronvalues, selection[1])) == NULL)
		selection = new Array {0, 0};
	}
	return(selection);
    }

    GetSelectorData(int selector, String sortby) {
	Array data;
	int   n;

	switch (selector) {
	    case 0:
		data = new Array[] allnames;
		break;

	    case 1:
		switch (chartmodel) {
		    case ISOTOPE_TABLE:
		    case NUCLIDE_TABLE:
			data = new Array[columns];
			for (n = 0; n < columns; n++)
			    data[n] = toString(n);
			break;

		    default:
			data = NULL;
		}
		break;

	    default:
		data = NULL;
		break;
	}

	if (data != NULL) {
	    switch (sortby ? sortby : GetDefaultSortby(selector)) {
		case SORTBY_INPUT_ORDER:
		    SortByInputOrder(selector, data);
		    break;

		case SORTBY_NAME:
		    SortByName(selector, data);
		    break;

		case SORTBY_ROWS:
		    SortByRows(selector, data);
		    break;

		case SORTBY_GROUP:
		    SortByGroup(selector, data);
		    break;
	    }
	}
	return(data);
    }

    GetSelectorMenuData(int selector) {
	Array data;

	switch (selector) {
	    case 0:
		data = new Array[0, ...] {
		    new Dictionary {
			String text = "Sort by Name";
			String command = SORTBY_NAME;
		    }
		};

		switch (chartmodel) {
		    case ISOTOPE_TABLE:
		    case NUCLIDE_TABLE:
			data[data@sizeof] = new Dictionary {
			    String text = "Sort by Atomic Number";
			    String command = SORTBY_INPUT_ORDER;
			    int    state = TRUE;
			};
			break;

		    case PERIODIC_TABLE_STANDARD:
		    case PERIODIC_TABLE_WIDE:
			data[data@sizeof] = new Dictionary {
			    String text = "Sort by Atomic Number";
			    String command = SORTBY_INPUT_ORDER;
			    int    state = TRUE;
			};
			data[data@sizeof] = new Dictionary {
			    String text = "Sort by Group";
			    String command = SORTBY_GROUP;
			    int    state = FALSE;
			};
			break;
		}
		break;

	    default:
		data = NULL;
		break;
	}
	return(data);
    }

    GetChartLabelGenerators() {
	Array generators;

	switch (chartmodel) {
	    case PERIODIC_TABLE_STANDARD:
		generators = new Array {
		    new Dictionary {
			String group = COLUMN_LABELS;
			double xoffset = 0.0;
			double yoffset = -0.2;
			Array  columnends = columnends;
			int    baseline = BOTTOM;
			int    alignment = CENTER;

			GetText(Array location) = toString(location[1]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[1] < 17) {
				    location[1]++;
				    location[0] = columnends[location[1]][0] - 1;
				} else location = NULL;
			    } else location = new Array {-1, 0};
			    return(location);
			}
		    },

		    new Dictionary {
			String group = ROW_LABELS;
			double xoffset = -0.2;
			double yoffset = 0.0;
			int    baseline = CENTER;
			int    alignment = RIGHT;

			GetText(Array location) = toString(location[0]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[0] < 6)
				    location[0]++;
				else location = NULL;
			    } else location = new Array {0, -1};
			    return(location);
			}
		    },

		    new Dictionary {
			String group = ROW_LABELS;
			double xoffset = -0.2;
			double yoffset = 0.0;
			int    baseline = CENTER;
			int    alignment = RIGHT;

			GetText(Array location) = (location[0] == 8) ? "Lanthanides" : "Actinides";

			NextCellLocation(Array location) {
			    if (location) {
				if (location[0] < 9)
				    location[0]++;
				else location = NULL;
			    } else location = new Array {8, 1};
			    return(location);
			}
		    },
		};
		break;

	    case PERIODIC_TABLE_WIDE:
		generators = new Array {
		    new Dictionary {
			String group = COLUMN_LABELS;
			double xoffset = 0.0;
			double yoffset = -0.2;
			Array  columnends = columnends;
			int    baseline = BOTTOM;
			int    alignment = CENTER;

			GetText(Array location) = (location[1] < 3) ? toString(location[1]+1) : (location[1] > 16 ? toString(location[1] - 13) : NULL);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[1] < 31) {
				    if (location[1] == 2)
					location[1] = 16;
				    else location[1]++;
				    location[0] = columnends[location[1]][0] - 1;
				} else location = NULL;
			    } else location = new Array {-1, 0};
			    return(location);
			}
		    },

		    new Dictionary {
			String group = ROW_LABELS;
			double xoffset = -0.2;
			double yoffset = 0.0;
			int    baseline = CENTER;
			int    alignment = RIGHT;

			GetText(Array location) = toString(location[0]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[0] < 6)
				    location[0]++;
				else location = NULL;
			    } else location = new Array {0, -1};
			    return(location);
			}
		    },
		};
		break;

	    case PERIODIC_PUZZLE:
		generators = new Array {
		    new Dictionary {
			String group = COLUMN_LABELS;
			double xoffset = 0.0;
			double yoffset = -0.2;
			int    baseline = BOTTOM;
			int    alignment = CENTER;

			GetText(Array location) = toString(location[1]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[1] < 17)
				    location[1]++;
				else location = NULL;
			    } else location = new Array {-1, 0};
			    return(location);
			}
		    },

		    new Dictionary {
			String group = COLUMN_LABELS;
			double xoffset = 0.0;
			double yoffset = -0.2;
			int    baseline = CENTER;
			int    alignment = CENTER;

			GetText(Array location) = toString(location[1]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[1] < 17)
				    location[1]++;
				else location = NULL;
			    } else location = new Array {10, 0};
			    return(location);
			}
		    },

		    new Dictionary {
			String group = ROW_LABELS;
			double xoffset = -0.2;
			Font   font = GetChartFont();
			int    baseline = CENTER;
			int    alignment = RIGHT;

			GetText(Array location) = toString(location[0]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[0] < 9)
				    location[0]++;
				else location = NULL;
			    } else location = new Array {0, -1};
			    return(location);
			}
		    },

		    new Dictionary {
			String group = ROW_LABELS;
			double xoffset = 0.2;
			double yoffset = 0.0;
			int    baseline = CENTER;
			int    alignment = LEFT;

			GetText(Array location) = toString(location[0]+1);

			NextCellLocation(Array location) {
			    if (location) {
				if (location[0] < 9)
				    location[0]++;
				else location = NULL;
			    } else location = new Array {0, 18};
			    return(location);
			}
		    },
		};
		break;
	}

	return(generators);
    };

    GetChartMenuData() {
	return(new Array {
	    new Dictionary {
		String text = PERIODIC_TABLE_STANDARD;
		int    state = TRUE;
		int    preload = FALSE;
	    },
	    new Dictionary {
		String text = PERIODIC_TABLE_WIDE;
		int    preload = TRUE;
	    },
	    NULL,
	    new Dictionary {
		String text = ISOTOPE_TABLE;
		int    preload = TRUE;
	    },
	    new Dictionary {
		String text = NUCLIDE_TABLE;
		int    preload = TRUE;
	    },
	    NULL,
	    new Dictionary {
		String text = PERIODIC_PUZZLE;
		int    preload = TRUE;
	    },
	});
    }

    GetVersion() {
	return("Interactive Periodic Table - Version 1.0\nDeveloped by AT&T Labs - Research");
    }

    LoadChart() {
	simplecellmodel = TRUE;
	cellaspect = 3.0/4.0;

	switch (chartmodel) {
	    case ISOTOPE_TABLE:
		LoadIsotopeTable();
		break;

	    case NUCLIDE_TABLE:
		LoadNuclideTable();
		break;

	    case PERIODIC_PUZZLE:
		LoadPeriodicPuzzle();
		break;

	    case PERIODIC_TABLE_STANDARD:
		LoadPeriodicTableStandard();
		break;

	    case PERIODIC_TABLE_WIDE:
		LoadPeriodicTableWide();
		break;

	    default:
		Die("chart model %s is not supported", chartmodel);
		break;
	}
    }

    ////////////////////////////
    //
    // Support Functions
    //
    ////////////////////////////

    LoadIsotopeTable() {
	Dictionary element;
	Dictionary cell;
	Array      isotopes;
	int        primary_isotope;
	int        row;
	int        column;

	rows = 92;		// U 238 is heaviest naturally occurring isotope
	columns = 147;
	arrowselector = 0;
	chartcells = new Array[rows*columns];

	for (ptr in ElementData) {
	    element = *ptr;
	    if (element.Z <= rows) {
		if ((primary_isotope = element.primary_isotope) >= 0) {
		    for (ptr in element.isotopes by FIELDS_PER_ISOTOPE) {
			if (ptr[1]) {
			    row = rows - element.Z;
			    column = ptr[0];
			    cell = NewChartCell(element.name, row, column, 1, 1, element, ptr);
			    cell.tip = cell.name;
			    if (column == primary_isotope)
				cell.selectable = TRUE;
			}
		    }
		}
	    } else break;
	}
    }

    LoadNuclideTable() {
	Dictionary element;
	Dictionary cell;
	Array      isotopes;
	int        primary_isotope;
	int        row;
	int        column;

	rows = 96;			// Curium is last one in our data
	columns = 156;
	arrowselector = 0;
	chartcells = new Array[rows*columns];

	for (ptr in ElementData) {
	    element = *ptr;
	    if (element.Z <= rows) {
		if ((primary_isotope = element.primary_isotope) >= 0) {
		    for (ptr in element.isotopes by FIELDS_PER_ISOTOPE) {
			row = rows - element.Z;
			column = ptr[0];
			cell = NewChartCell(element.name, row, column, 1, 1, element, ptr);
			cell.tip = cell.name;
			if (column == primary_isotope)
			    cell.selectable = TRUE;
		    }
		}
	    } else break;
	}
    }

    LoadPeriodicPuzzle() {
	Dictionary element;
	Dictionary cell;
	int        row;
	int        column;

	rows = 10;
	columns = 18;
	arrowselector = -1;
	chartcells = new Array[rows*columns];

	puzzle = TRUE;
	scatter = TRUE;
	showgrid = TRUE;
	snaptogrid = TRUE;
	autocheck = TRUE;

	scatterrects = new Array {
	    new Rectangle {
		double x = -5;
		double y = -1;
		double width = 4;
		double height = 12;
	    },

	    new Rectangle {
		double x = 19;
		double y = -1;
		double width = 4;
		double height = 12;
	    },

	    new Rectangle {
		double x = -5;
		double y = -2.5;
		double width = 28;
		double height = 1.5;
	    },

	    new Rectangle {
		double x = -5;
		double y = 10.75;
		double width = 28;
		double height = 1.5;
	    },
	};

	for (ptr in ElementData) {
	    element = *ptr;
	    row = element.period - 1;
	    switch (element.period) {
		case 1:
		    column = element.Z == 1 ? 0 : 17;
		    break;

		case 2:
		    if ((column = element.Z - 3) > 1)
			column += 10;
		    break;

		case 3:
		    if ((column = element.Z - 11) > 1)
			column += 10;
		    break;

		case 4:
		    column = element.Z - 19;
		    break;

		case 5:
		    column = element.Z - 37;
		    break;

		case 6:
		    if (element.Z < 58 || element.Z > 71) {
			if ((column = element.Z - 55) > 2)
			    column -= 14;
		    } else {
			row = 8;
			column = element.Z - 58 + 2;	// put Ce under group 3
		    }
		    break;

		case 7:
		    if (element.Z < 90 || element.Z > 103) {
			if ((column = element.Z - 87) > 2)
			    column -= 14;
		    } else {
			row = 9;
			column = element.Z - 90 + 2;	// put Th under group 3
		    }
		    break;
	    }
	    cell = NewChartCell(element.name, row, column, 1, 1, element, NULL);
	    cell.tip = cell.name;
	}
    }

    LoadPeriodicTableStandard() {
	Dictionary element;
	Dictionary cell;
	int        row;
	int        column;

	rows = 10;
	columns = 18;
	arrowselector = -1;
	chartcells = new Array[rows*columns];

	for (ptr in ElementData) {
	    element = *ptr;
	    row = element.period - 1;
	    switch (element.period) {
		case 1:
		    column = element.Z == 1 ? 0 : 17;
		    break;

		case 2:
		    if ((column = element.Z - 3) > 1)
			column += 10;
		    break;

		case 3:
		    if ((column = element.Z - 11) > 1)
			column += 10;
		    break;

		case 4:
		    column = element.Z - 19;
		    break;

		case 5:
		    column = element.Z - 37;
		    break;

		case 6:
		    if (element.Z < 58 || element.Z > 71) {
			if ((column = element.Z - 55) > 2)
			    column -= 14;
		    } else {
			row = 8;
			column = element.Z - 58 + 2;	// put Ce under group 3
		    }
		    break;

		case 7:
		    if (element.Z < 90 || element.Z > 103) {
			if ((column = element.Z - 87) > 2)
			    column -= 14;
		    } else {
			row = 9;
			column = element.Z - 90 + 2;	// put Th under group 3
		    }
		    break;
	    }
	    cell = NewChartCell(element.name, row, column, 1, 1, element, NULL);
	    cell.tip = cell.name;
	}
    }

    LoadPeriodicTableWide() {
	Dictionary element;
	Dictionary cell;
	int        row;
	int        column;

	//
	// Wide version of the periodic table that places f block elements
	// in the same row as the other elements in their period.
	//

	rows = 7;
	columns = 32;
	arrowselector = -1;
	chartcells = new Array[rows*columns];

	for (ptr in ElementData) {
	    element = *ptr;
	    row = element.period - 1;
	    switch (element.period) {
		case 1:
		    column = element.Z == 1 ? 0 : 31;
		    break;

		case 2:
		    if ((column = element.Z - 3) > 1)
			column += 24;
		    break;

		case 3:
		    if ((column = element.Z - 11) > 1)
			column += 24;
		    break;

		case 4:
		    if ((column = element.Z - 19) > 2)
			column += 14;
		    break;

		case 5:
		    if ((column = element.Z - 37) > 2)
			column += 14;
		    break;

		case 6:
		    column = element.Z - 55;
		    break;

		case 7:
		    column = element.Z - 87;
		    break;
	    }
	    cell = NewChartCell(element.name, row, column, 1, 1, element, NULL);
	    cell.tip = cell.name;
	}
    }

    PickColorsFor(String text) {
	Object colors;

	//
	// The object that we build is handed back to GetCellBackground()
	// whenever we need a cell's background color. In other words the
	// only requirement for colors is that GetCellBackground() should
	// be happy with it.
	//

	switch (text) {
	    case COLORBY_ATOMIC_RADIUS:
		colors = new Array {
		    0, CellColors.UNKNOWN,
		    75, CellColors.BLUE,
		    150, CellColors.GREEN,
		    225, CellColors.TAN,
		    300, CellColors.BROWN,
		};
		break;

	    case COLORBY_BLOCK:
		colors = new Dictionary[] {
		    "s", CellColors.BLUE,
		    "p", CellColors.GREEN,
		    "d", CellColors.TAN,
		    "f", CellColors.BROWN,
		};
		break;

	    case COLORBY_BOILING_POINT:
		colors = new Array {
		    0, CellColors.UNKNOWN,
		    200, CellColors.BLUE,
		    330, CellColors.GREEN,
		    2000, CellColors.TAN,
		    4000, CellColors.BROWN,
		    6000, CellColors.RED,
		};
		break;

	    case COLORBY_CHECKERBOARD:
		colors = new Array[] {CellColors.TAN, CellColors.BROWN};
		break;

	    case COLORBY_CLASSIFICATION:
		colors = new Dictionary[] {
		    METAL, CellColors.LIGHTGRAY,
		    SEMIMETAL, CellColors.GRAY,
		    NONMETAL, CellColors.DARKGRAY,
		    UNKNOWN, CellColors.TAN,
		};
		break;

	    case COLORBY_COLOR_TAN:
		colors = CellColors.TAN;
		break;

	    case COLORBY_COLOR_BROWN:
		colors = CellColors.BROWN;
		break;

	    case COLORBY_DECAY_MODE:
		colors = new Dictionary[] {
		    ALPHA, CellColors.RED,
		    BETA, CellColors.GREEN,
		    POSITRON, CellColors.BLUE,
		    EC, CellColors.CYAN,
		    PROTON, CellColors.BROWN,
		    NEUTRON, CellColors.YELLOW,
		    SF, CellColors.MAGENTA,

		    STABLE, CellColors.TAN,
		    UNKNOWN, CellColors.UNKNOWN,
		};
		break;

	    case COLORBY_ELECTRONEGATIVITY:
		colors = new Array {
		    0, CellColors.UNKNOWN,
		    1, CellColors.BLUE,
		    2, CellColors.GREEN,
		    3, CellColors.TAN,
		    4, CellColors.BROWN,
		};
		break;

	    case COLORBY_HALF_LIFE:
		colors = new Dictionary[] {
		    "y", CellColors.BROWN,
		    "d", CellColors.BLUE,
		    "h", CellColors.CYAN,
		    "m", CellColors.MAGENTA,
		    "s", CellColors.RED,

		    STABLE, CellColors.TAN,
		    UNKNOWN, CellColors.UNKNOWN,
		};
		break;

	    case COLORBY_MELTING_POINT:
		colors = new Array {
		    0, CellColors.UNKNOWN,
		    200, CellColors.BLUE,
		    330, CellColors.GREEN,
		    1000, CellColors.TAN,
		    3000, CellColors.BROWN,
		    4000, CellColors.RED,
		};
		break;

	    case COLORBY_RADIOACTIVE:
		colors = new Dictionary[] {
		    NO, CellColors.TAN,
		    TRACE, CellColors.BROWN,
		    YES, CellColors.RED,
		};
		break;

	    case COLORBY_STATE:
		colors = new Dictionary[] {
		    SOLID, CellColors.TAN,
		    LIQUID, CellColors.GREEN,
		    GAS, CellColors.BLUE,
		};
		break;
	}
	return(colors);
    }

    SortByGroup(int selector, Array names) {
	Dictionary cell;
	Array      keys[names@sizeof];
	int        index;

	Compare(Object left, Object right) {
	    int result;

	    if (left[0] == right[0])
		result = (left[1] < right[1]) ? -1 : (left[1] > right[1] ? 1 : 0);
	    else result = (left[0] < right[0]) ? -1 : 1;
	    return(result);
	}

	for (ptr in names) {
	    if (defined(ptr) && defined(*ptr, namemap)) {
		if (namemap[*ptr] instanceof Array)
		    cell = namemap[*ptr][0];
		else cell = namemap[*ptr];
		keys[index++] = new Array {atoi(cell.data.properties[GROUP], 10, 1000), cell.index};
	    } else keys[index++] = NULL;
	}
	qsort(keys, &Compare, names);
    }
};

//
// These are used to store string bounds measurements (currently only for
// one font) that's filled in when we build the first table. The code is
// confusing and it's probably not worth trying to understand. We'll take
// another look at it all in the near future - we suspect we can simplify
// some of the GetMinimumSize() functions that use them and perhaps even
// eliminating some of these functions.
//

Dictionary FieldBoundsCache[0, ...];

GetFieldBounds(Array data, String name) {
    Object field;

    if (!defined(name, FieldBoundsCache)) {
	for (ptr in data) {
	    if (defined(name, ptr[0])) {
		field = ptr[0][name];
		if (field instanceof Number)
		    field = toString(field);
		if (field instanceof String)
		    FieldBoundsCache[name] = rectUnionRect(defined(name, FieldBoundsCache) ? FieldBoundsCache[name] : NULL, NormalCellFont.stringbounds(field, TRUE));
	    }
	}
    }
    return(FieldBoundsCache[name]);
}

GetArrayElementBounds(Array data, String name, int index) {
    Object field;

    if (!(defined(name, FieldBoundsCache) && defined(index, FieldBoundsCache[name]))) {
	for (ptr in data) {
	    if (defined(name, ptr[0])) {
		field = ptr[0][name];
		if (field instanceof Array) {
		    if (defined(index, field)) {
			if (!defined(name, FieldBoundsCache))
			    FieldBoundsCache[name] = new Array[field@sizeof, ...];
			field = field[index];
			if (field instanceof Number)
			    field = toString(field);
			if (field instanceof String) {
			    if (!defined(index, FieldBoundsCache[name]))
				FieldBoundsCache[name][index] = NULL;
			    FieldBoundsCache[name][index] = rectUnionRect(FieldBoundsCache[name][index], NormalCellFont.stringbounds(field, TRUE));
			}
		    }
		}
	    }
	}
    }
    return(FieldBoundsCache[name][index]);
}

GetArrayOverlayBounds(Array data, String name, int index, int length) {
    Object field;

    if (!(defined(name, FieldBoundsCache) && defined(index, FieldBoundsCache[name]))) {
	for (ptr in data) {
	    if (defined(name, ptr[0])) {
		field = ptr[0][name];
		if (field instanceof Array) {
		    for (ptr in field by length) {
			if (defined(index, ptr)) {
			    if (!defined(name, FieldBoundsCache))
				FieldBoundsCache[name] = new Array[field@sizeof, ...];
			    field = ptr[index];
			    if (field instanceof Number)
				field = toString(field);
			    if (field instanceof String) {
				if (!defined(index, FieldBoundsCache[name]))
				    FieldBoundsCache[name][index] = NULL;
				FieldBoundsCache[name][index] = rectUnionRect(FieldBoundsCache[name][index], NormalCellFont.stringbounds(field, TRUE));
			    }
			}
		    }
		}
	    }
	}
    }
    return(FieldBoundsCache[name][index]);
}

GetLineBounds(...) {
    Rectangle bounds = NULL;
    Rectangle rect = NULL;
    Object    arg;

    //
    // Assumes the arguments represent "stuff" that's supposed to be laid
    // out along the current baseline as a line of text and the rectangle
    // that we return is supposed to cover all the "stuff".
    //

    if (argc > 1) {
	for (ptr in &argv[1]) {
	    if (arg = *ptr) {
		if (arg instanceof String)
		    rect = NormalCellFont.stringbounds(arg, TRUE);
		else if (arg instanceof Number) {
		    rect = new Rectangle {
			double width = arg;
		    };
		} else if (arg instanceof Array) {
		    if (arg@sizeof == 2)
			rect = GetFieldBounds(unroll(arg));
		    else if (arg@sizeof == 3)
			rect = GetArrayElementBounds(unroll(arg));
		    else if (arg@sizeof == 4)
			rect = GetArrayOverlayBounds(unroll(arg));
		} else if (arg instanceof Rectangle)
		    rect = arg;
		else rect = NULL;
		if (rect != NULL) {
		    if (bounds != NULL) {
			bounds.width += rect.x + rect.width;
			rect = rectUnionRect(rect, bounds);
			bounds.y = rect.y;
			bounds.height = rect.height;
		    } else bounds = new Rectangle {unroll(rect)};	// don't change rect!!!
		}
	    }
	}
    }
    return(bounds);
}

//
// All that's left to do is show mainscreen, which should only be done by
// calling the ShowScreen() function that's defined in mainscreen.
//

mainscreen.ShowScreen();

