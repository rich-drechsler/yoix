//
// A collection of generally useful functions that include several that
// make it easy to implement standard behavior in Swing event handlers.
// Take a look at DragGestureRecognized() and KeyPressed() definitions
// below and how they're used in some of our screen files and you should
// be able to incorporate them in your own screens.
//

CompareNumbers(a, b) = (a - b);

CopyFromSystemClipboard(Object dest) {
    Clipboard clipboard;
    Object    contents;
    Array     ends;

    if (dest != NULL) {
	if ((clipboard = getSystemClipboard()) != NULL) {
	    if ((contents = clipboard.contents) != NULL) {
		if (contents instanceof String) {
		    if (dest instanceof JTextArea || dest instanceof JTextField) {
			ends = dest.selectedends;
			if (ends[1] > ends[0])
			    deleteText(dest, ends[0], ends[1] - ends[0]);
			insertText(dest, contents, dest.caret);
		    }
		}
	    }
	}
    }
}

CopyToClipboardScreen(String text) {
    Object screen;

    if ((screen = GetCachedScreen("clipboard")) != NULL) {
	if (screen.visible)
	    screen.ReplaceText(text);
    }
}

CopyToSystemClipboard(Object source) {
    Clipboard clipboard;
    Object    contents;

    if ((clipboard = getSystemClipboard()) != NULL) {
	if (source instanceof JTextField)
	    contents = (source.echo == 0) ? source.selected : NULL;
	else if (source instanceof JTextArea || source instanceof JTextPane)
	    contents = source.selected;
	else if (defined("text", source))
	    contents = source.text;
	if (contents != NULL)
	    clipboard.setContents(contents);
    }
}

FilterTableREFlags(Object root, String basetag) {

    int flags = 0;

    if (!root.components[basetag + "_case_sensitive"].state)
	flags |= CASE_INSENSITIVE;

    if (!root.components[basetag + "_re_pattern"].state) {
	if (root.components[basetag + "_glob_pattern"].state)
	    flags |= SHELL_PATTERN;
	else flags |= TEXT_PATTERN;
    }

    return(flags);
}

GetFromArgArray(String argname, Array args, Object dflt, ...) {
    Object  obj = dflt;
    Object  retval = NULL;

    for (ptr in args by 2) {
	if (*ptr === argname) {
	    obj = *(ptr + 1);
	    break;
	}
    }

    if (obj instanceof Callable)
	retval = obj(unroll(&dflt + 1));
    else retval = obj;

    return(retval);
}

GetTableRowFromColumn(JTable table, int row, int col, int visible) {

    int    len = table.width;
    int    vcol = table.action(GET_COLUMN_VIEW_INDEX, col);
    int    dcol;
    int    m, n;
    Array  cols[0, ...];

    for (m = 0, n = vcol; n < len; n++) {
	dcol = table.action(GET_COLUMN_DATA_INDEX, n);
	if (!visible || table.action(GET_COLUMN_FIELD, dcol, "width") > 0) {
	    cols[m++] = table.action(GET_FIELD, row, dcol, "view");
	}
    }

    return(strjoin(cols, table.outputfilter[0]));
}

GetUserInfo() {
    return("You are logged in to " + ACRONYM + " as user " + UserName + " in group " + GroupName);
}

GetVersionInfo() {
    String text;
    String developer = trim(DeveloperOrganization);

    text += ACRONYM + " Release: " + ReleaseNumber;
    if (ReleaseDate@sizeof > 0)
	text += " - " + ReleaseDate;
    text += "\n";
    if (BetaPrefix@sizeof > 0)
	text += "    [Using Beta Prefix " + BetaPrefix + "]\n";
    if (developer@sizeof > 0)
	text += ACRONYM + " is a product of " + developer + "\n";
    text += "Yoix Version: " + VM.Version + " - " +  date("MM/dd/yy", parseDate(Locale.US, VM.Created)) + "\n";
    if (JavaRuntimeVersion@sizeof > 0)
	text += "Java Version: " + JavaRuntimeVersion + "\n";
    text += "Yoix is a product of AT&T Labs - Research\n";
    if (JavaVendor@sizeof > 0)
	text += "Java is a product of " + JavaVendor + "\n";
    text += "Yoix is a registered trademark of AT&T";
    return(text);
}

HaveAppleExtension() {
    return(ISMAC && defined("apple", yoix) && defined("appleApplication", yoix.apple) && appleApplication());
}

IsAquaLookAndFeel() {
    return(ISMAC && indexOf(toLowerCase(VM.screen.uimanager.lookandfeel), "aqua") >= 0);
}

Options() {
    Option option;
    int    ch;
    int    index;

    while ((ch = getopt(option, global.argv, "d:g:z:G:R:T:")) != -1) {
	switch (ch) {
	    case 'd':
		SetPreferredDebugging(atoi(option.optarg));
		break;

	    case 'g':
		GarbageTimer = atoi(option.optarg);
		break;

	    case 'z':
		UserTimeZone = option.optarg;
		break;

	    case 'G':
		split = strsplit(option.optarg, "=", -2);
		if (split[0] != NULL && split[0]@length > 0)
		    CommandOpts[split[0]] = split[1];
		break;

	    case 'R':
		ReleaseNumber = option.optarg;
		break;

	    case 'T':
		ReleaseDate = option.optarg;
		break;

	    default:
		ShowWarning("Command line option error: " + option.opterror);
		break;
	}
    }
    global.argc -= option.optind;
    global.argv += option.optind;
}

PickCalendarFor(Object arg, ...) {
    Calendar cal;
    double   now;

    //
    // Primarily for the calendar popup window, but it could be useful
    // elsewhere. Probably should handle more strings and perhaps even
    // accept a function that's called to return the time (perhaps for
    // complicated JPanel that also happens to include a date panel).
    //

    if (arg instanceof String) {
	now = (argc > 2) ? argv[2] : time();
	cal.unixtime = now;
	if (arg === "now" || arg === "today")
	    cal.unixtime = now;
	else if (arg === "tomorrow")
	    cal.add(Calendar.DAY_OF_YEAR, 1);
	else if (arg === "yesterday")
	    cal.add(Calendar.DAY_OF_YEAR, -1);
	else if (arg === "nextweek")
	    cal.add(Calendar.DAY_OF_YEAR, 7);
	else if (arg === "lastweek")
	    cal.add(Calendar.DAY_OF_YEAR, -7);
	else if (arg === "nextmonth")
	    cal.add(Calendar.MONTH, 1);
	else if (arg === "lastmonth")
	    cal.add(Calendar.MONTH, -1);
	else if (arg === "nextyear" || arg === "one year from now")
	    cal.add(Calendar.YEAR, 1);
	else if (arg === "two years from now")
	    cal.add(Calendar.YEAR, 2);
	else if (arg === "three years from now")
	    cal.add(Calendar.YEAR, 3);
	else if (arg === "lastyear" || arg === "one year ago")
	    cal.add(Calendar.YEAR, -1);
	else if (arg === "two years ago")
	    cal.add(Calendar.YEAR, -2);
	else if (arg === "three years ago")
	    cal.add(Calendar.YEAR, -3);
	else if (arg === "four years ago")
	    cal.add(Calendar.YEAR, -4);
	else if (arg === "five years ago")
	    cal.add(Calendar.YEAR, -5);
	else if (arg === "lastdecade" || arg === "ten years ago")
	    cal.add(Calendar.YEAR, -10);
	else cal = NULL;
    }
    return(cal);
}

PickUnixTime(Object arg, ...) {
    Object cal;
    double unixtime = NaN;
    double now;

    //
    // Primarily for the calendar popup window, but it could be useful
    // elsewhere. Probably should handle more strings and perhaps even
    // accept a function that's called to return the time (perhaps for
    // complicated JPanel that also happens to include a date panel).
    //

    if (arg instanceof String) {
	cal = PickCalendarFor(unroll(&arg));
	unixtime = (cal != NULL) ? cal.unixtime : NaN;
    } else if (defined("PickUnixTime", arg) && arg.PickUnixTime instanceof Function && arg.PickUnixTime@sizeof == 0)
	unixtime = arg.PickUnixTime();
    else if (defined("calendar", arg) && arg.calendar instanceof Calendar)
	unixtime = arg.calendar.unixtime;
    else if (arg instanceof Calendar)
	unixtime = arg.unixtime;
    else if (arg instanceof double)
	unixtime = arg;
    return(unixtime);
}

Quit(int status) {
    //
    // The three lines that claim they're trying to prevent a hang during
    // JVM shutdown are just a guess. The hang was an occasional problem
    // that we only saw on windows and the Java dump wasn't all that much
    // help. Anyway, the lines marked by comments that mention hangs are
    // just a guess that should prevent any updating of the status labels,
    // which is where we suspect the hangs were happening.
    //

    Quitting = TRUE;
    ScreenVisibility = FALSE;		// no more screens will be shown
    NetworkStatus = NULL;		// kludge for rare shutdown hangs??
    ServerStatus = NULL;		// kludge for rare shutdown hangs??
    if (currentThread() != CommandThread)
	Stop();				// kludge for rare shutdown hangs??
    exit(status);
}

Rejected(Dictionary header) {
    if (!Quitting) {
	if (SessionID != NULL) {
	    SessionID = NULL;
	    ShowHeaderMessage(NULL, header);
	} else header.MESSAGE = NULL;
	Quit(2);
    }
}

SoundBeeps(int count) {
    while (count-- > 0) {
	beep();
	if (count > 0)
	    sleep(.3);
    }
}

//
// Several functions that implement some standard behavior when used as
// event handlers in some Swing components. They assume they run in the
// component's, which means the interpreter resolves "this", at runtime
// to the appropriate component.
//

AdjustmentValueChanged(e) {
    String status;
    Point  point;
    int    firstrow;
    int    lastrow;

    //
    // Currently only for JTables that also define a function named
    // SetScrollStatus.
    //

    if (this instanceof JTable) {
	if (e.orientation == VERTICAL) {
	    if (defined("SetScrollStatus", this)) {
		if (this.SetScrollStatus instanceof Function) {
		    point = this.origin;
		    if ((firstrow = this.action(FIND_CELL_AT, point).viewRow) >= 0) {
			lastrow = min(firstrow + viewrowcount, rows);
			if (firstrow < lastrow)
			    firstrow++;
			else firstrow = lastrow;
			status = strfmt("%d - %d", firstrow, lastrow);
		    }
		    this.SetScrollStatus(status);
		}
	    }
	}
    }
}

DragEnter(DropTargetEvent e) {
    int accepted = FALSE;

    //
    // Only for indicating our willingness to accept an object that's
    // being dragged, which is why the argument is explicitly declared
    // as a DropTargetEvent. In other words, we don't have deal with
    // DragSourceEvents, and that also gurantees there's a dragowner
    // field in e.
    //

    SyncDropTargetEvent(e);

    if (!defined("DragEnterHandler", this) || this.DragEnterHandler == NULL || !this.DragEnterHandler(e)) {
	if (this instanceof JTextArea || this instanceof JTextField || this instanceof JTextPane || this instanceof JTable)
	    accepted = this.edit;
	else if (this instanceof JChoice || this instanceof JComboBox)
	    accepted = !e.dragowner;
    } else accepted = TRUE;
    return(accepted);
}

DragGestureRecognized(e) {
    Dictionary cell;
    Array      ends;
    int        index;

    //
    // A generic dragGestureRecognized() event handler that can be used
    // by some Swing components. We haven't tried to support all Swing
    // components, and some will probably always need their own custom
    // implementations. Current versions of Yoix require that you store
    // NULL in the component's transferhandler field before the custom
    // dragGestureRecognized() event handler will be activated.
    //

    if (this instanceof JTextArea || this instanceof JTextField || this instanceof JTextPane) {
	//
	// The checks make sure we only start dragging (by returning
	// a non-NULL value) if the event happened inside the current
	// selection.
	//
	if (!(this instanceof JTextField) || this.echo == 0) {
	    if ((ends = this.selectedends) != NULL) {
		index = this.viewToModel(e.location);
		if (index >= ends[0] && index < ends[1])
		    e.visual = selected;
	    }
	}
    } else if (this instanceof JTable) {
	if ((cell = action(FIND_CELL_AT, e.location)) != NULL) {
	    if (cell.valuesRow >= 0 && cell.valuesColumn >= 0) {
		e.visual = action(GET_FIELD, cell.valuesRow, cell.valuesColumn);
		action(EDIT_STOP);
	    }
	}
    } else if (this instanceof JChoice || this instanceof JComboBox) {
	if ((index = indexOfObject(mappings, selected)) >= 0) {
	    if (trim(labels[index])@sizeof > 0)
		e.visual = labels[index];
	}
    } else if (defined("text", this)) {
	//
	// This will cover quite a many other components, but it may not
	// be what you want. We look for a field named dragtext first and
	// use it if it's defined and not NULL, which gives the component
	// a way to drag something other than what's actually displayed.
	//
	e.visual = (defined("dragtext", this) && this.dragtext != NULL) ? this.dragtext : this.text;
    }

    if (e.visual != NULL) {
	if (defined("CancelMousePressed", this))
	    this.CancelMousePressed();
    }

    return(e.visual);
}

Drop(e) {
    Dictionary cell;
    Object     transferable;
    int        accepted = FALSE;
    int        row;
    int        column;
    int        index;

    //
    // A generic drop() event handler that really only works well in a few
    // Swing components.
    //

    SyncDropTargetEvent(e);

    if ((transferable = e.transferable) != NULL) {
	if (!defined("DropHandler", this) || this.DropHandler == NULL || !this.DropHandler(e)) {
	    if (this instanceof JTextArea || this instanceof JTextField || this instanceof JTextPane) {
		if (this.edit && transferable instanceof String) {
		    insertText(this, transferable, viewToModel(e.location), TRUE);
		    this.requestfocus = TRUE;
		    accepted = TRUE;
		}
	    } else if (this instanceof JTable) {
		if (this.edit) {
		    if ((cell = action(FIND_CELL_AT, e.location)) != NULL) {
			if ((row = cell.valuesRow) >= 0 && (column = cell.valuesColumn) >= 0) {
			    if (columns[column].edit == NULL || columns[column].edit) {
				try {
				    action(EDIT_STOP);	// recent addition - it could be improved
				    action(SET_FIELD, row, column, transferable);
				    accepted = TRUE;
				}
				catch(e) {}
			    }
			}
		    }
		}
	    } else if (this instanceof JChoice || this instanceof JComboBox) {
		if (!e.dragowner && transferable instanceof String) {
		    if ((index = indexOfObject(labels, transferable)) >= 0) {
			this.selected = index;
			accepted = TRUE;
		    }
		}
	    } else if (defined("text", this)) {
		if (!e.dragowner && transferable instanceof String) {
		    this.text = transferable;
		    accepted = TRUE;
		}
	    }
	} else accepted = TRUE;
    }
    return(accepted);
}

SyncDropTargetEvent(DropTargetEvent e) {
    if (defined("String", e.transferable))
	e.transferable = e.transferable.String;
}

KeyPressed(e) {
    //
    // Adds keyboard control over cut and paste to the Swing components
    // supported by CopyToSystemClipboard() and CopyToSystemClipboard().
    //

    if (e.modifiersdown & CTRL_DOWN_MASK || (ISMAC && (e.modifiersdown & META_DOWN_MASK))) {
	switch (e.keycode) {
	    case KeyCode.VK_C:
		CopyToSystemClipboard(this);
		break;

	    case KeyCode.VK_V:
		if (strcasecmp(VM.screen.uimanager.lookandfeel, "Windows"))
		    CopyFromSystemClipboard(this);
		break;
	}
    }
}

KeyTyped(e) {
    //
    // Currently just shifts the focus to another component when the user
    // types a newline in a JTextField.
    //

    switch (e.keychar) {
	case '\n':
	    if (this instanceof JTextField)
		this.requestfocus = FALSE;
	    break;
    }
}

MouseReleased(e) {
    //
    // Adds mouse button control over cut and paste to Swing components
    // supported by CopyToSystemClipboard() and CopyToSystemClipboard().
    //

    switch (e.modifiers) {
	case BUTTON1_MASK:
	    CopyToSystemClipboard(this);
	    break;

	case BUTTON2_MASK:
	case BUTTON3_MASK:
	    CopyFromSystemClipboard(this);
	    break;
    }
}

MouseWheelMoved(e) {
    int index;

    //
    // A generic mouseWheelMoved() event handler.
    //

    if (this instanceof JChoice) {
	index = indexOfObject(this.mappings, this.selected);
	if (e.wheelrotation < 0) {
	    if (--index >= 0)
		this.selected = index;
	} else {
	    if (++index < this.mappings@length)
		this.selected = index;
	}
    } else if (this instanceof JSlider || this instanceof JScrollBar)
	this.value += e.wheelrotation;
}

WindowClosed(e) {
    if (defined("HideScreen", this))
	this.HideScreen();
    else HideScreen(this);
}

WindowClosing(e) {
    if (!disposeonclose) {
	if (defined("HideScreen", this))
	    this.HideScreen();
	else HideScreen(this);
    }
    return(!disposeonclose);
}

//
// Event handlers used in NewJDateTimePanel() and NewJDatePanel().
//

CalendarMouseEntered(e) {
    if (enabled)
	requestfocus = TRUE;
}

CalendarFocusGained(e) {
    if (enabled) {
	if (root.components[basetag].normalborder == NULL) {
	    root.components[basetag].normalborder = border;
	    root.components[basetag].activeborder = new Border {
		int    type = LINED;
		double thickness = VM.screen.pixelwidth;
		Color  background = foreground;
	    };
	}
	border = root.components[basetag].activeborder;
    }
}

CalendarFocusLost(e) {
    if (root.components[basetag].normalborder != NULL)
	border = root.components[basetag].normalborder;
    root.components[basetag].StopTyping(tag);
}

CalendarKeyPressed(e) {
    if (enabled) {
	switch(e.keycode) {
	    case KeyCode.VK_UP:
		root.components[basetag].UpdateDisplay(caltype, 1);
		if (defined("consumed", e))
		    e.consumed = TRUE;
		break;

	    case KeyCode.VK_DOWN:
		root.components[basetag].UpdateDisplay(caltype, -1);
		if (defined("consumed", e))
		    e.consumed = TRUE;
		break;
	}
    }
}

CalendarKeyTyped(e) {
    if (enabled) {
	if (e.modifiersdown == 0 || e.modifiersdown == SHIFT_DOWN_MASK)
	    root.components[basetag].TypedChar(tag, e.keystring);
    }
}

CalendarMouseWheelMoved(e) {
    if (enabled)
	root.components[basetag].UpdateDisplay(caltype, -e.wheelrotation);
}

CalendarMousePressed(e) {
    if (enabled) {
	if (root.components[basetag].pressedborder == NULL) {
	    root.components[basetag].pressedborder = new Border {
		int    type = LINED;
		double thickness = VM.screen.pixelwidth;
		Color  background = GetPreferredActiveColor();
	    };
	}
	saveborder = border;
	border = root.components[basetag].pressedborder;
    }
}

CalendarMouseReleased(e) {
    if (enabled) {
	root.components[basetag].ShowCalendar();
	border = saveborder;
    }
}

ClockMousePressed(e) {
    if (enabled) {
	if (root.components[basetag].pressedborder == NULL) {
	    root.components[basetag].pressedborder = new Border {
		int    type = LINED;
		double thickness = VM.screen.pixelwidth;
		Color  background = GetPreferredActiveColor();
	    };
	}
	saveborder = border;
	border = root.components[basetag].pressedborder;
    }
}

ClockMouseReleased(e) {
    if (enabled) {
	//root.components[basetag].ShowClock(); // TODO
	border = saveborder;
    }
}

//
// JTable support functions.
//

BuildTableTags(Object table) {
    Dictionary tags;
    String     tag;
    Object     activeforeground;
    Array      activetags;
    Array      activecolumns;
    Array      columns;
    int        index;
    int        n;

    //
    // Used to build a dictionary and array that keep track of the tags
    // that are associated with the columns in a table. Both are optional
    // and only built if the table defines the appriopriate fields, but
    // if built they're also automatically assigned to the appropriate
    // table fields (i.e., tags and activecolumns).
    // 

    if (table instanceof JTable) {
	if ((columns = table.columns) != NULL) {
	    tags = defined("tags", table) ? new Dictionary[0, ...] : NULL;
	    if (defined("activetags", table) && defined("activecolumns", table)) {
		activetags = table.activetags;
		activecolumns = new Array[activetags@sizeof];
		for (n = 0; n < activecolumns@sizeof; n++)
		    activecolumns[n] = -1;
	    } else activecolumns = NULL;
	    activeforeground = defined("activeforeground", table) ? table.activeforeground : NULL;
	    for (n = 0; n < columns@sizeof; n++) {
		if ((tag = columns[n].tag) !~ "^_[0-9]*") {
		    if ((index = indexOfObject(activetags, tag)) >= 0) {
			activecolumns[index] = n;
			if (activeforeground != NULL)
			    table.action(SET_COLUMN_FIELD, n, "foreground", activeforeground);
		    }
		    if (tags != NULL)
			tags[tag] = n;
		}
	    }
	    if (activecolumns != NULL)
		table.activecolumns = activecolumns;
	    if (defined("activemask", table) && (table.activemask & BUTTON_MASK) == 0)
		table.activemask |= BUTTON1_MASK;
	    if (tags != NULL)
		table.tags = tags;
	}
    }
}

GenerateTableHTML(Object table, Object root, String title, String extra, int include_hidden, ...) {
    int      tblwid = include_hidden ? table.width : table.visiblewidth;
    Array    lines[(3 + tblwid + (2 + tblwid) * table.rows),...];
    Pointer  ptr = lines;
    Array    columns;
    Array    alignments[0,...];
    Array    halignments[0,...];
    Array    headers[0,...];
    Array    types[0,...];
    Array    html[0,...];
    Array    position[0,...];
    Array    strdata;
    Array    data;
    String   autotitle = NULL;
    String   tmpstr;
    String   path;
    int      maxrows = (argc > 6) ? argv[6] : -1;
    int      removepath = (argc > 7) ? argv[7] : FALSE;
    int      sz;
    int      ln;
    int      m, n;

    //
    // Added two optional arguments. The first specifies the maximum number of
    // rows allowed in tables that will be converted to HTML. A value less than
    // or equal to 0, which is the default, means there's no limit. The second
    // optional argument can be set to TRUE when you want to immediately delete
    // the temp file that was created by ViewFile().
    //

    if (maxrows <= 0 || table.rows < maxrows) {
	if (defined("tabletitletag", table)) {
	    if (table.tabletitletag instanceof String) {
		if (defined(table.tabletitletag, root.components)) {
		    if (defined("text", root.components[table.tabletitletag])) {
			autotitle = trim(root.components[table.tabletitletag].text);
		    }
		}
	    } else if (table.tabletitletag instanceof Array) {
		autotitle = "";
		for (tptr in table.tabletitletag) {
		    if (*tptr instanceof String) {
			if (defined(*tptr, root.components)) {
			    if (defined("text", root.components[*tptr])) {
				autotitle += htmlEncode(trim(root.components[*tptr].text));
				if (tptr@sizeof > 1)
				    autotitle += "<br>\n";
			    }
			}
		    }
		}
	    }
	}

	if ((autotitle == NULL || autotitle@length == 0) && defined("title", root))
	    autotitle = htmlEncode(root.title);

	if (autotitle == NULL || autotitle@length == 0)
	    autotitle = "Table Conversion to HTML";

	columns = table.columns;

	for (n=0, sz=0; n<columns@sizeof; n++) {
	    if (columns[n].visible || include_hidden) {
		types[sz] = columns[n].type;
		html[sz] = columns[n].type == TEXT_TYPE ? (columns[n].attributes != NULL && defined("format",columns[n].attributes) && columns[n].attributes.format =~ "[Hh][Tt][Mm][Ll]") : FALSE;
		alignments[sz] =  (columns[n].alignment == LEFT ? "LEFT" : (columns[n].alignment == RIGHT ? "RIGHT" : "CENTER"));
		halignments[sz] =  (columns[n].altalignment == CENTER ? "CENTER" : (columns[n].altalignment == LEFT ? "LEFT" : "RIGHT"));
		headers[sz] = columns[n].header;
		position[sz] = columns[n].view;
		sz++;
	    }
	}
	qsort(position, CompareNumbers, types, headers, alignments, halignments);

	strdata = table.action(TABLE_JOIN, position, true, true, -1, 0, new Array { "\t", "\n" });

	data = new Array[sz];

	for (n=0; n<sz; n++)
	    data[n] = linesplit(strdata[n]); // OK to discard empty rows

	ln = table.rows;

	*ptr++ = strfmt(@<<
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>%s: %s</title>
    <style type="text/css">
		    body {
			font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
			font-size : 11px; 
			background-color:#FFFFFF;
		    }

		    P, TD {
			font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
			font-size : 11px; 
		    }

		    TH {
			font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
			font-size : 11px; 
			font-weight : bold;
		    }

		    H1 {
			font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
			font-size : 14px;
			font-weight : bold;
		    }

		    H2 {
			font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
			font-size : 12px;
			font-weight : bold;
		    }

		    H1 A { font-size: 14pt; }
		    H2 A { font-size: 12pt; }
		    SMALL { font-size: smaller; }
		    BIG { font-size: larger; }
		    STRONG { font-weight: bold; }
		    EM { font-style: italic; }
		    CODE { font-family: monospace; }
		    NORMAL { font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;
			     font-style: normal; font-weight: normal; }
		    SMALLPRINT { font-size: xx-small; }
		    SUB#opt { font-size: smaller; }
		    SUP#trademark { font-size: small; }
		    SUP#top { font-size: xx-small; }
		    TABLE#page { margin: 24px;
		                 border-collapse: collapse; }
		    TD#page    { border: 1px solid #000000;
				 padding-left: 5px;
				 padding-right: 5px; }
		    TH#page    { border: 1px solid #000000;
				 padding: 5px; }
		    TR#grey    { background-color: #EEEEEE; }
		    TD#box     { border: 1px solid #000000;
				 padding: 5px; }
    </style>
</head>
<body bgcolor="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" >
<center><h1>%s</h1></center>
%s
<table border=0 cellpadding=0 cellspacing=0 id=page>
>>@, 
		htmlEncode(ACRONYM),
		(autotitle@sizeof > 30 ? substring(autotitle, 0, 30)+"..." : autotitle),
		(title == NULL ? (autotitle == NULL ? "" : autotitle) : title),
		(extra == NULL ? "" : extra));

	// ignores header icons currently (just need to do what ICON_TYPE, below, does)
	for (n=0; n<sz; n++) {
	    *ptr++ = strfmt("<th id=page valign=top nowrap align=%s>%s</th>", halignments[n], (strncasecmp(headers[n],"<html>",6) == 0 ? substring(headers[n],6) : htmlEncode(headers[n])));
	}
	*ptr++ = "\n";
	for(m=0; m<ln; m++) {
	    if (m%2)
		*ptr++ = "<tr id=grey>";
	    else *ptr++ = "<tr>";
	    for (n=0; n<sz; n++) {
		if (data[n]@sizeof > m) {
		    switch (types[n]) {
			case ICON_TYPE:
			    // simple test for URL (could do better)
			    tmpstr = htmlEncode(data[n][m]);
			    if (strncasecmp(tmpstr,"http",4) == 0)
				*ptr++ = strfmt("<td id=page valign=top align=%s><img alt='%s' src='%s'></td>", alignments[n], tmpstr, tmpstr);
			    else {
				int row = table.action(GET_ROW_DATA_INDEX, m);
				int col = table.action(GET_COLUMN_DATA_INDEX, position[n]);
				Object img = table.action(GET_FIELD, row, col, "value");
				String jpg = NULL;

				if (img != NULL && img instanceof Image)
				    jpg = encodeImage(img, "jpg");

				if (jpg != NULL) {
				    String fname;
				    File fl;
				    int tries = 0;

				    fname = MakeTempFile(".jpg");

				    while(tries < 3 && (fl = fopen(fname,"w")) == null) {
					fname = MakeTempFile(".jpg");
					tries++;
				    }
				    if(fl == null) {
					fname = null;
					// we tried, give up
					*ptr++ = strfmt("<td id=page valign=top align=%s><img alt='%s' src='%s'></td>", alignments[n], tmpstr, tmpstr);
				    } else {
					fl.nextbuf = jpg;
					fclose(fl);
					*ptr++ = strfmt("<td id=page valign=top align=%s><img alt='%s' src='file://%s'></td>", alignments[n], tmpstr, htmlEncode(fname));
				    }
				} else {
				    // best we can do...
				    *ptr++ = strfmt("<td id=page valign=top align=%s><img src='%s'></td>", alignments[n], tmpstr, tmpstr);
				}
			    }
			    break;
			case DATE_TYPE:
			case OBJECT_TYPE: // maybe not a good idea?
			    *ptr++ = strfmt("<td id=page valign=top align=%s nowrap>%s</td>", alignments[n], htmlEncode(data[n][m]));
			    break;
			case TEXT_TYPE:
			    if (html[n])
				*ptr++ = strfmt("<td id=page valign=top align=%s>%s</td>", alignments[n], data[n][m]);
			    else *ptr++ = strfmt("<td id=page valign=top align=%s>%s</td>", alignments[n], htmlEncode(data[n][m]));
			    break;
			default:
			    *ptr++ = strfmt("<td id=page valign=top align=%s>%s</td>", alignments[n], htmlEncode(data[n][m]));
			    break;
		    }
		} else *ptr++ = "<td id=page></td>";
	    }
	    *ptr++ = "</tr>\n";
	}
	*ptr = @<<
</table>
</body>
</html>
>>@;
	if ((path = ViewFile(strjoin(lines, ""), ".html", FALSE)) != NULL && removepath)
	    unlink(path);
    } else ShowAlert(strfmt("table exceeds limit of %d rows\n", maxrows));
}

GenerateTableCSV(Object table, Object root, String title, String extra, int include_hidden) { // comma-separated values
    Array    lines[3,...];
    Pointer  ptr = lines;
    Array    columns;
    Array    headers[0,...];
    Array    position[0,...];
    Regexp   re = null;
    String   autotitle = NULL;
    int      sz;
    int      ln;
    int      m, n;

    if (defined("tabletitletag", table)) {
	if (table.tabletitletag instanceof String) {
	    if (defined(table.tabletitletag, root.components)) {
		if (defined("text", root.components[table.tabletitletag])) {
		    autotitle = trim(root.components[table.tabletitletag].text);
		}
	    }
	} else if (table.tabletitletag instanceof Array) {
	    autotitle = "";
	    for (tptr in table.tabletitletag) {
		if (*tptr instanceof String) {
		    if (defined(*tptr, root.components)) {
			if (defined("text", root.components[*tptr])) {
			    autotitle += trim(root.components[*tptr].text) + "\n";
			}
		    }
		}
	    }
	    autotitle = trim(autotitle);
	}
    }

    if ((autotitle == NULL || autotitle@length == 0) && defined("title", root))
	autotitle = root.title;

    if (autotitle == NULL || autotitle@length == 0)
	autotitle = "Table Conversion to Comma-Separated Values";

    title = (title == NULL ? autotitle : title) + (extra == NULL ? "" : "\n" + extra);

    if (indexOf(title, '"') >= 0) {
	if (re == null)
	    re = regexp("\"", TEXT_PATTERN);
	title = gsubsti("\"\"", re, title);
    }

    *ptr++ = strfmt("\"\"\"%s\"\n", title);

    columns = table.columns;

    for (n=0, sz=0; n<columns@sizeof; n++) {
	if (columns[n].visible || include_hidden) {
	    if (
		defined("htmlmap", table)
		&& (strncasecmp(columns[n].header, "<html>", 6) == 0)
		&& table.htmlmap instanceof Hashtable
		&& table.htmlmap.contains(columns[n].header)
		) {
		headers[sz] = table.htmlmap.get(columns[n].header);
	    } else headers[sz] = columns[n].header;
	    position[sz] = columns[n].view;
	    sz++;
	}
    }
    qsort(position, CompareNumbers, headers);

    for (n=0; n<sz; n++) {
	if (indexOf(headers[n], '"') >= 0) {
	    if (re == null)
		re = regexp("\"", TEXT_PATTERN);
	    headers[n] = gsubsti("\"\"", re, headers[n]);
	}
	if (n+1 == sz)
	    *ptr++ = strfmt("\"%s\"\n", headers[n]);
	else *ptr++ = strfmt("\"%s\",", headers[n]);
    }

    *ptr++ = table.action(TABLE_JOIN, position, true, true, 0, 0, new Array[] { ",", "\n" });
    
    // if we use ".csv" suffix, then Excel will autoload the data and stubbornly
    // insist that long digit strings must be numbers thereby losing precision
    // beyond 15 digits, using ".xls" keeps the CSV contents in the first column,
    // whereupon the "Text to Columns" wizard can be invoked to load the data
    // as desired (invoked from the Excel menubar as Data->"Text to Columns...")
    ViewFile(strjoin(lines, ""), ".xls", FALSE);
}

GenerateTableTSV(Object table, Object root, String title, String extra, int include_hidden) { // tab-separated values
    Array    lines[3,...];
    Pointer  ptr = lines;
    Array    columns;
    Array    headers[0,...];
    Array    position[0,...];
    Regexp   re = null;
    String   autotitle = NULL;
    int      sz;
    int      ln;
    int      m, n;

    if (defined("tabletitletag", table)) {
	if (table.tabletitletag instanceof String) {
	    if (defined(table.tabletitletag, root.components)) {
		if (defined("text", root.components[table.tabletitletag])) {
		    autotitle = trim(root.components[table.tabletitletag].text);
		}
	    }
	} else if (table.tabletitletag instanceof Array) {
	    autotitle = "";
	    for (tptr in table.tabletitletag) {
		if (*tptr instanceof String) {
		    if (defined(*tptr, root.components)) {
			if (defined("text", root.components[*tptr])) {
			    autotitle += trim(root.components[*tptr].text) + "\n";
			}
		    }
		}
	    }
	    autotitle = trim(autotitle);
	}
    }

    if ((autotitle == NULL || autotitle@length == 0) && defined("title", root))
	autotitle = root.title;

    if (autotitle == NULL || autotitle@length == 0)
	autotitle = "Table Conversion to Tab-Separated Values";

    title = (title == NULL ? autotitle : title) + (extra == NULL ? "" : "\n" + extra);

    if (indexOf(title, '"') >= 0) {
	re = regexp("\"", TEXT_PATTERN);
	title = gsubsti("\"\"", re, title);
    }

    *ptr++ = strfmt("\"%s\"\n", title);

    columns = table.columns;

    for (n=0, sz=0; n<columns@sizeof; n++) {
	if (columns[n].visible || include_hidden) {
	    if (
		defined("htmlmap", table)
		&& (strncasecmp(columns[n].header, "<html>", 6) == 0)
		&& table.htmlmap instanceof Hashtable
		&& table.htmlmap.contains(columns[n].header)
		) {
		headers[sz] = table.htmlmap.get(columns[n].header);
	    } else headers[sz] = columns[n].header;
	    position[sz] = columns[n].view;
	    sz++;
	}
    }
    qsort(position, CompareNumbers, headers);

    for (n=0; n<sz; n++) {
	if (n+1 == sz)
	    *ptr++ = strfmt("%s\n", headers[n]);
	else *ptr++ = strfmt("%s\t", headers[n]);
    }

    *ptr++ = table.action(TABLE_JOIN, position, true, true, 0, 0, new Array[] { "\t", "\n" });
    
    // Note: Excel will autoload the data and stubbornly insist that long digit
    // strings must be numbers thereby losing precision beyond 15 digits. Use
    // GenerateTableCSV if that behavior will present a problem. The advantage to
    // this version is that the data loads automatically and, in most case (i.e.,
    // those without long digit strings like credit card numbers), the autoloading
    // works fine and is easier for the end-user.
    ViewFile(strjoin(lines, ""), ".xls", FALSE);
}

GenerateTableTXT(Object table, Object root, String title, String extra, int include_hidden) {
    Array    lines[3,...];
    Pointer  ptr = lines;
    Array    columns;
    Array    headers[0,...];
    Array    position[0,...];
    Regexp   re = null;
    String   autotitle = NULL;
    int      sz;
    int      ln;
    int      m, n;
    String   NL = getProperty("line.separator");

    if (defined("tabletitletag", table)) {
	if (table.tabletitletag instanceof String) {
	    if (defined(table.tabletitletag, root.components)) {
		if (defined("text", root.components[table.tabletitletag])) {
		    autotitle = trim(root.components[table.tabletitletag].text);
		}
	    }
	} else if (table.tabletitletag instanceof Array) {
	    autotitle = "";
	    for (tptr in table.tabletitletag) {
		if (*tptr instanceof String) {
		    if (defined(*tptr, root.components)) {
			if (defined("text", root.components[*tptr])) {
			    autotitle += trim(root.components[*tptr].text) + NL;
			}
		    }
		}
	    }
	    autotitle = trim(autotitle);
	}
    }

    if ((autotitle == NULL || autotitle@length == 0) && defined("title", root))
	autotitle = root.title;

    if (autotitle == NULL || autotitle@length == 0)
	autotitle = "Table Conversion to Tab-Separated Values";

    title = (title == NULL ? autotitle : title) + (extra == NULL ? "" : NL + extra);

    *ptr++ = strfmt("%s%s", title, NL);

    columns = table.columns;

    for (n=0, sz=0; n<columns@sizeof; n++) {
	if (columns[n].visible || include_hidden) {
	    if (
		defined("htmlmap", table)
		&& (strncasecmp(columns[n].header, "<html>", 6) == 0)
		&& table.htmlmap instanceof Hashtable
		&& table.htmlmap.contains(columns[n].header)
		) {
		headers[sz] = table.htmlmap.get(columns[n].header);
	    } else headers[sz] = columns[n].header;
	    position[sz] = columns[n].view;
	    sz++;
	}
    }
    qsort(position, CompareNumbers, headers);

    for (n=0; n<sz; n++) {
	if (n+1 == sz)
	    *ptr++ = strfmt("%s%s", headers[n], NL);
	else *ptr++ = strfmt("%s\t", headers[n]);
    }

    *ptr++ = table.action(TABLE_JOIN, position, true, true, 0, 0, new Array[] { "\t", NL });
    
    ViewFile(strjoin(lines, ""), ".txt", FALSE);
}

PickTableColumnWidth(String header, ...) {
    double width;

    //
    // Function that can be used to pick widths for JTable columns. The
    // first argument, if it's not NULL, is text that's measured using
    // the header's font. The second argument, if supplied should be a
    // string that's measured in using the column's font. Supplying an
    // int as the second argument means we should meansure an arbitrary
    // string that has that many characters. An optional third argument
    // can also be supplied and is used to adjust the calculated width.
    //

    if (argc > 2) {
	if (argv[2] instanceof String)
	    width = stringWidth(GetPreferredTableFont(), argv[2]);
	else if (argv[2] instanceof Number)
	    width = argv[2]*stringWidth(GetPreferredTableFont(), "W");
	if (argc > 3) {
	    if (argv[3] instanceof String)
		width += stringWidth(GetPreferredTableFont(), argv[3]);
	    else if (argv[3] instanceof Number)
		width += argv[3];
	}
    }
    if (header@sizeof > 0)
	width = max(width, stringWidth(GetPreferredTableHeadingFont(), header + " "));
    return(width + 3.0 * VM.screen.pixelwidth); // pixelwidth addition for cell pad and slop
}

SearchTableFindText(Object table, Object root, String basetag, String str, int forward) {
    String match;
    int    find_pattern;
    int    find_ignorecase;
    int    find_bycols;

    find_bycols = root.components[basetag + "_colwise"].state;

    find_ignorecase = !root.components[basetag + "_case_sensitive"].state;

    if (root.components[basetag + "_re_pattern"].state)
	find_pattern = 1;
    else if (root.components[basetag + "_glob_pattern"].state)
	find_pattern = -1;
    else find_pattern = 0;

    if (str@sizeof > 0) {
	match = table.findNextMatch(str, find_pattern, find_ignorecase, find_bycols, forward);
	root.components[basetag + "_find_text"].foreground = (match != NULL) ? NULL : Color.red;
    }
}

SearchTableReset(Object table, Object root, String basetag) {
    Object   obj;

    table.action(RESET_VIEW);
    table.action(CLEAR_SELECTION);
    table.action(MAKE_CELL_VISIBLE, 0, 0, TRUE);
    if (basetag != NULL && defined(basetag + "_find_text", root.components)) {
	root.components[basetag + "_find_text"].text = "";
	root.components[basetag + "_case_sensitive"].state = 0;
	root.components[basetag + "_re_pattern"].state = 0;
	root.components[basetag + "_glob_pattern"].state = 0;
	root.components[basetag + "_colwise"].state = 0;
    }

    obj = NULL;
    if (GetUseRetainedColumnOrder() && HasRetainedColumnOrder(table))
	obj = GetRetainedColumnOrder(table);
    else if (defined("vieworder", table))
	obj = table.vieworder;
    for (ptr in obj)
	table.action(MOVE_COLUMN, table.modelToView(*ptr, "c"), ptr@offset);

    obj = NULL;
    if (GetUseRetainedColumnWidths() && HasRetainedColumnWidths(table))
	obj = GetRetainedColumnWidths(table);
    else if (defined("viewwidths", table))
	obj = table.viewwidths;
    for (ptr in obj)
	table.action(SET_COLUMN_FIELD, ptr@offset, "width", *ptr);

    obj = NULL;
    if (GetUseRetainedTableSort() && HasRetainedTableSort(table))
	obj = GetRetainedTableSort(table);
    else if (defined("tablesort", table))
	obj = table.tablesort;
    if (obj == NULL)
	table.etc = NULL;
    else table.etc = new Array[obj@sizeof,...] obj;
    if (table.action(GET_ROW_DATA_INDEX, 0) >= 0) // data is loaded
	table.action(TABLE_SORT, obj);

    if (defined("SyncToolTipText", table))
	table.SyncToolTipText();

    if (basetag != NULL && defined(obj = basetag + "_filter", root.components)) {
	if (defined("ResetFilter", table))
	    table.ResetFilter();
	if (defined("SyncSizes", table))
	    table.SyncSizes(table, root.components[obj]);
    }
}

TableDragGestureRecognized(e) {
    Dictionary cell;
    Dictionary dict;
    Rectangle  rowrect;
    Pointer    cptr;
    Object     transferable = NULL;
    String     rowtext = NULL;
    double     ht;
    double     sc;
    Array      rows;
    Array      cols;
    Image      img1;
    Image      img2;
    Image      img3;
    int        ridx;
    int        type;
    int        n;

    //
    // Fancy DragGestureRecognized just for tables. Returns selected rows
    // with all columns or just those specified, optionally, by a non-null
    // dragcolumns value in the JTable. Supplies an image of a table row
    // and a row count (when > 1) for the drag visual.
    //

    if (this instanceof JTable) {
	if (defined("dragcolumns", this)) {
	    if (this.dragcolumns instanceof int) {
		if (this.dragcolumns < 0) {
		    if ((cell = action(FIND_CELL_AT, e.location)) != NULL) {
			if (cell.valuesRow >= 0 && cell.valuesColumn >= 0)
			    cols = new Array[] { cell.valuesColumn };
			else return(e.visual);
		    } else return(e.visual);
		} else cols = new Array[] { this.dragcolumns };
	    } else cols = this.dragcolumns;
	} else cols = NULL;
	rows = this.action(GET_ROW_SELECTION);
	if (rows@length > 0) {
	    Array rdata[rows@length];
	    Array cdata[cols@length];
	    ridx = rows[0].viewRow;
	    if (cols == NULL || cols@length == 0)
		rdata[0] = GetTableRowFromColumn(this, rows[0].valuesRow, this.action(GET_COLUMN_DATA_INDEX, 0), TRUE);
	    else {
		if (cols@length > 1) {
		    cptr = cdata;
		    for (ptr in cols) {
			*cptr++ = this.action(GET_FIELD, rows[0].valuesRow, *ptr);
		    }
		    rdata[0] = strjoin(cdata, this.outputfilter);
		} else rdata[0] = this.action(GET_FIELD, rows[0].valuesRow, cols[0]);
	    }
	    img2 = NULL;
	    if (rows@length > 1) {
		cell = this.action(FIND_CELL_AT, e.location);
		ridx = cell.valuesRow;
		rowrect = this.action(GET_ROW_RECT, ridx, true);
		e.offset = new Point {
		    double x = rowrect.x - e.screenlocation.x;
		    double y = rowrect.y - e.screenlocation.y;
		};
		e.anchor = NONE;
		img1 = captureScreen(rowrect);
		if (cols == NULL || cols@length == 0) {
		    for (n=1; n<rows@length; n++)
			rdata[n] = this.action(GET_ROW, rows[n].valuesRow);
		} else if (cols@length == 1) {
		    for (n=1; n<rows@length; n++)
			rdata[n] = this.action(GET_FIELD, rows[n].valuesRow, cols[0]);
		} else {
		    for (n=1; n<rows@length; n++) {
			cptr = cdata;
			for (ptr in cols)
			    *cptr++ = this.action(GET_FIELD, rows[n].valuesRow, *ptr);
			rdata[n] = strjoin(cdata, this.outputfilter);
		    }
		}
		rowtext = strjoin(rdata, "\n");
		ht = rowrect.height;
		img3 = new Image {
		    int type = TYPE_RGB_ALPHA;
		    String nbr = toString(rows@length);
		    Graphics graphics = {
			String font = "Helvetica-plain-14";
		    };
		    double fwd = 1.4 * stringWidth(graphics.font, nbr);
		    double fht = 1.4 * graphics.font.height;
		    Dimension size = {
			double width = 1 + fwd;
			double height = 1 + fht;
		    };
		    sc = size.height;
		    paint(Rectangle r) {
			graphics.foreground = Color.red;
			fillOval(this, 0, 0, fwd, fht);
			graphics.foreground = Color.white;
			Rectangle bnds = graphics.stringbounds(nbr, TRUE);
			double x = ((fwd - bnds.width + 1) / 2.0);
			double y = ((fht + bnds.height - 1) / 2.0);
			drawString(this, nbr, x, y);
		    }
		};
		img2 = new Image {
		    Image img1 = img1;
		    Image img3 = img3;
		    double ioffx = 9 - e.offset.x;
		    if (ioffx + img3.size.width > img1.size.width)
			ioffx = -9 - img3.size.width - e.offset.x;
		    Dimension size = new Dimension {
			double width = img1.size.width;
			double height = sc;
		    };
		    double off = (sc - img1.size.height) / 2.0;
		    int type = TYPE_RGB_ALPHA;
		    paint(Rectangle r) {
			graphics {
			    gsave();
			    moveto(0,off);
			    showimage(img1, 0.6);
			    moveto(ioffx, 0);
			    showimage(img3);
			    grestore();
			}
		    }
		};
	    } else {
		rowtext = rdata[0];
		rowrect = this.action(GET_ROW_RECT, ridx, true);
		e.offset = new Point {
		    double x = rowrect.x - e.screenlocation.x;
		    double y = rowrect.y - e.screenlocation.y;
		};
		e.anchor = NONE;
		img1 = captureScreen(rowrect);
		img2 = new Image{
		    Image img1 = img1;
		    Dimension size = img1.size;
		    int type = TYPE_RGB_ALPHA;
		    paint(Rectangle r) {
			graphics {
			    gsave();
			    moveto(0,0);
			    showimage(img1, 0.6);
			    grestore();
			}
		    }
		};
	    }
	    e.visual = img2;
	}

	if (defined("TableDragAdjustment", this)) {
	    rowtext = this.TableDragAdjustment(rowtext);
	}
    }

    if (rowtext != NULL) {
	if (defined("CancelMousePressed", this))
	    this.CancelMousePressed();
	if (defined("GetFieldsByTag", this)) {
	    if (GetFieldsByTag instanceof Function) {
		if ((dict = GetFieldsByTag(rows[0].valuesRow)) != NULL) {
		    transferable = new Dictionary {
			"Dictionary", dict,
			"String", rowtext,
		    };
		} else transferable = rowtext;
	    } else transferable = rowtext;
	} else transferable = rowtext;
    }

    if (transferable != NULL)
	this.action(EDIT_STOP);

    return(transferable);
}

TableInitializer(Object table) {
    if (defined("initialized", table) && !table.initialized) {
	table.initialized = TRUE;
	if (defined("basetag", table)) {
	    if (defined(table.basetag+"_search", table.root))
		SearchTableReset(table, table.root, table.basetag);
	    else TableReset(table, table.root);
	}
    }
}

TableLoader(Pointer arg) {
    String suffix;
    String rcf;

    //
    // A function that can be automatically used by PostCommand() to load
    // a JTable whenever it's defined in a JTable. Might be a little hard
    // to follow if you're not familiar with PostCommand(), but the low
    // level details aren't that important. All you should have to do to
    // automatically load a JTable is define this function in your JTable
    // and pass its address as one of the destinations when QueueCommand()
    // or RunCommand() is called and data that the server returns should
    // end up in your table.
    //

    if (this.root != NULL) {
	TableInitializer(this);
	if (arg == NULL)
	    this.values = "";
	else if (arg instanceof String)
	    this.values = arg;
	else this.values = *arg;
	this.action(MAKE_CELL_VISIBLE, 0, 0, TRUE);
	if (defined("rowcountfield", this))
	    rcf = this.rowcountfield;
	else rcf = tag + "_rowcount";
	if (defined(rcf, this.root.components)) {
	    if (defined("TableLoaderLabel", this))
		suffix = this.TableLoaderLabel;
	    else suffix = " rows";
	    this.root.components[rcf].text = (arg@sizeof > 0) ? (toString(this.rows)+suffix) : "";
	}
        //if (this.etc != NULL)
            //this.action(TABLE_SORT, this.etc);
        if (defined("Filter", this)) {
            Object panel = root.components[basetag + "_card"];
            if (panel.visible && panel.cardtag === (basetag + "_filter"))
                this.Filter();
        }
        invocationAction(NULL); // really Global.TableSorter

    }
}

TableReset(Object table, Object root) = SearchTableReset(table, root, NULL);

TableSorter(InvocationEvent e) {
    JTable  table = this;
    int     idx;
    int     len;
    int     off;
    int     i;
    int     j;

    //
    // A generic invocationAction() event handler that can be used
    // by the JTable component. It uses the spare "etc" field in
    // JTable to store sort column info across invocations.
    //
    // Java mishandles cursor changes over table headers, so we do not
    // allow them, thus to provide some visual feedback to user that
    // sort is in progress we also flash the gridcolor -- note: the
    // wait cursor does show up when the cursor is off the header, but
    // it is usually in the header during the sort
    //
    // NOTE - decided to remove the code that changed the gridcolor because
    // right now sorting triggered by pressing a header happens in the event
    // thread and that means the gridcolor change doesn't happen until after
    // the sort finishes!!! All the user sees the table flash when the sort
    // is done, which isn't particularly helpful.
    //
    // NOTE - old code did something like
    //
    //     save table.root.cursor = Cursor.WAIT_CURSOR;
    //
    // which could occasionally made the WAIT_CURSOR the screen's official
    // cursor. It could happen when sorting was triggered when the table
    // was loaded from the server. Just setting the table's cursro should
    // eliminate the occasional problem, but there may be a better place
    // for the fix (e.g., maybe in RunCommand()).
    //
    // NOTE - changing the cursor, on Linux at least, doesn't give the user
    // any visual feedback until the sort finishes when we're called from
    // the event thread, which usually happnes when a header is pressed.
    // There's definitely room for improvement here!!!!
    //

    save table.cursor = Cursor.WAIT_CURSOR;

    if (e != NULL && e.valuesColumn >= 0) {
	if ((e.modifiers&CTRL_MASK) == 0) {
	    table.etc = new Array[0,...] {};
	    len = 0;
	} else {
	    e.modifiers &= ~CTRL_MASK;
	    if (table.etc == NULL)
		table.etc = new Array[0,...] {};
	    len = table.etc@sizeof;
	}

	if (e.modifiers == BUTTON1_MASK) {
	    if (len == 0 && table.action(GET_COLUMN_FIELD, e.valuesColumn, "state") > 0)
		idx = 0;
	    else idx = 1 + e.valuesColumn;
	} else {
	    if (len == 0 && table.action(GET_COLUMN_FIELD, e.valuesColumn, "state") < 0)
		idx = 0;
	    else idx = -(1 + e.valuesColumn);
	}
	for (i=0; i<len; i++) {
	    if (idx == table.etc[i]) {
		for (j=i; j>0; j--)
		    table.etc[j] = table.etc[j-1];
		table.etc[0] = 0;
		idx = 0;
		break;
	    } else if (-idx == table.etc[i]) {
		table.etc[i] = idx;
		idx = 0;
		break;
	    }
	}
	for (off=0; off<len; off++) {
	    if (table.etc[off] != 0)
		break;
	}
	if (idx != 0) {
	    table.etc[len] = idx;
	    len++;
	}
    } else if ((len = table.etc@sizeof) > 0) {
	for (off=0; off<len; off++) {
	    if (table.etc[off] != 0)
		break;
	}
    }

    if (len == off) {
	table.action(TABLE_SORT, NULL);
	table.etc = new Array[0,...] {};
    } else table.action(TABLE_SORT, table.etc + off);

    if (e != NULL && (len - off) < 2)
	table.action(MAKE_CELL_VISIBLE, 0, e.viewColumn, TRUE);
	    

    if (defined("dfltcellcolors", table)) {
	if (len == off) {
	    table.cellcolors = table.dfltcellcolors;
	} else {
	    Array  values;
	    Array  cols;
	    Array  etc;

	    cols = new Array[len-off];
	    etc = (table.etc + off);
	    //
	    // Need to convert columns to the view model because
	    // that's what the TABLE_JOIN operation (below) will
	    // expect.
	    //
	    for (i = 0; i < cols@length; i++) {
		cols[i] = table.action(GET_COLUMN_VIEW_INDEX, abs(etc[i]) - 1);
	    }
	    table.cellcolors = getArrayBands(
		table.action(TABLE_JOIN, cols, TRUE, TRUE, 1),
		unroll(table.dfltcellcolors)
		);
	}
    }
}

//
// Functions that can be used to view a file or URL in a separate program,
// like a browser.
//

ViewFile(String text, String extension, int plaintext) {
    Array   exec_viewer;
    Process proc;
    String  viewer;
    String  fname = NULL;
    String  directory;
    String  basename;
    String  realpath;
    String  cmd;
    File    fl;
    int     tries = 0;
    int     pexit;
    int     idx;

    if ((viewer = GetPreferredViewer()) != NULL) {
	fname = MakeTempFile(extension);
	while (tries < 3 && (fl = fopen(fname,"w")) == NULL) {
	    fname = MakeTempFile(extension);
	    tries++;
	}
	if (fl == NULL) {
	    ShowAlert("Could not create a needed temporary file (" + fname + ")");
	    fname = NULL;
	} else {
	    if (plaintext)
		fl.nextbuf = "<PLAINTEXT>";
	    fl.nextbuf = text;
	    fclose(fl);
	}

	realpath = realPath(fname);

	if (!ISUNIX && (idx = lastIndexOf(realpath, "/")) > 0) {
	    directory = substring(realpath, 0, idx);
	    basename = substring(realpath, idx+1);
	} else {
	    directory = NULL;
	    basename = realpath;
	}
	cmd = strfmt(viewer, basename);

	proc = exec(cmd, NULL, directory);
	if (proc != NULL) {
	    String errbuf = proc.error.nextbuf;
	    if (errbuf != NULL)
		trim(errbuf);
	    if (errbuf@length > 0) {
		//
		// Recent addition to try to reduce complaints on Unix since
		// we're going to try again below and there's another chance
		// to issue an error message.
		// 
		if (!(ISUNIX && proc.exitvalue)) {
		    if (proc.alive == 0)
			errbuf = strfmt("[exit=%d] %s", proc.exitvalue, errbuf);
		    ShowError(errbuf, "View URL Error");
		}
	    }
	    try {
		waitFor(proc);
		pexit = proc.exitvalue;
		if (ISUNIX && pexit) {
		    idx = indexOf(viewer,' ');
		    if (idx < 0) // unlikely
			exec_viewer = new Array[] { viewer, basename };
		    else exec_viewer = new Array[] { substring(viewer,0,idx), basename };
		    proc = exec(exec_viewer, NULL, directory);
		    if (proc == NULL || (proc.alive == 0 && proc.exitvalue !=0))
			ShowAlert("Browser must already be running for viewer to function."); // give up
		    else {
			proc.persistent = TRUE;	// allow to live after the application exits
			pexit = 0;
		    }
		}
	    }
	    catch(e) {
		ShowWarning(e.message, "View File Exception");
		pexit = 1;
		return(TRUE);
	    }
	} else pexit = -1;
	if (pexit) {
	    if (ShowConfirm("Could not start viewer. Do you want to save the material to a file?").confirmed) {
		Array   filtarr = NULL;
		if (extension@length > 0) {
		    filtarr = new Array {
			extension + " files", new Regexp {
			    String pattern = "*" + extension;
			    int type = yoix.re.SHELL_PATTERN;
			    int toyoixpath = TRUE;
			},
			NULL, NULL,
		    };
		}
		JFileDialog jfd = {
		    String directory = getProperty("user.home");
		    int    mode = SAVE;
		    Array  filters = filtarr;
		};
		jfd.visible = TRUE;
		if (jfd.file != NULL) {
		    realpath = jfd.file;
		    if ((fl = fopen(realpath,"w")) == NULL) {
			ShowAlert(strfmt("Could not open '%s' for writing", realpath));
		    } else {
			fl.nextbuf = text;
			fclose(fl);
		    }
		}
	    }
	}
    } else ShowAlert("Viewer command is not specified under general preferences.");

    return(fname);
}

ViewURL(String url) {
    Array   exec_viewer;
    File    fl;
    Process proc;
    String  content;
    String  realpath;
    String  type;
    String  viewer;
    URL     stream;
    int     result = FALSE;
    int     pexit;
    int     idx;

    if (HaveAppleExtension()) {
	appleOpenURL(url);
	result = TRUE;
    } else if ((viewer = GetPreferredViewer()) != NULL) {
	proc = exec(strfmt(viewer, url));
	if (proc != NULL) {
	    String errbuf = proc.error.nextbuf;
	    if (errbuf != NULL)
		trim(errbuf);
	    if (errbuf@length > 0) {
		//
		// Recent addition to try to reduce complaints on Unix since
		// we're going to try again below and there's another chance
		// to issue an error message.
		// 
		if (!(ISUNIX && proc.exitvalue)) {
		    if (proc.alive == 0)
			errbuf = strfmt("[exit=%d] %s", proc.exitvalue, errbuf);
		    ShowError(errbuf, "View URL Error");
		}
	    }
	    try {
		waitFor(proc);
		pexit = proc.exitvalue;
		if (ISUNIX && pexit) {
		    idx = indexOf(viewer,' ');
		    if (idx < 0) // unlikely
			exec_viewer = new Array[] { viewer, url };
		    else exec_viewer = new Array[] { substring(viewer,0,idx), url };
		    proc = exec(exec_viewer);
		    if (proc == NULL || (proc.alive == 0 && proc.exitvalue != 0))
			ShowAlert("Browser must already be running for viewer to function."); // give up
		    else {
			proc.persistent = TRUE; // allow to live after the application exits
			pexit = 0;
		    }
		}
	    }
	    catch(e) {
		ShowWarning(e.message, "View URL Exception");
		pexit = 1;
		return(TRUE);
	    }
	} else pexit = -1;
	if (pexit) {
	    if ((stream = open(url, "r")) != NULL) {
		content = readStream(stream);
		if (defined("content-type", stream.headerfield))
		    type = " (Content-Type: " + stream.headerfield["content-type"] + ")";
		else type = NULL;
		close(stream);
	    } else content = NULL;
	    if (content == NULL) {
		ShowAlert(strfmt("Could not access requested content (URL: %s).", url));
	    } else if (ShowConfirm(strfmt("Could not start viewer. Do you want to save the material%s to a file?", (type == NULL ? "" : type))).confirmed) {
		JFileDialog jfd = {
		    String directory = getProperty("user.home");
		    int    mode = SAVE;
		};
		jfd.visible = TRUE;
		if (jfd.file != NULL) {
		    realpath = jfd.file;
		    if ((fl = fopen(realpath,"w")) == NULL) {
			ShowAlert(strfmt("Could not open '%s' for writing", realpath));
		    } else {
			fl.nextbuf = content;
			fclose(fl);
		    }
		}
	    }
	} else result = TRUE;
    } else ShowAlert("Viewer command is not specified under general preferences.");

    return(result);
}

//
// Functions to load optional files
//

LoadByzgraf() {
    //
    // May be overkill to synchronize, but we want to avoid two loads...
    // we pick acronym as the lock just because it is sure to be around
    //
    synchronized(acronym) {
	if (!defined("BYZGRAF_LINEPLOT")) {
	    global {
		include ServerFile(BetaPrefix + acronym + "_byzgraf.yx");
	    }
	}
    }
}

//
// Simple memory management functions that sometimes help with debugging.
//

CollectGarbage() {
    gc();
    runFinalization();
    yoix.thread.sleep(.2);
    gc();
    runFinalization();
}

MemoryUsage(Pointer lasttotal) {
    double percent;
    int    available;
    int    free;
    int    total;
    int    expanded;

    free = freeMemory();
    total = totalMemory();
    available = total - free;
    percent = (100.0*available)/total;

    if (lasttotal != NULL) {
	expanded = (*lasttotal > 0) ? total - *lasttotal : 0;
	*lasttotal = total;
    } else expanded = 0;

    return(expanded != 0
	? strfmt("Memory used=%.1f%% [%d/%d] total changed by %d bytes", percent, available, total, expanded)
	: strfmt("Memory used=%.1f%% [%d/%d]", percent, available, total)
    );
}

if (HaveAppleExtension()) {

    AboutHandler(ev) {
	ev.handled = true;
	ShowVersion(MainScreen);
    }

    QuitHandler(ev) {
	ev.handled = true;
	if (ShowConfirm(MainScreen, "You are about to exit " + ACRONYM + ". Are you sure you want to continue?", ACRONYM + ": Quit Check").confirmed) {
	    Quit(0);
	}
    }

    appleApplication("about", AboutHandler);
    appleApplication("quit", QuitHandler);
}

