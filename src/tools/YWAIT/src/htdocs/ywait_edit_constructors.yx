//
// Functions that create objects that are used when we build screens that
// support editing.
//

////////////////////////////
//
// Edit Stack
//
////////////////////////////

NewEditStack(String key, int row, Object editor) {
    //
    // A constructor that builds a dictionary that manages information about
    // changes that have been applied by the "edit components" contained in
    // an "edit screen". The stack array manages the individual dictionaries
    // that store the state of the "edit components" in an "edit container"
    // and it's used to support undo and redo operations. We now guarantee
    // that every state saved in stack is growable, so fields can be added
    // to the states whenever we think it's appropriate.
    //

    Dictionary stack = {
	Dictionary startstate = NULL;
	String     key = key;
	Object     editor = editor;
	Array      stack[0, ...];
	int        top = -1;
	int        limit = -1;
	int        lowerlimit = -1;
	int        lastsave = -1;
	int        row = row;
	int        enabled = FALSE;
	int        newedit = (row < 0);
	int        edited;
	int        ready = (row >= 0 || key != NULL);

	AtSavedState() {
	    return(top == lastsave);
	}

	CanRedo() {
	    return(top < limit);
	}

	CanUndo() {
	    return(top > 0);
	}

	CollectStates(int start, int stop) {
	    Array states;
	    int   count;
	    int   incr;
	    int   index;
	    int   n;

	    //
	    // Right now this is only needed when the editor includes table
	    // edit components, because the state that's recorded here for
	    // table edit components for the most part only reflect changes
	    // that were made to individual cells. Operations, like Undo or
	    // any that do more than increment or decrement the stack top,
	    // are harder than you might expect.
	    //
	    // NOTE - limited bounds checking here because this function is
	    // really only designed to be called from Undo() and Redo(), so
	    // start and stop values are assumed to be valid entries in the
	    // stack[] even though they may not lie in the interval that's
	    // usually considered valid.
	    //

	    if (editor != NULL && editor.edit_need_states) {
		if (start >= 0 && stop >= 0) {
		    if (start <= stop) {
			count = stop - start + 1;
			incr = 1;
		    } else {
			count = start - stop + 1;
			incr = -1;
		    }
		    states = new Array[count];
		    for (n = 0; n < count; n++) {
			states[n] = stack[start];
			start += incr;
		    }
		}
	    }
	    return(states);
	}

	GetExtra(String key) {
	    Dictionary state;
	    Object     value;

	    if ((state = Peek()) != NULL) {
		if (defined("extra", state)) {
		    if (defined(key, state.extra))
			value = state.extra[key];
		}
	    }
	    return(value);
	}

	IsComponentModified(Object comp) {
	    Dictionary current;
	    Dictionary start;
	    String     name;
	    int        result = FALSE;

	    if (comp instanceof String)
		name = comp;
	    else if (defined("tag", comp) && comp.tag instanceof String)
		name = comp.tag;

	    if ((start = startstate) != NULL) {
		if ((current = Peek()) != NULL) {
		    if (defined(name, current) && defined(name, start)) {
			if (current[name] !== start[name])
			    result = TRUE;
		    }
		}
	    }
	    return(result);
	}

	IsDeleted() {
	    Dictionary current;

	    return((current = Peek()) != NULL ? current.deleted : FALSE);
	}

	IsEdited() {
	    return(edited);
	}

	IsEditing() {
	    return(ready || edited);
	}

	IsEnabled() {
	    return(enabled);
	}

	IsModified() {
	    Dictionary current;
	    int        result = FALSE;

	    //
	    // Older version set modified in Push() and LoadStates(), but
	    // right now the answer for at least one edit component, namely
	    // the JTable edit component, usually can't be determined from
	    // from the current state. As a result Push() and LoadStates()
	    // now set modified to a negative value which lets us determine
	    // when it still needs to be initialized.
	    //

	    if ((current = Peek()) != NULL) {
		if (current.modified < 0)	// negative means it's not set yet
		    current.modified = editor.IsStateModified(current) ? TRUE : FALSE;
		result = current.modified;
	    }
	    return(result);
	}

	IsNewEdit() {
	    return(newedit);
	}

	IsSavable() {
	    return(IsValid() && IsModified() && !(IsNewEdit() && IsDeleted()));
	}

	IsValid() {
	    Dictionary current;

	    return((current = Peek()) != NULL ? current.valid : FALSE);
	}

	LoadStates(Array states) {
	    Dictionary state;

	    //
	    // NOTE - trying to load initial states using Push() is trickier
	    // than you might expect because more than one initial state isn't
	    // unusual.
	    //

	    stack = new Array[0, ...] {unroll(states)};
	    top = states@sizeof - 1;
	    limit = top;
	    lowerlimit = top;
	    lastsave = top;
	    startstate = stack[top];
	    edited = FALSE;

	    for (ptr in stack) {
		if ((state = ptr[0]) != NULL) {
		    if (!state@growable) {
			state = new Dictionary[0, ...] state;
			ptr[0] = state;
		    }
		    state.modified = -1;	// postponed until really needed
		}
	    }
	}

	NotEditing() {
	    return(!IsEditing());
	}

	Peek() {
	    return(top >= 0 ? stack[top] : NULL);
	}

	PeekAt(int index) {
	    Dictionary state;

	    if (top >= 0) {
		if (index >= 0) {
		    if (index <= top)
			state = stack[top - index];
		} else {
		    if (top - index <= limit)
			state = stack[top - index];
		}
	    }
	    return(state);
	}

	PeekAtBottom() {
	    //
	    // This should always return the editor's original state, even
	    // when a series of changes are buffered in an object (usually
	    // a JTable).
	    //

	    return(stack[0]);
	}

	PeekAtStartState() {
	    return(startstate);
	}

	Push(Dictionary state) {
	    String name;

	    if (state != NULL) {
		state = state@growable ? state : new Dictionary[0, ...] state;
		if (top >= 0 && top < lowerlimit)
		    lowerlimit = top;
		stack[++top] = state;
		limit = (top > lowerlimit) ? top : lowerlimit;
		if (limit < lastsave)
		    lastsave = -1;
		state.row = row;
		state.modified = -1;		// postponed until really needed
		edited = TRUE;
	    }
	}

	Redo(int modifiers) {
	    int start;

	    if ((start = top) < limit) {
		if (modifiers & SHIFT_MASK) {
		    if (modifiers & CTRL_MASK) {
			if (top < lowerlimit)
			    top = lowerlimit;
			else top = limit;
		    } else top = limit;
		} else top++;
		edited = TRUE;
	    }
	    return(CollectStates(start, top));
	}

	SetEnabled(int value) {
	    enabled = value;
	}

	SetExtra(String key, Object value) {
	    Dictionary state;

	    if ((state = Peek()) != NULL) {
		if (defined("extra", state))
		    state.extra = new Dictionary[0, ...] state.extra;
		else state.extra = new Dictionary[0, ...];
		state.extra[key] = value;
	    }
	}

	SyncSavedState() {
	    lastsave = top;
	}

	Undo(int modifiers) {
	    int start;

	    if ((start = top) > 0) {
		if (modifiers & SHIFT_MASK) {
		    if (modifiers & CTRL_MASK) {
			if (top > lowerlimit)
			    top = lowerlimit;
			else top = 0;
		    } else top = 0;
		} else top--;
		edited = TRUE;
	    }
	    return(CollectStates(start, top));
	}

	//
	// Simple dump - just for debugging.
	//

	Dump() {
	    int n;

	    fprintf(stderr, "row=%d, top=%d, limit=%d, lowerlimit=%d, newedit=%d, editor=%s\n", row, top, limit, lowerlimit, newedit, editor ? editor.tag : "NULL");
	    for (n = 0; n < stack@sizeof; n++)
		fprintf(stderr, "stack[%d]=%O\n", n, defined(stack[n]) ? stack[n] : "--- undefined ---");
	}
    };

    return(stack);
}

////////////////////////////
//
// Edit Stack Controls
//
////////////////////////////

NewJButtonEditStackControl(String tag, String text, ...) {
    Dictionary initializer;

    //
    // A constructor that builds a JButton used for "edit stack" operations
    // like undo, redo, save and cancel. Buttons start out disabled, which
    // assumes their states are properly sync'd by their editor.
    //

    initializer = new Dictionary {
	String command = toUpperCase(text);
	Object editor = NULL;
	int    enabled = FALSE;
	int    is_edit_button = TRUE;

	actionPerformed(e) {
	    switch (e.command) {
		case "CANCEL":
		    editor.CancelEdit();
		    if (editor.edit_standalone)
			editor.StartEdit(NULL);
		    if (defined("AfterCancel", root))
			root.AfterCancel(editor);
		    else editor.SetFocusToFirst();
		    break;

		case "REDO":
		    editor.RedoEdit(e.modifiers);
		    break;

		case "SAVE":
		    editor.SaveEdit();
		    if (editor.edit_standalone)
			editor.StartEdit(NULL);
		    if (defined("AfterSave", root))
			root.AfterSave(editor);
		    else editor.SetFocusToFirst();
		    break;

		case "UNDO":
		    editor.UndoEdit(e.modifiers);
		    break;
	    }
	}
    };

    return(NewJButtonWithSmallInsets(tag, text, initializer, unroll(&text+1)));
}

NewJPanelEditStackControls(String basetag, int showsave, int showstatus, ...) {
    Dictionary initializer;
    Object     ptr;

    //
    // A constructor that builds a JPanel that's used to control an edit
    // stack.
    //

    initializer = new Dictionary[0, ...] {
	GridBagLayout layoutmanager;
	Array layout = {
	    NewJLabel(basetag + "_status_label", NULL, "showstatus", showstatus),
	    new Dictionary {
		int gridx = 1;
		int gridy = 1;
		int weightx = 1;
	    },

	    NewJPanelEditStackUndoControls(basetag),
	    LEFT, NONE,

	    NewJPanelEditStackSaveControls(basetag, "visible", showsave),
	    RIGHT, NONE,
	};
    };

    for (ptr = &showstatus + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }
    return(new JPanel initializer);
}

NewJPanelEditStackSaveControls(String basetag, ...) {
    Dictionary initializer;
    Object     ptr;
    Object     tmp;

    initializer = new Dictionary[0, ...] {
	GridBagLayout layoutmanager = {
	    double hgap = 72.0/32;
	};
	Array layout = {
	    NewJButtonEditStackControl(basetag + "_save_button", "Save", "requestfocusenabled", FALSE),
	    NONE,
	    NewJButtonEditStackControl(basetag + "_cancel_button", "Cancel", "requestfocusenabled", FALSE),
	    NONE,
	};
    };

    for (ptr = &basetag + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    if (defined("flipped", initializer) && initializer.flipped) {
	tmp = initializer.layout[0];
	initializer.layout[0] =  initializer.layout[2];
	initializer.layout[2] = tmp;
    }

    return(new JPanel initializer);
}

NewJPanelEditStackUndoControls(String basetag, ...) {
    Dictionary initializer;
    Object     ptr;
    Object     tmp;

    initializer = new Dictionary[0, ...] {
	GridBagLayout layoutmanager = {
	    double hgap = 72.0/32;
	};
	Array layout = {
	    NewJButtonEditStackControl(basetag + "_redo_button", "Redo", "focusable", FALSE),
	    NONE,
	    NewJButtonEditStackControl(basetag + "_undo_button", "Undo", "focusable", FALSE),
	    NONE,
	};
    };

    for (ptr = &basetag + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    if (defined("flipped", initializer) && initializer.flipped) {
	tmp = initializer.layout[0];
	initializer.layout[0] =  initializer.layout[2];
	initializer.layout[2] = tmp;
    }

    if (defined("buttoninsets", initializer)) {
	initializer.layout[0].insets = initializer.buttoninsets;
	initializer.layout[2].insets = initializer.buttoninsets;
    }

    return(new JPanel initializer);
}

////////////////////////////
//
// Edit Table Controls
//
////////////////////////////

NewJPanelEditTableControls(String basetag, ...) {
    Dictionary initializer;
    Object     ptr;

    initializer = new Dictionary[0, ...] {
	String tag = basetag + "_controls_panel";
	int    confirm_delete = TRUE;

	GridBagLayout layoutmanager = {
	    double hgap = 72.0/32;
	};
	Array layout = {
	    NewJButtonWithSmallInsets(basetag + "_add_button", "Add", new Dictionary {
		String tabletag = basetag;
		int    focusable = FALSE;
		int    requestfocusenabled = FALSE;

		actionPerformed(e) {
		    root.components[tabletag].HandleAppendRow(NULL);
		}
	    }),
	    NONE,
	    NewJButtonWithSmallInsets(basetag + "_delete_button", "Delete", new Dictionary {
		String tabletag = basetag;
		String paneltag = basetag + "_controls_panel";
		int    focusable = FALSE;
		int    requestfocusenabled = FALSE;

		actionPerformed(e) {
		    root.components[tabletag].HandleDeleteSelectedRow(root.components[paneltag].confirm_delete);
		}
	    }),
	    NONE,
	};
    };

    for (ptr = &basetag + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }
    return(new JPanel initializer);
}


////////////////////////////
//
// Edit Selection Button
//
////////////////////////////

NewEditSelectorButton(String tag, String selector_builder, Object selector_args, Object owner, ...) {
    Dictionary initializer;
    JButton    button;
    Insets     insets = NULL;
    int        is_edit_selector_button = TRUE;

    initializer = new Dictionary {
	String selector_builder = selector_builder;
	Object selector_args = selector_args;
	Object owner = owner;
	Insets insets = GetPreferredSelectorButtonInsets();
	Object anchorpoint = NULL;
	int    screenanchor = CENTER;
	int    requestfocusenabled = FALSE;

	actionPerformed(e) {
	    if (isComponent(owner) && owner.visible) {
		if (defined("editor", owner) && isComponent(owner.editor) && owner.editor.visible)
		    anchorpoint = owner.editor;
		else anchorpoint = owner;
		screenanchor = SOUTH;
	    }
	    ShowEditSelector(
		root,
		selector_builder,
		selector_args,
		owner,
		"anchorpoint", anchorpoint,
		"screenanchor", screenanchor
	    );
	}
    };

    return(NewJButton(tag, "...", initializer));
}

////////////////////////////
//
// Edit Screens
//
////////////////////////////

NewJDialogEditScreen(String name, int modal, ...) {
    Dictionary initializer[0, ...] = EDITSCREEN_TEMPLATE;
    Object     ptr;

    //
    // This version automatically builds an "edit manager" panel and makes
    // sure it's the only object in the frame's layout array, which means
    // the caller doesn't have to know anything about "edit managers".
    // 

    initializer.modal = modal;

    for (ptr = &name + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    initializer.layout = new Array {
	new JPanel {
	    unroll(EDITMANAGER_TEMPLATE),
	    "layout", defined("layout", initializer) ? initializer.layout : NULL,
	    "layoutmanager", defined("layoutmanager", initializer) ? initializer.layoutmanager : new BorderLayout,
	}
    };
    initializer.layoutmanager = new BorderLayout;

    return(new JDialog initializer);
}

NewJFrameEditScreen(String name, ...) {
    Dictionary initializer[0, ...] = EDITSCREEN_TEMPLATE;
    Object     ptr;

    //
    // This version automatically builds an "edit manager" panel and makes
    // sure it's the only object in the frame's layout array, which means
    // the caller doesn't have to know anything about "edit managers".
    // 

    for (ptr = &name + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    initializer.layout = new Array {
	new JPanel {
	    unroll(EDITMANAGER_TEMPLATE),
	    "layout", defined("layout", initializer) ? initializer.layout : NULL,
	    "layoutmanager", defined("layoutmanager", initializer) ? initializer.layoutmanager : new BorderLayout,
	}
    };
    initializer.layoutmanager = new BorderLayout;

    return(new JFrame initializer);
}

////////////////////////////
//
// Edit Buffers
//
////////////////////////////

NewJTableEditBuffer(String basetag, Object inputfilter, int scroll, Object dragcolumns, ...) {
    Dictionary initializer[0, ...] = JTABLE_EDITBUFFER_TEMPLATE;
    Object     ptr;

    //
    // A constructor for a JTable that's used to manage "editable rows" of
    // data. Fields in a row are loaded into edit components when the user
    // clicks on a row and changes made in the edit components can be saved
    // back in the table. No permanent changes are made until the edits are
    // collected and sent back to the server.
    //

    for (ptr = &dragcolumns + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    return(NewJTable(basetag, inputfilter, scroll, dragcolumns, initializer));
}

NewJTableWithSearchEditBuffer(String basetag, Object inputfilter, int scroll, Object dragcolumns, ...) {
    Dictionary initializer[0, ...] = JTABLE_EDITBUFFER_TEMPLATE;
    Object     ptr;

    //
    // A constructor for a JTable that's used to manage "editable rows" of
    // data. Fields in a row are loaded into edit components when the user
    // clicks on a row and changes made in the edit components can be saved
    // back in the table. No permanent changes are made until the edits are
    // collected and sent back to the server.
    //

    for (ptr = &dragcolumns + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    return(NewJTableWithSearch(basetag, inputfilter, scroll, dragcolumns, initializer));
}

////////////////////////////
//
// Editors
//
////////////////////////////

NewJPanelEditor(String tag, ...) {
    Dictionary initializer;
    Object     ptr;

    initializer = new Dictionary[0, ...] {
	String tag = tag;
    };

    unroll(EDITOR_TEMPLATE, initializer);

    for (ptr = &tag + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    return(new JPanel initializer);
}

NewJSplitPaneEditor(String tag, ...) {
    Dictionary initializer;
    Object     ptr;

    initializer = new Dictionary[0, ...] {
	String tag = tag;
	double border = 0.0;
	int    orientation = VERTICAL;
	int    onetouchexpandable = TRUE;
	int    resizeweight = 1;
    };

    unroll(EDITOR_TEMPLATE, initializer);

    for (ptr = &tag + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    return(new JSplitPane initializer);
}

////////////////////////////
//
// Edit Components
//
////////////////////////////

NewJButtonPanelEditComponent(String tag, String title, Array items, Object selected, int type, int orientation, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     subpanel;
    Object     ptr;
    Object     separator;
    Object     button;
    Array      buttons;
    Array      editor_layout;
    Array      layout;

    //
    // A collection of buttons that behave something like a JList. Order of
    // the corresponding arguments don't dumpicate NewJListEditComponent() or
    // NewJListEditComponent(), mostly because we decided to follow the items
    // array with selected. Probably can't change NewJList() constructor and
    // in that case it seems reasonable to have NewJListEditComponent() use
    // the NewJList() order. The constructors
    //
    //     NewJCheckBoxPanelEditComponent()
    //
    // and
    //
    //     NewJRadioButtonPanelEditComponent()
    //
    // defined later in this file let you omit the type argument that has to
    // be supplied when you call this function directly.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[9, ...] {
	String tag = tag;
	Object group = NULL;
	Array  buttons;
	int    syncbuttonlabels = FALSE;

	//
	// Suspect these won't be needed...
	//

	Object selected = selected;
	Array  items = items;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JPanel that manages a collection of JButtons that's going to
	// be used as an "edit component". Behaves something like a JList, so
	// may notice the similiarity with a JList edit component.
	//
	// NOTE - is_edit_component_enabled was added to all edit components
	// so scripts can control whether an edit component is enabled or not.
	// Needed because the DisableEditor() and EnableEditor() funtions in
	// editors assume they can change an edit component's enabled state
	// whenever they want. Scripts should use the SetEnabled() function
	// that's now defined in all edit components whenever they want to
	// change the enabled state.
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	Object lastfocuscomponent = NULL;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	actionPerformed(e) {
	    if (editor != NULL)
		invokeLater(&editor.AfterEdit, tag);
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    for (ptr in buttons)
		ptr[0].state = FALSE;
	    SyncState();
	}

	CollectData() {
	    return(CollectEdits());
	}

	CollectEdits() {
	    String value = GetValue();
	    Object edits;

	    //
	    // Really should be able to do
	    //
	    //     return(strsplit(value, ","));
	    //
	    // but wanted to make absolutely sure NULL is returned, even if
	    // GetValue() happened to return "" (which it currently won't).
	    //
	    // NOTE - what's done here should be controlled by some variable
	    // that we use to decide whether to return an array or string.
	    //
	    // NOTE - should we check IsEditComponentEnabled() here and just
	    // return NULL if it's not enabled?
	    //

	    if (value@sizeof > 0)
		edits = strsplit(value, ",");
	    return(edits);
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetSelected() {
	    Array selected[0, ...];

	    for (ptr in buttons) {
		if (ptr[0].state)
		    selected[selected@sizeof] = ptr[0].command;
	    }
	    return(selected@sizeof ? selected : NULL);
	}

	GetValue() {
	    String value;
	    String sep;

	    SyncState();
	    for (ptr in buttons) {
		if (ptr[0].state) {
		    value += sep + ptr[0].command;
		    sep = ",";
		}
	    }
	    return(defined("Format", this) ? Format(value) : value);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    int empty = TRUE;

	    for (ptr in buttons) {
		if (ptr[0].state) {
		    empty = FALSE;
		    break;
		}
	    }
	    return(empty);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else valid = FALSE;
		    } else valid = FALSE;
		} else valid = (!IsEmpty() || !required);
	    } else valid = TRUE;
	    return(valid);
	}

	LoadData(Object data) {
	    if (data instanceof String || data instanceof Array || data == NULL) {
		if (data instanceof Array)
		    data = strjoin(data, ",");
		SetValue(data);
	    }
	}

	MapValueToDisplayed(String value) {
	    String displayed = "";
	    Array  values;
	    int    index;

	    if (value != NULL) {
		values = strsplit(value, ",");
		for (ptr in values) {
		    if ((index = indexOfObject(items, ptr[0])) >= 0) {
			if (displayed@sizeof)
			    displayed += ", ";
			displayed += items[2*(index/2)];
		    }
		}
	    }
	    return(displayed);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	    for (ptr in buttons)
		ptr[0].enabled = state;
	}

	SetValue(String value, ...) {
	    SetSelected(strsplit(value, ","));
	    SyncState();
	    if (defined("AfterSetValue", this)) {
		AfterSetValue();
		if (editor != NULL)
		    editor.SyncEditor();
	    }
	}

	SetSelected(Array selected) {
	    int state;

	    lastfocuscomponent = NULL;

	    if (group == NULL) {
		for (ptr in buttons) {
		    state = (indexOfObject(selected, ptr[0].command) >= 0 || indexOfObject(selected, ptr[0].text) >= 0);
		    if (state != ptr[0].state) {
			ptr[0].state = state;
			lastfocuscomponent = ptr[0];
		    }
		}
	    } else {
		if (selected@sizeof > 0) {
		    group.selected = selected[selected@sizeof - 1];
		    lastfocuscomponent = group.selected;
		} else {
		    lastfocuscomponent = group.selected;
		    group.selected = NULL;
		}
	    }
	}

	SyncFocus() {
	    Object comp;

	    if ((comp = lastfocuscomponent) != NULL) {
		if (defined("requestfocus", comp))	// just in case
		    comp.requestfocus = TRUE;
		else lastfocuscomponent = NULL;
	    }
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;
	    Object color;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();

	    if (syncbuttonlabels) {
		color = IsValid() ? NULL : PickInvalidForeground();
		for (ptr in buttons)
		    ptr[0].foreground = color;
	    }
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JPanel initializer;

    //
    // Build all the buttons and add them and appropriate constraints to the
    // layout array.
    //

    editor_layout = new Array[0, ...];
    buttons = new Array[0, ...];
    layout = editor_layout;
    subpanel = NULL;

    for (ptr in items by 2) {
	if (ptr[0] != NULL) {
	    button = NewJButton(NULL, NULL, new Dictionary {
		String text = ptr[0];
		String command = ptr[1];
		Object group = editor.group;
		Object owner =  editor;
		int    type = type;
		int    state = selected instanceof String ? (selected === ptr[1]) : (indexOfObject(selected, ptr[1]) >= 0);

		actionPerformed(e) {
		    owner.actionPerformed(e);
		}

		itemStateChanged(e) {
		    //
		    // This is supposed to maintain "group" behavior when there's
		    // no group assigned to a collection of radio buttons, but it
		    // also lets the user deselect all buttons in the "group". You
		    // can always override the behavior by including a ButtonGroup
		    // in the constructor call.
		    // 
		    if (e.state) {
			if (group == NULL && type == RADIO_BUTTON) {
			    for (ptr in owner.buttons) {
				if (ptr[0] != this) {
				    if (ptr[0].state)
					ptr[0].state = FALSE;
				}
			    }
			}
		    }
		}
	    });
	    layout[layout@sizeof] = button;
	    layout[layout@sizeof] = LEFT;
	    layout[layout@sizeof] = NONE;
	    buttons[buttons@sizeof] = button;
	} else {
	    if (ptr[1] instanceof String) {
		if (subpanel != NULL) {
		    subpanel.layout = layout;
		    layout = editor_layout;
		    layout[layout@sizeof] = subpanel;
		    layout[layout@sizeof] = LEFT;
		    layout[layout@sizeof] = NONE;
		    subpanel = NULL;
		}
		if (ptr[1]@sizeof > 0) {
		    subpanel = new JPanel {
			Border border = NewEtchedBorder(ptr[1]);

			GridBagLayout layoutmanager = {
			    int columns = (orientation == VERTICAL) ? 1 : 0;
			};
		    };
		    layout = new Array[0, ...];
		};
	    } else if (ptr[1] == NULL) {
		separator = new JSeparator {
		    Color foreground = GetPreferredTextForeground();
		};
		layout[layout@sizeof] = separator;
		layout[layout@sizeof] = HORIZONTAL;
	    } else if (ptr[1] instanceof Border) {
		separator = new JCanvas {
		    Border border = ptr[1];
		};
		layout[layout@sizeof] = separator;
		layout[layout@sizeof] = HORIZONTAL;
	    } else if (ptr[1] instanceof double)
		layout[layout@sizeof] = ptr[1];
	}
    }

    if (subpanel != NULL) {
	subpanel.layout = layout;
	layout = editor_layout;
	layout[layout@sizeof] = subpanel;
	layout[layout@sizeof] = LEFT;
	layout[layout@sizeof] = NONE;
	subpanel = NULL;
    }

    //
    // Then update fields in the editor panel - layoutmanager should be set
    // before layout, otherwise there could be an error.
    //

    editor.layout = NULL;		// unnecessary
    editor.layoutmanager = new GridBagLayout {
	int columns = (orientation == VERTICAL) ? 1 : 0;
    };

    editor.layout = editor_layout;
    editor.buttons = buttons;

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor
	    };
	};
    }
    return(editor);
}

NewJCheckBoxEditComponent(String tag, String title, String text, Object group, int state, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    tag = PickEditComponentTag(tag);

    //
    // A constructor for a JCheckBox edit component.
    //

    initializer = new Dictionary[5, ...] {
	String tag = tag;
	String text = text;
	Object font = GetPreferredLabelFont();
	Object group = group;
	Color  foreground = GetPreferredForeground();
	int    state = state;

	//
	// Setting this to TRUE means the foreground color of the text will
	// be sync'd to indicate the validity of the component.
	//

	int synctextcolor = FALSE;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JChoice that's going to be used as an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = "0";
	String editlabel = title;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	actionPerformed(e) {
	    if (editor != NULL)
		invokeLater(&editor.AfterEdit, tag);
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    state = FALSE;
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetValue() {
	    String value;

	    SyncState();
	    value = toString(state);
	    return(defined("Format", this) ? Format(value) : value);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(FALSE);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else valid = FALSE;
		    } else if (isPointer(Validate) && isCallable(*Validate, 1))
			valid = (*Validate)(tag);
		    else if (isPointer(Validate) && isCallable(*Validate, 0))
			valid = (*Validate)();
		    else valid = FALSE;
		} else valid = (!IsEmpty() || !required);	// always TRUE
	    } else valid = TRUE;
	    return(valid);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetValue(String value, ...) {
	    state = (value === "1" || value === "true" || value === "TRUE");
	    SyncState();
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;
	    Object color = IsValid() ? NULL : PickInvalidForeground();

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = color;
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = color;

	    if (synctextcolor)
		this.foreground = color;
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JCheckBox initializer;

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor
	    };
	};
    }
    return(editor);
}

NewJCheckBoxPanelEditComponent(String tag, String title, Array items, Object selected, int orientation, Object apptags, ...) {

    return(NewJButtonPanelEditComponent(tag, title, items, selected, CHECKBOX_BUTTON, orientation, apptags, unroll(&apptags + 1)));
}

NewJChoiceEditComponent(String tag, String title, Array items, Object selected, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    tag = PickEditComponentTag(tag);

    //
    // A constructor for a JChoice edit component.
    //

    initializer = new Dictionary[11, ...] {
	String tag = tag;
	Object font = GetPreferredChoiceFont();
	Object selected = selected;
	Object transferhandler = NULL;		// required for custom drag and drop
	Array  items = items;
	Color  background = GetPreferredChoiceBackground();
	Color  foreground = GetPreferredChoiceForeground();

	Function mouseWheelMoved = MouseWheelMoved;
	Function dragGestureRecognized = DragGestureRecognized;
	Function dragEnter = DragEnter;
	Function drop = Drop;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JChoice that's going to be used as an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NO_SELECTION;
	String editlabel = title;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	itemStateChanged(e) {
	    if (e.state) {
		if (editor != NULL)
		    invokeLater(&editor.AfterEdit, tag);
	    }
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    selected = NO_SELECTION;
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetValue() {
	    String value;

	    SyncState();
	    value = selected;
	    return(defined("Format", this) ? Format(value) : value);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    //
	    // The last version had
	    //
	    //     return(selected !== NO_SELECTION);
	    //
	    // which sure looked wrong. Changed the test and also added a
	    // check for NULL on 2/24/11 (for ccs). Also now using this in
	    // IsValid().
	    //
	    return(selected === NO_SELECTION || selected == NULL);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else if (Validate@length == 1)
			    valid = Validate(selectedlabel);
			else valid = FALSE;
		    } else if (!IsEmpty()) {
			if (Validate instanceof Regexp)
			    valid = regexp(Validate, selectedlabel);
			else if (Validate instanceof String)
			    valid = (selectedlabel =~ Validate);
			else if (Validate instanceof Array)
			    valid = (indexOfObject(Validate, selectedlabel) >= 0);
			else valid = FALSE;
		    } else valid = !required;
		} else valid = (!IsEmpty() || !required);
	    } else valid = TRUE;
	    return(valid);
	}

	MapValueToDisplayed(String value) {
	    String displayed = "";
	    int    index;

	    if (value !== NO_SELECTION) {
		if ((index = indexOfObject(mappings, value)) >= 0)
		    displayed = labels[index];
	    }
	    return(displayed);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetItems(Array items) {
	    this.items = (indexOfObject(items, NO_SELECTION) >= 0) ? items : AddNoSel(items);
	    selected = NO_SELECTION;
	}

	SetValue(String value, ...) {
	    //
	    // In practice all all we really should have to do is something
	    // like,
	    //
	    //     this.selected = (value@sizeof > 0) ? value : NO_SELECTION;
	    //
	    // but during development we ran into a case where entries in the
	    // table didn't match the items that were being displayed in the
	    // JChoice. Perhaps we should issue a warning since it's something
	    // an administrator probably should look at.
	    //

	    if (value != NULL) {
		if (indexOfObject(items, value) < 0) {		// was using mappings
		    //
		    // Should we issue a warning here??
		    //
		    selected = NO_SELECTION;
		} else selected = value;
	    } else selected = NO_SELECTION;
	    SyncState();
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JChoice initializer;

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor
	    };
	};
    }
    return(editor);
}

NewJDateEditComponent(String tag, String other_tag, String title, int daymodel, int end, int flags, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    //
    // A constructor for a component that edits dates.
    //
    // The daymodel argument should be negative when the displayed day is
    // always forced to the first day of the month, zero when all days are
    // allowed, and positive when the day is forced to the last day of the
    // month. The daymodel is also used to select the elements in the date
    // display that are activated (i.e., have non-NULL event handlers).
    //
    // The end argument should be negative when the date displayed by this
    // component is a lower bound and positive if it's an upper bound. If
    // end is zero (or other_tag is NULL or doesn't reference a component
    // in the current screen) then any non-blank date is considered valid.
    //
    // NOTE - DnD is a little tricky and needs special attention.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[0, ...] {
	Calendar calendar = new Calendar {double unixtime = 0;};
	String   tag = tag;
	String   other_tag = other_tag;
	String   linked_tag = NULL;
	Object   minlimit = NULL;
	Object   maxlimit = NULL;
	Object   calscreen;
	Object   normalborder = NULL;
	Object   activeborder = NULL;
	Object   pressedborder = NULL;
	Object   lastfocuscomponent = NULL;
	double   lastunixtime;
	String   lasttext;
	Object   font = GetPreferredLabelFont();
	Color    foreground = GetPreferredForeground();
	int      sync_linked = FALSE;
	int      track = FALSE;
	int      daymodel = daymodel;
	int      activeyear = flags & ACTIVE_YEAR;
	int      end = end;

	//
	// The preferred_pattern and preferred_format strings are used when
	// dates are loaded (i.e., strings are converted to unixtimes). In
	// addition preferred_format is used when unixtimes are converted to
	// strings that can be sent back to the server. Both values can be
	// changed during initialization, but the should be consistent. The
	// display_format string is only for internal use, so Initialize()
	// makes sure it's set to an appropriate values.
	//

	String preferred_pattern = PATTERN_DATE;
	String preferred_format = FORMAT_DATE;
	String display_format = NULL;		// special value set in Initialize()

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JChoice that's going to be used an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	String startdate = NULL;
	int    startdate_locked = FALSE;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	GridBagLayout layoutmanager;
	Array layout = {
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_dow";
		Object font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "Www"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.DAY_OF_WEEK;
		int    focusable = FALSE;
		int    visible = flags & VISIBLE_DOW;

		//
		// NOTE - using something like
		//
		//     Pointer drop = &drop;
		//
		// doesn't work here because it ends up pointing to the drop
		// function defined in the initializer, so we use a slightly
		// more complicated definition. Incidentally, it also fails
		// because drop hasn't been defined yet, but that's not the
		// real reason why we're using a more complicated appraoch.
		//

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String text = " ";
		int    visible = flags & VISIBLE_DOW;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_month";
		Font   font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "Www"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.MONTH;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);

		Function mouseEntered = CalendarMouseEntered;
		Function focusGained = CalendarFocusGained;
		Function focusLost = CalendarFocusLost;
		Function keyPressed = CalendarKeyPressed;
		Function mouseWheelMoved = CalendarMouseWheelMoved;
		Function mousePressed = CalendarMousePressed;
		Function mouseReleased = CalendarMouseReleased;
	    },
	    new JLabel {
		String basetag = tag;
		String text = " ";

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_day";
		Font   font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "00"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.DATE;
		int    typing = FALSE;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);

		Function mouseEntered = daymodel == 0 ? CalendarMouseEntered : NULL;
		Function focusGained = daymodel == 0 ? CalendarFocusGained : NULL;
		Function focusLost = daymodel == 0 ? CalendarFocusLost : NULL;
		Function keyPressed = daymodel == 0 ? CalendarKeyPressed : NULL;
		Function keyTyped = daymodel == 0 ? CalendarKeyTyped : NULL;
		Function mouseWheelMoved = daymodel == 0 ? CalendarMouseWheelMoved : NULL;
		Function mousePressed = daymodel == 0 ? CalendarMousePressed : NULL;
		Function mouseReleased = daymodel == 0 ? CalendarMouseReleased : NULL;
	    },
	    new JLabel {
		String basetag = tag;
		String text = " ";

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_year";
		Font   font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "0000"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.YEAR;
		int    typing = FALSE;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);

		Function mouseEntered = activeyear ? CalendarMouseEntered : NULL;
		Function focusGained = activeyear ? CalendarFocusGained : NULL;
		Function focusLost = activeyear ? CalendarFocusLost : NULL;
		Function keyPressed = activeyear ? CalendarKeyPressed : NULL;
		Function keyTyped = activeyear ? CalendarKeyTyped : NULL;
		Function mouseWheelMoved = activeyear ? CalendarMouseWheelMoved : NULL;
		Function mousePressed = activeyear ? CalendarMousePressed : NULL;
		Function mouseReleased = activeyear ? CalendarMouseReleased : NULL;
	    },
	};

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	dragEnter(DropTargetEvent e) {
	    int accepted;

	    if (!DragEnterHandler(e)) {
		if (e.transferable instanceof String) {
		    //
		    // We eventually may want to do more here.
		    //
		    accepted = TRUE;
		} else accepted = FALSE;
	    } else accepted = TRUE;
	    return(accepted);
	}

	dragGestureRecognized(e) {
	    e.visual = GetValue();
	    return(e.visual);
	}

	drop(e) {
	    int accepted;

	    if (!DragEnterHandler(e)) {
		if (e.transferable instanceof String) {
		    SetValue(e.transferable);
		    accepted = TRUE;
		}
	    } else accepted = TRUE;

	    return(accepted);
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	AfterUpdate() {
	    //
	    // There's a small chance the UpdatePerformed() call should be
	    // handled using invokeLater, but only to make sure it always
	    // followed AfterEdit(). Decided to ignore it for now, but you
	    // eventually may want to change the call.
	    //

	    SyncState();
	    if (defined(other_tag, root.components))
		root.components[other_tag].SyncState();
	    if (editor != NULL)
		invokeLater(&editor.AfterEdit, tag);
	    UpdatePerformed();
	}

	BlankDisplay() {
	    calendar.unixtime = 0;
	    lastfocuscomponent = NULL;
	    UpdateDisplayParts(NULL);
	}

	CalBack(Dictionary selection, Object fields) {
	    Calendar cal;

	    //
	    // Changed mostly because the original implementation didn't use
	    // minlimit and maxlimit to constrain the final date. Eventually
	    // could use them to limit the calandar screen.
	    // 

	    cal.set(selection.year, selection.month - 1, selection.day, 0, 0, 0);
	    MapCalendarToLimits(cal);
	    if (IsBlank()) {
		if (!startdate_locked)
		    startdate = date(preferred_format, cal.unixtime);
	    }
	    Setup(cal, this.minlimit, this.maxlimit, TRUE);
	}

	CancelEdit() {
	    //
	    // Is there more to do here??
	    //
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetTimestamp(...) {
	    String value;

	    if (!IsBlank())
		value = (argc == 2) ? date(argv[1], calendar.unixtime) : date(preferred_format, calendar.unixtime);
	    else value = NULL;
	    return(value);
	}

	GetUnixtime() {
	    //
	    // Apparently Calendar.set() doesn't clear milliseconds so we do
	    // it here.
	    //
	    return(floor(calendar.unixtime));
	}

	GetUnixtimeForShowCalendar() {
	    Object cal;
	    double unixtime;

	    //
	    // A function that applications sometimes override.
	    //

	    if (IsBlank()) {
		if (startdate != NULL) {
		    if ((cal = PickCalendar(startdate)) != NULL)
			unixtime = cal.unixtime;
		    else unixtime = time();
		} else unixtime = time();
	    } else unixtime = calendar.unixtime;

	    return(unixtime);
        }

	GetValue() {
	    String value;

	    SyncState();
	    value = GetTimestamp();
	    return(defined("Format", this) ? Format(value) : value);
	}

	HideCalendar() {
	    if (calscreen != NULL)
		calscreen.HideScreen();
	}

	Initialize() {
	    display_format = "EEE|MMM|dd|yyyy";
	    startdate_locked = (startdate !== "");
	    if (startdate != NULL) {
		SetValue(startdate);
		if (!startdate_locked)
		    startdate = date(preferred_format);
	    }
	}

	IsBlank() {
	    //
	    // Recently changed from
	    //
	    //     return(root.components[tag+"_month"].text@sizeof == 0);
	    //
	    // primarily because UpdateDisplay() needed a better way to recognize
	    // when the calendar's unixtime should be ignored or not. It currently
	    // used IsBlank() to decide so we decided to change IsBlank(), but if
	    // that approach causes problems you can easily change the IsBlank()
	    // call to a test of calendar.unixtime in UpdateDisplay().
	    //
	    // NOTE - change assumes calendar.unixtime is set to a value less than
	    // or equal to 0 whenever the display is really blank (e.g., when the
	    // calendar is initialized or cleared by BlankDisplay()).
	    //

	    return(calendar.unixtime <= 0);		// recent change
	}

	IsDateValid() {
	    Object other_editor;
	    int    valid;

	    if (!IsBlank()) {
		if (end != 0) { 
		    if (defined(other_tag, root.components)) {
			other_editor = root.components[other_tag];
			if (!other_editor.IsBlank()) {
			    if (end < 0)
				valid = (GetUnixtime() < other_editor.GetUnixtime());
			    else valid = (other_editor.GetUnixtime() < GetUnixtime());
			} else valid = !other_editor.IsRequired();
		    } else valid = TRUE;
		} else valid = TRUE;
	    } else valid = !IsRequired();

	    return(valid);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(IsBlank());
	}

	IsRequired() {
	    return(required);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else valid = FALSE;
		    } else if (isPointer(Validate) && isCallable(*Validate, 1))
			valid = (*Validate)(tag);
		    else if (isPointer(Validate) && isCallable(*Validate, 0))
			valid = (*Validate)();
		    else valid = FALSE;
		} else valid = IsDateValid();
	    } else valid = TRUE;

	    return(valid);
	}

	MapCalendarToDayModel(Calendar cal) {
	    if (cal != NULL) {
		if (daymodel > 0) {
		    cal.add(Calendar.MONTH, 1);
		    cal.dayofmonth = 0;
		} else if (daymodel < 0)
		    cal.dayofmonth = 1;
		cal.set(cal.year, cal.month, cal.dayofmonth, 0, 0, 0);
	    }
	    return(cal);
	}

	MapCalendarToLimits(Calendar cal) {
	    Object ref;

	    if (minlimit instanceof Calendar) {
		if ((ref = minlimit.unixtime) > cal.unixtime) {
		    if (track && defined("SetCalendar", minlimit)) {
			minlimit.SetCalendar(cal.unixtime);
			if (minlimit.calendar.unixtime > cal.unixtime)
			    cal.unixtime = minlimit.calendar.unixtime;
		    } else cal.unixtime = ref;
		}
	    }

	    if (maxlimit != NULL) {
		if ((ref = maxlimit.unixtime) < cal.unixtime) {
		    if (track && defined("SetCalendar", maxlimit)) {
			maxlimit.SetCalendar(cal.unixtime);
			if (maxlimit.calendar.unixtime < cal.unixtime)
			    cal.unixtime = maxlimit.calendar.unixtime;
		    } else cal.unixtime = ref;
		}
	    }
	}

	PickCalendar(String value) {
	    Calendar calendar;
	    double   unixtime;

	    switch (value) {
		case DATE_OTHER:
		    break;

		default:
		    if (value =~ preferred_pattern)
			calendar.unixtime = parseDate(value, preferred_format);
		    else if (value =~ PATTERN_DATE)
			calendar.unixtime = parseDate(value, FORMAT_DATE);
		    else if (value =~ PATTERN_DATE_HHmm)
			calendar.unixtime = parseDate(value, FORMAT_DATE_HHmm);
		    else if (value =~ PATTERN_DATE_HHmmss)
			calendar.unixtime = parseDate(value, FORMAT_DATE_HHmmss);
		    else if (value =~ PATTERN_DATETIME_XML)
			calendar.unixtime = parseDate(value, FORMAT_DATETIME_XML);
		    else if ((unixtime = PickUnixTime(value)) !== NaN)
			calendar.unixtime = unixtime;
		    else calendar = NULL;
		    break;
	    }
	    if (calendar != NULL)
		calendar.set(calendar.year, calendar.month, calendar.dayofmonth, 0, 0, 0);
	    return(calendar);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	PickLimit(Object limit) {
	    Calendar calendar;

	    if (limit == NULL)
		calendar = NULL;
	    else if (limit === DATE_OTHER)
		calendar = PickCalendar(DATE_OTHER);
	    else if (limit instanceof String)
		calendar = PickCalendar(limit);
	    else if (limit instanceof Number)
		calendar.unixtime = limit;
	    else if (limit instanceof Calendar)
		calendar.unixtime = limit.unixtime;
	    else calendar = NULL;

	    if (calendar != NULL)
		calendar.set(calendar.year, calendar.month, calendar.dayofmonth, 0, 0, 0);

	    return(calendar);
	}

	ResetDisplay() {
	    UpdateDisplay(Calendar.YEAR, 0);
	}

	SetCalendar(Number value, ...) {
	    if (argc == 2)
		calendar.unixtime = value;
	    else if (argc >= 4 && argc <= 6)
		calendar.set(unroll(&value));
	    else VM.abort(BADCALL);
	    ResetDisplay();
	}

	SetDisplayBackground(Color c) {
	    components[tag+"_dow"].background = c;
	    components[tag+"_month"].background = c;
	    components[tag+"_day"].background = c;
	    components[tag+"_year"].background = c;
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetEnableEvents(int state) {
	    Object month;
	    Object day;
	    Object year;
	    Object next;

	    //
	    // Seems friendlier than disabling the entire panel and doesn't
	    // obscure the text displayed in labels.
	    //
	    // NOTE - checking the focusowner before removing event handlers
	    // is a precaution that's occasionally needed to make sure the
	    // highlighted border is properly cleared. The behavior can be
	    // reproduced on Linux when the mouse wheel is used to change a
	    // selection in the JChoice that's controlling our behavior. A
	    // very obscure problem and unfortunately more direct approaches
	    // didn't always work!!
	    //

	    month = root.components[tag+"_month"];
	    day = root.components[tag+"_day"];
	    year = root.components[tag+"_year"];

	    if (state) {
		month.mouseEntered = CalendarMouseEntered;
		month.focusGained = CalendarFocusGained;
		month.focusLost = CalendarFocusLost;
		month.keyPressed = CalendarKeyPressed;
		month.mouseWheelMoved = CalendarMouseWheelMoved;
		month.mousePressed = CalendarMousePressed;
		month.mouseReleased = CalendarMouseReleased;
		if (daymodel == 0) {
		    day.mouseEntered = CalendarMouseEntered;
		    day.focusGained = CalendarFocusGained;
		    day.focusLost = CalendarFocusLost;
		    day.keyPressed = CalendarKeyPressed;
		    day.keyTyped = CalendarKeyTyped;
		    day.mouseWheelMoved = CalendarMouseWheelMoved;
		    day.mousePressed = CalendarMousePressed;
		    day.mouseReleased = CalendarMouseReleased;
		}
		if (activeyear) {
		    year.mouseEntered = CalendarMouseEntered;
		    year.focusGained = CalendarFocusGained;
		    year.focusLost = CalendarFocusLost;
		    year.keyPressed = CalendarKeyPressed;
		    year.keyTyped = CalendarKeyTyped;
		    year.mouseWheelMoved = CalendarMouseWheelMoved;
		    year.mousePressed = CalendarMousePressed;
		    year.mouseReleased = CalendarMouseReleased;
		}
		month.focusable = TRUE;
		day.focusable = (daymodel == 0);
		year.focusable = activeyear;
	    } else {
		HideCalendar();
		if (!month.focusowner && !day.focusowner && !year.focusowner) {
		    month.mouseEntered = NULL;
		    month.focusGained = NULL;
		    month.focusLost = NULL;
		    month.keyPressed = NULL;
		    month.mouseWheelMoved = NULL;
		    month.mousePressed = NULL;
		    month.mouseReleased = NULL;
		    if (daymodel == 0) {
			day.mouseEntered = NULL;
			day.focusGained = NULL;
			day.focusLost = NULL;
			day.keyPressed = NULL;
			day.keyTyped = NULL;
			day.mouseWheelMoved = NULL;
			day.mousePressed = NULL;
			day.mouseReleased = NULL;
		    }
		    if (activeyear) {
			year.mouseEntered = NULL;
			year.focusGained = NULL;
			year.focusLost = NULL;
			year.keyPressed = NULL;
			year.keyTyped = NULL;
			year.mouseWheelMoved = NULL;
			year.mousePressed = NULL;
			year.mouseReleased = NULL;
		    }
		    month.focusable = FALSE;
		    day.focusable = FALSE;
		    year.focusable = FALSE;
		} else {
		    if ((next = getFocusComponentAfter(year, root.components[panel_tag])) == NULL) {
			month.requestfocus = FALSE;
			day.requestfocus = FALSE;
			year.requestfocus = FALSE;
		    } else next.requestfocus = TRUE;
		    invokeLater(&SetEnableEvents, state);
		}
	    }
	}

	SetFocusToFirst() {
	    Object comp;

	    //
	    // This function, when defined, is used by editors to make sure
	    // the appropriate component gets the initial focus. Seems like
	    // a bit of kludge, but without it the JPanel that's created as
	    // the editor keeps the focus when its requestfocus field is set
	    // to TRUE. Eventually should investigate to see what's really
	    // happening - maybe the interpreter can compensate or perhaps
	    // it's causing the behavior. Trying to track down focus issues
	    // is a challenge - the Java source code is very complicated!!
	    // 

	    comp = root.components[tag+"_month"];
	    if (comp.focusable)
		comp.requestfocus = TRUE;
	}

	SetStartDate(String value) {
	    startdate = value;
	    Initialize();
	}

	Setup(Calendar cal, Calendar minlimit, Calendar maxlimit, int enableevents) {
	    this.minlimit = MapCalendarToDayModel(minlimit);
	    this.maxlimit = MapCalendarToDayModel(maxlimit);

	    if (cal != NULL) {
		cal = MapCalendarToDayModel(cal);
		SetCalendar(cal.unixtime);
		SetEnableEvents(enableevents);
	    } else {
		calendar.unixtime = 0;
		BlankDisplay();
		SetEnableEvents(startdate != NULL);	// recent change from FALSE
	    }
	}

	SetValue(String value, ...) {
	    Setup(PickCalendar(value), PickLimit(this.minlimit), PickLimit(this.maxlimit), value != NULL);
	}

	ShowCalendar() {
	    Calendar cal;
	    Object   screen;
	    String   name = "calendar_" + root.tag;

	    if (editor == NULL || !editor.edit_readonly) {
		if ((screen = GetCachedScreen(name)) != NULL) {
		    if (defined("cbdict", screen) && screen.cbdict != this)
			screen.HideScreen();
		}

		cal.unixtime = GetUnixtimeForShowCalendar();

		calscreen = GetAndShowScreen(
		    name, "calendar",
		    "parent", root,
		    "autodispose", TRUE,
		    "callback", "CalBack",
		    "cbdict", this,
		    "now", cal,
		    "anchorpoint", this,
		    "screenanchor", SOUTHWEST,
		    "anchorstyle", NORTHWEST
		);
	    }
	}

	StartTyping(String tag) {
	    int typing = FALSE;

	    if (calscreen == NULL || !calscreen.visible) {
		if (defined("typing", root.components[tag])) {
		    if (!root.components[tag].typing) {
			lastunixtime = GetUnixtime();
			lasttext = root.components[tag].text;
			root.components[tag].text = "";
			root.components[tag].typing = TRUE;
		    }
		    typing = root.components[tag].typing;
		}
	    }
	    return(typing);
	}

	StopTyping(String tag) {
	    String text;

	    if (defined("typing", root.components[tag]) && root.components[tag].typing) {
		root.components[tag].typing = FALSE;
		text = root.components[tag].text;
		if (text@sizeof > lasttext@sizeof)
		    text = lasttext;
		text = strfmt(strfmt("%%0%ds", lasttext@sizeof), text);
		UpdateDisplay(root.components[tag].caltype, atoi(text) - atoi(lasttext));
		if (root.components[tag].text !== text)
		    SetCalendar(lastunixtime);
	    }
	}

	SyncFocus() {
	    Object comp;

	    if (!defined("owner", this) || !defined("SyncFocus", owner)) {
		if ((comp = lastfocuscomponent) != NULL)
		    comp.requestfocus = TRUE;
		else this.requestfocus = TRUE;
	    } else owner.SyncFocus(this);
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;
	    Object color;

	    //
	    // Sets the external indication of our state (i.e., the color
	    // of our panel's border title) by trying to compare our date
	    // with the current end date.
	    //

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();

	    if (sync_linked) {
		if (defined(linked_tag, root.components)) {
		    if (defined("SyncState", root.components[linked_tag]))
			root.components[linked_tag].SyncState();
		}
	    }
	}

	TypedChar(String tag, String str) {
	    String text;

	    if (StartTyping(tag)) {
		text = trim(root.components[tag].text);
		switch (str) {
		    case "\n":
			StopTyping(tag);
			break;

		    case "\b":
			if (text@sizeof > 0)
			    root.components[tag].text = new String[text@sizeof-1] text;
			break;

		    default:
			root.components[tag].text = text + str;
			break;
		}
	    }
	}

	UpdateDisplay(int mode, int amount) {
	    if (IsBlank())
		calendar.unixtime = GetUnixtimeForShowCalendar();
	    else calendar.add(mode, amount);

	    MapCalendarToLimits(calendar);
	    MapCalendarToDayModel(calendar);
	    UpdateDisplayParts(strsplit(date(calendar.locale, calendar.timezone, display_format, calendar.unixtime), "|"));
	}

	UpdateDisplayParts(Array parts) {
	    Object comp;
	    int    blanked;
	    int    updated = FALSE;

	    if (parts == NULL) {
		parts = new Array {"", "", "", ""};
		blanked = TRUE;
		updated = TRUE;		// force AfterUpdate - recent addition mostly for empty startdate
	    } else blanked = FALSE;

	    if (root.components[tag+"_dow"].text !== parts[0]) {
		comp = root.components[tag+"_dow"];
		comp.text = parts[0];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_year"].text !== parts[3]) {
		comp = root.components[tag+"_year"];
		comp.text = parts[3];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_month"].text !== parts[1]) {
		comp = root.components[tag+"_month"];
		comp.text = parts[1];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_day"].text !== parts[2]) {
		comp = root.components[tag+"_day"];
		comp.text = parts[2];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }

	    if (blanked)
		lastfocuscomponent = NULL;
	    if (updated) {
		if (defined("owner", this) && defined("AfterUpdate", owner)) {
		    if (owner.AfterUpdate@length == 1)
			owner.AfterUpdate(this);
		    else owner.AfterUpdate();
		} else AfterUpdate();
	    }
	}

	UpdatePerformed() {
	    //
	    // A function that applications can define when they want to
	    // be notified after every update.
	    //
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JPanel initializer;

    //
    // Users can now pass displaybackground color as an optional argument, so
    // we handle it before the new panel is returned to the caller.
    //

    if (defined("displaybackground", editor) && editor.displaybackground instanceof Color)
        editor.SetDisplayBackground(editor.displaybackground);

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor,
		BOTH,
	    };
	};
    }
    return(editor);
}

NewJDateTimeEditComponent(String tag, String other_tag, String title, int daymodel, int end, int flags, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    //
    // A constructor for a component that edits dates.
    //
    // The daymodel argument should be negative when the displayed day is
    // always forced to the first day of the month, zero when all days are
    // allowed, and positive when the day is forced to the last day of the
    // month. The daymodel is also used to select the elements in the date
    // display that are activated (i.e., have non-NULL event handlers).
    //
    // The end argument should be negative when the date displayed by this
    // component is a lower bound and positive if it's an upper bound. If
    // end is zero (or other_tag is NULL or doesn't reference a component
    // in the current screen) then any non-blank date is considered valid.
    //
    // NOTE - DnD is a little tricky and needs special attention.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[0, ...] {
	Calendar calendar = new Calendar {double unixtime = 0;};
	String   tag = tag;
	String   other_tag = other_tag;
	String   linked_tag = NULL;
	Object   minlimit = NULL;
	Object   maxlimit = NULL;
	Object   calscreen;
	Object   normalborder = NULL;
	Object   activeborder = NULL;
	Object   pressedborder = NULL;
	Object   lastfocuscomponent = NULL;
	double   lastunixtime;
	String   lasttext;
	Object   font = GetPreferredLabelFont();
	Color    foreground = GetPreferredForeground();
	int      sync_linked = FALSE;
	int      track = FALSE;
	int      daymodel = daymodel;
	int      activeyear = flags & ACTIVE_YEAR;
	int      ampm = flags & VISIBLE_AMPM;
	int      end = end;

	//
	// The preferred_pattern and preferred_format strings are used when
	// dates are loaded (i.e., strings are converted to unixtimes). In
	// addition preferred_format is used when unixtimes are converted to
	// strings that can be sent back to the server. Both values can be
	// changed during initialization, but the should be consistent. The
	// display_format string is only for internal use, so Initialize()
	// makes sure it's set to an appropriate values.
	//

	String preferred_pattern = PATTERN_DATETIME;
	String preferred_format = FORMAT_DATETIME;
	String display_format = NULL;		// special value set in Initialize()

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JChoice that's going to be used an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	String startdate = NULL;
	int    startdate_locked = FALSE;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	GridBagLayout layoutmanager;
	Array layout = {
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_dow";
		Object font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "Www"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.DAY_OF_WEEK;
		int    focusable = FALSE;
		int    visible = flags & VISIBLE_DOW;

		//
		// NOTE - using something like
		//
		//     Pointer drop = &drop;
		//
		// doesn't work here because it ends up pointing to the drop
		// function defined in the initializer, so we use a slightly
		// more complicated definition. Incidentally, it also fails
		// because drop hasn't been defined yet, but that's not the
		// real reason why we're using a more complicated appraoch.
		//

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String text = " ";
		int    visible = flags & VISIBLE_DOW;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_month";
		Font   font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "Www"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.MONTH;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);

		Function mouseEntered = CalendarMouseEntered;
		Function focusGained = CalendarFocusGained;
		Function focusLost = CalendarFocusLost;
		Function keyPressed = CalendarKeyPressed;
		Function mouseWheelMoved = CalendarMouseWheelMoved;
		Function mousePressed = CalendarMousePressed;
		Function mouseReleased = CalendarMouseReleased;
	    },
	    new JLabel {
		String basetag = tag;
		String text = " ";

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_day";
		Font   font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "00"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.DATE;
		int    typing = FALSE;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);

		Function mouseEntered = daymodel == 0 ? CalendarMouseEntered : NULL;
		Function focusGained = daymodel == 0 ? CalendarFocusGained : NULL;
		Function focusLost = daymodel == 0 ? CalendarFocusLost : NULL;
		Function keyPressed = daymodel == 0 ? CalendarKeyPressed : NULL;
		Function keyTyped = daymodel == 0 ? CalendarKeyTyped : NULL;
		Function mouseWheelMoved = daymodel == 0 ? CalendarMouseWheelMoved : NULL;
		Function mousePressed = daymodel == 0 ? CalendarMousePressed : NULL;
		Function mouseReleased = daymodel == 0 ? CalendarMouseReleased : NULL;
	    },
	    new JLabel {
		String basetag = tag;
		String text = " ";

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_year";
		Font   font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "0000"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.YEAR;
		int    typing = FALSE;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);

		Function mouseEntered = activeyear ? CalendarMouseEntered : NULL;
		Function focusGained = activeyear ? CalendarFocusGained : NULL;
		Function focusLost = activeyear ? CalendarFocusLost : NULL;
		Function keyPressed = activeyear ? CalendarKeyPressed : NULL;
		Function keyTyped = activeyear ? CalendarKeyTyped : NULL;
		Function mouseWheelMoved = activeyear ? CalendarMouseWheelMoved : NULL;
		Function mousePressed = activeyear ? CalendarMousePressed : NULL;
		Function mouseReleased = activeyear ? CalendarMouseReleased : NULL;
	    },
	    new JLabel {
		String basetag = tag;
		String text = " at ";

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_hour";
		Object font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "00"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.HOUR;
		int    typing = FALSE;

		Function mouseEntered = CalendarMouseEntered;
		Function focusGained = CalendarFocusGained;
		Function focusLost = CalendarFocusLost;
		Function keyPressed = CalendarKeyPressed;
		Function keyTyped = CalendarKeyTyped;
		Function mouseWheelMoved = CalendarMouseWheelMoved;
		Function mousePressed = ClockMousePressed;
		Function mouseReleased = ClockMouseReleased;
	    },
	    new JLabel {
		String basetag = tag;
		String text = ":";

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_minute";
		int    autotrim = TRUE;
		Object font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "00"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    caltype = Calendar.MINUTE;
		int    typing = FALSE;

		Function mouseEntered = CalendarMouseEntered;
		Function focusGained = CalendarFocusGained;
		Function focusLost = CalendarFocusLost;
		Function keyPressed = CalendarKeyPressed;
		Function keyTyped = CalendarKeyTyped;
		Function mouseWheelMoved = CalendarMouseWheelMoved;
		Function mousePressed = ClockMousePressed;
		Function mouseReleased = ClockMouseReleased;
	    },
	    new JLabel {
		String text = " ";
		int    visible = flags & VISIBLE_AMPM;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_ampm";
		Object font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		int    autotrim = TRUE;
		int    alignment = LEFT;
		int    focusable = FALSE;
		int    visible = flags & VISIBLE_AMPM;
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "mm");
		};

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String text = " ";
		int    visible = flags & VISIBLE_TZ;

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_tz";
		Object font = GetPreferredLabelFont();
		Color  background = GetPreferredBackground();
		int    autotrim = TRUE;
		int    alignment = LEFT;
		int    focusable = FALSE;
		int    visible = flags & VISIBLE_TZ;
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "+0000");	// not accounting for GMT+hh:mm case
		};

		dragEnter(DropTargetEvent e) = root.components[basetag].dragEnter(e);
		dragGestureRecognized(e) = root.components[basetag].dragGestureRecognized(e);
		drop(e) = root.components[basetag].drop(e);
	    },
	};

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	dragEnter(DropTargetEvent e) {
	    int accepted;

	    if (!DragEnterHandler(e)) {
		if (e.transferable instanceof String) {
		    //
		    // We eventually may want to do more here.
		    //
		    accepted = TRUE;
		} else accepted = FALSE;
	    } else accepted = TRUE;
	    return(accepted);
	}

	dragGestureRecognized(e) {
	    e.visual = GetValue();
	    return(e.visual);
	}

	drop(e) {
	    int accepted;

	    if (!DragEnterHandler(e)) {
		if (e.transferable instanceof String) {
		    SetValue(e.transferable);
		    accepted = TRUE;
		}
	    } else accepted = TRUE;

	    return(accepted);
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	AfterUpdate() {
	    //
	    // There's a small chance the UpdatePerformed() call should be
	    // handled using invokeLater, but only to make sure it always
	    // followed AfterEdit(). Decided to ignore it for now, but you
	    // eventually may want to change the call.
	    //

	    SyncState();
	    if (defined(other_tag, root.components))
		root.components[other_tag].SyncState();
	    if (editor != NULL)
		invokeLater(&editor.AfterEdit, tag);
	    UpdatePerformed();
	}

	BlankDisplay() {
	    calendar.unixtime = 0;
	    lastfocuscomponent = NULL;
	    UpdateDisplayParts(NULL);
	}

	CalBack(Dictionary selection, Object fields) {
	    Calendar cal;

	    //
	    // Changed mostly because the original implementation didn't use
	    // minlimit and maxlimit to constrain the final date. Eventually
	    // could use them to limit the calandar screen.
	    // 

	    cal.set(selection.year, selection.month - 1, selection.day, 0, 0, 0);
	    MapCalendarToLimits(cal);
	    if (IsBlank()) {
		if (!startdate_locked)
		    startdate = date(preferred_format, cal.unixtime);
	    }
	    Setup(cal, this.minlimit, this.maxlimit, TRUE);
	}

	CancelEdit() {
	    //
	    // Is there more to do here??
	    //
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetTimestamp(...) {
	    String value;

	    if (!IsBlank())
		value = (argc == 2) ? date(argv[1], calendar.unixtime) : date(preferred_format, calendar.unixtime);
	    else value = NULL;
	    return(value);
	}

	GetUnixtime() {
	    //
	    // Apparently Calendar.set() doesn't clear milliseconds so we do
	    // it here.
	    //
	    return(floor(calendar.unixtime));
	}

	GetUnixtimeForShowCalendar() {
	    Object cal;
	    double unixtime;

	    //
	    // A function that applications sometimes override.
	    //

	    if (IsBlank()) {
		if (startdate != NULL) {
		    if ((cal = PickCalendar(startdate)) != NULL)
			unixtime = cal.unixtime;
		    else unixtime = time();
		} else unixtime = time();
	    } else unixtime = calendar.unixtime;

	    return(unixtime);
        }

	GetValue() {
	    String value;

	    SyncState();
	    value = GetTimestamp();
	    return(defined("Format", this) ? Format(value) : value);
	}

	HideCalendar() {
	    if (calscreen != NULL)
		calscreen.HideScreen();
	}

	Initialize() {
	    if (ampm)
		display_format = "EEE|MMM|dd|yyyy|hh|mm|aa|X";
	    else display_format = "EEE|MMM|dd|yyyy|HH|mm|aa|X";
	    startdate_locked = (startdate !== "");
	    if (startdate != NULL) {
		SetValue(startdate);
		if (!startdate_locked)
		    startdate = date(preferred_format);
	    }
	}

	IsBlank() {
	    //
	    // Recently changed from
	    //
	    //     return(root.components[tag+"_month"].text@sizeof == 0);
	    //
	    // primarily because UpdateDisplay() needed a better way to recognize
	    // when the calendar's unixtime should be ignored or not. It currently
	    // used IsBlank() to decide so we decided to change IsBlank(), but if
	    // that approach causes problems you can easily change the IsBlank()
	    // call to a test of calendar.unixtime in UpdateDisplay().
	    //
	    // NOTE - change assumes calendar.unixtime is set to a value less than
	    // or equal to 0 whenever the display is really blank (e.g., when the
	    // calendar is initialized or cleared by BlankDisplay()).
	    //

	    return(calendar.unixtime <= 0);		// recent change
	}

	IsDateValid() {
	    Object other_editor;
	    int    valid;

	    if (!IsBlank()) {
		if (end != 0) { 
		    if (defined(other_tag, root.components)) {
			other_editor = root.components[other_tag];
			if (!other_editor.IsBlank()) {
			    if (end < 0)
				valid = (GetUnixtime() < other_editor.GetUnixtime());
			    else valid = (other_editor.GetUnixtime() < GetUnixtime());
			} else valid = !other_editor.IsRequired();
		    } else valid = TRUE;
		} else valid = TRUE;
	    } else valid = !IsRequired();

	    return(valid);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(IsBlank());
	}

	IsRequired() {
	    return(required);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else valid = FALSE;
		    } else if (isPointer(Validate) && isCallable(*Validate, 1))
			valid = (*Validate)(tag);
		    else if (isPointer(Validate) && isCallable(*Validate, 0))
			valid = (*Validate)();
		    else valid = FALSE;
		} else valid = IsDateValid();
	    } else valid = TRUE;

	    return(valid);
	}

	MapCalendarToDayModel(Calendar cal) {
	    if (cal != NULL) {
		if (daymodel > 0) {
		    cal.add(Calendar.MONTH, 1);
		    cal.dayofmonth = 0;
		} else if (daymodel < 0)
		    cal.dayofmonth = 1;
		cal.set(cal.year, cal.month, cal.dayofmonth, cal.hourofday, cal.minute, 0);
	    }
	    return(cal);
	}

	MapCalendarToLimits(Calendar cal) {
	    Object ref;

	    if (minlimit instanceof Calendar) {
		if ((ref = minlimit.unixtime) > cal.unixtime) {
		    if (track && defined("SetCalendar", minlimit)) {
			minlimit.SetCalendar(cal.unixtime);
			if (minlimit.calendar.unixtime > cal.unixtime)
			    cal.unixtime = minlimit.calendar.unixtime;
		    } else cal.unixtime = ref;
		}
	    }

	    if (maxlimit != NULL) {
		if ((ref = maxlimit.unixtime) < cal.unixtime) {
		    if (track && defined("SetCalendar", maxlimit)) {
			maxlimit.SetCalendar(cal.unixtime);
			if (maxlimit.calendar.unixtime < cal.unixtime)
			    cal.unixtime = maxlimit.calendar.unixtime;
		    } else cal.unixtime = ref;
		}
	    }
	}

	PickCalendar(String value) {
	    Calendar calendar;
	    double   unixtime;

	    switch (value) {
		case DATE_OTHER:
		    break;

		default:
		    if (value =~ preferred_pattern)
			calendar.unixtime = parseDate(value, preferred_format);
		    else if (value =~ PATTERN_DATE)
			calendar.unixtime = parseDate(value, FORMAT_DATE);
		    else if (value =~ PATTERN_DATE_HHmm)
			calendar.unixtime = parseDate(value, FORMAT_DATE_HHmm);
		    else if (value =~ PATTERN_DATE_HHmmss)
			calendar.unixtime = parseDate(value, FORMAT_DATE_HHmmss);
		    else if (value =~ PATTERN_DATETIME_XML)
			calendar.unixtime = parseDate(value, FORMAT_DATETIME_XML);
		    else if ((unixtime = PickUnixTime(value)) !== NaN)
			calendar.unixtime = unixtime;
		    else calendar = NULL;
		    break;
	    }
	    if (calendar != NULL)
		calendar.set(calendar.year, calendar.month, calendar.dayofmonth, calendar.hourofday, calendar.minute, 0);
	    return(calendar);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	PickLimit(Object limit) {
	    Calendar calendar;

	    if (limit == NULL)
		calendar = NULL;
	    else if (limit === DATE_OTHER)
		calendar = PickCalendar(DATE_OTHER);
	    else if (limit instanceof String)
		calendar = PickCalendar(limit);
	    else if (limit instanceof Number)
		calendar.unixtime = limit;
	    else if (limit instanceof Calendar)
		calendar.unixtime = limit.unixtime;
	    else calendar = NULL;

	    if (calendar != NULL)
		calendar.set(calendar.year, calendar.month, calendar.dayofmonth, calendar.hourofday, calendar.minute, 0);

	    return(calendar);
	}

	ResetDisplay() {
	    UpdateDisplay(Calendar.YEAR, 0);
	}

	SetCalendar(Number value, ...) {
	    if (argc == 2)
		calendar.unixtime = value;
	    else if (argc >= 4 && argc <= 6)
		calendar.set(unroll(&value));
	    else VM.abort(BADCALL);
	    ResetDisplay();
	}

	SetDisplayBackground(Color c) {
	    components[tag+"_dow"].background = c;
	    components[tag+"_month"].background = c;
	    components[tag+"_day"].background = c;
	    components[tag+"_year"].background = c;
	    components[tag+"_hour"].background = c;
	    components[tag+"_minute"].background = c;
	    components[tag+"_ampm"].background = c;
	    components[tag+"_tz"].background = c;
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetEnableEvents(int state) {
	    Object month;
	    Object day;
	    Object year;
	    Object hour;
	    Object minute;
	    Object next;

	    //
	    // Seems friendlier than disabling the entire panel and doesn't
	    // obscure the text displayed in labels.
	    //
	    // NOTE - checking the focusowner before removing event handlers
	    // is a precaution that's occasionally needed to make sure the
	    // highlighted border is properly cleared. The behavior can be
	    // reproduced on Linux when the mouse wheel is used to change a
	    // selection in the JChoice that's controlling our behavior. A
	    // very obscure problem and unfortunately more direct approaches
	    // didn't always work!!
	    //

	    month = root.components[tag+"_month"];
	    day = root.components[tag+"_day"];
	    year = root.components[tag+"_year"];
	    hour = root.components[tag+"_hour"];
	    minute = root.components[tag+"_minute"];

	    if (state) {
		month.mouseEntered = CalendarMouseEntered;
		month.focusGained = CalendarFocusGained;
		month.focusLost = CalendarFocusLost;
		month.keyPressed = CalendarKeyPressed;
		month.mouseWheelMoved = CalendarMouseWheelMoved;
		month.mousePressed = CalendarMousePressed;
		month.mouseReleased = CalendarMouseReleased;
		if (daymodel == 0) {
		    day.mouseEntered = CalendarMouseEntered;
		    day.focusGained = CalendarFocusGained;
		    day.focusLost = CalendarFocusLost;
		    day.keyPressed = CalendarKeyPressed;
		    day.keyTyped = CalendarKeyTyped;
		    day.mouseWheelMoved = CalendarMouseWheelMoved;
		    day.mousePressed = CalendarMousePressed;
		    day.mouseReleased = CalendarMouseReleased;
		}
		if (activeyear) {
		    year.mouseEntered = CalendarMouseEntered;
		    year.focusGained = CalendarFocusGained;
		    year.focusLost = CalendarFocusLost;
		    year.keyPressed = CalendarKeyPressed;
		    year.keyTyped = CalendarKeyTyped;
		    year.mouseWheelMoved = CalendarMouseWheelMoved;
		    year.mousePressed = CalendarMousePressed;
		    year.mouseReleased = CalendarMouseReleased;
		}
		hour.mouseEntered = CalendarMouseEntered;
		hour.focusGained = CalendarFocusGained;
		hour.focusLost = CalendarFocusLost;
		hour.keyPressed = CalendarKeyPressed;
		hour.keyTyped = CalendarKeyTyped;
		hour.mouseWheelMoved = CalendarMouseWheelMoved;
		hour.mousePressed = CalendarMousePressed;
		hour.mouseReleased = CalendarMouseReleased;
		minute.mouseEntered = CalendarMouseEntered;
		minute.focusGained = CalendarFocusGained;
		minute.focusLost = CalendarFocusLost;
		minute.keyPressed = CalendarKeyPressed;
		minute.keyTyped = CalendarKeyTyped;
		minute.mouseWheelMoved = CalendarMouseWheelMoved;
		minute.mousePressed = CalendarMousePressed;
		minute.mouseReleased = CalendarMouseReleased;

		month.focusable = TRUE;
		day.focusable = (daymodel == 0);
		year.focusable = activeyear;
		hour.focusable = TRUE;
		minute.focusable = TRUE;
	    } else {
		HideCalendar();
		if (!month.focusowner && !day.focusowner && !year.focusowner) {
		    month.mouseEntered = NULL;
		    month.focusGained = NULL;
		    month.focusLost = NULL;
		    month.keyPressed = NULL;
		    month.mouseWheelMoved = NULL;
		    month.mousePressed = NULL;
		    month.mouseReleased = NULL;
		    if (daymodel == 0) {
			day.mouseEntered = NULL;
			day.focusGained = NULL;
			day.focusLost = NULL;
			day.keyPressed = NULL;
			day.keyTyped = NULL;
			day.mouseWheelMoved = NULL;
			day.mousePressed = NULL;
			day.mouseReleased = NULL;
		    }
		    if (activeyear) {
			year.mouseEntered = NULL;
			year.focusGained = NULL;
			year.focusLost = NULL;
			year.keyPressed = NULL;
			year.keyTyped = NULL;
			year.mouseWheelMoved = NULL;
			year.mousePressed = NULL;
			year.mouseReleased = NULL;
		    }
		    hour.mouseEntered = NULL;
		    hour.focusGained = NULL;
		    hour.focusLost = NULL;
		    hour.keyPressed = NULL;
		    hour.keyTyped = NULL;
		    hour.mouseWheelMoved = NULL;
		    hour.mousePressed = NULL;
		    hour.mouseReleased = NULL;
		    minute.mouseEntered = NULL;
		    minute.focusGained = NULL;
		    minute.focusLost = NULL;
		    minute.keyPressed = NULL;
		    minute.keyTyped = NULL;
		    minute.mouseWheelMoved = NULL;
		    minute.mousePressed = NULL;
		    minute.mouseReleased = NULL;

		    month.focusable = FALSE;
		    day.focusable = FALSE;
		    year.focusable = FALSE;
		    hour.focusable = FALSE;
		    minute.focusable = FALSE;
		} else {
		    if ((next = getFocusComponentAfter(year, root.components[panel_tag])) == NULL) {
			month.requestfocus = FALSE;
			day.requestfocus = FALSE;
			year.requestfocus = FALSE;
		    } else next.requestfocus = TRUE;
		    invokeLater(&SetEnableEvents, state);
		}
	    }
	}

	SetFocusToFirst() {
	    Object comp;

	    //
	    // This function, when defined, is used by editors to make sure
	    // the appropriate component gets the initial focus. Seems like
	    // a bit of kludge, but without it the JPanel that's created as
	    // the editor keeps the focus when its requestfocus field is set
	    // to TRUE. Eventually should investigate to see what's really
	    // happening - maybe the interpreter can compensate or perhaps
	    // it's causing the behavior. Trying to track down focus issues
	    // is a challenge - the Java source code is very complicated!!
	    // 

	    comp = root.components[tag+"_month"];
	    if (comp.focusable)
		comp.requestfocus = TRUE;
	}

	SetStartDate(String value) {
	    startdate = value;
	    Initialize();
	}

	Setup(Calendar cal, Calendar minlimit, Calendar maxlimit, int enableevents) {
	    this.minlimit = MapCalendarToDayModel(minlimit);
	    this.maxlimit = MapCalendarToDayModel(maxlimit);

	    if (cal != NULL) {
		cal = MapCalendarToDayModel(cal);
		SetCalendar(cal.unixtime);
		SetEnableEvents(enableevents);
	    } else {
		calendar.unixtime = 0;
		BlankDisplay();
		SetEnableEvents(startdate != NULL);	// recent change from FALSE
	    }
	}

	SetValue(String value, ...) {
	    Setup(PickCalendar(value), PickLimit(this.minlimit), PickLimit(this.maxlimit), value != NULL);
	}

	ShowCalendar() {
	    Calendar cal;
	    Object   screen;
	    String   name = "calendar_" + root.tag;

	    if (editor == NULL || !editor.edit_readonly) {
		if ((screen = GetCachedScreen(name)) != NULL) {
		    if (defined("cbdict", screen) && screen.cbdict != this)
			screen.HideScreen();
		}

		cal.unixtime = GetUnixtimeForShowCalendar();

		calscreen = GetAndShowScreen(
		    name, "calendar",
		    "parent", root,
		    "autodispose", TRUE,
		    "callback", "CalBack",
		    "cbdict", this,
		    "now", cal,
		    "anchorpoint", this,
		    "screenanchor", SOUTHWEST,
		    "anchorstyle", NORTHWEST
		);
	    }
	}

	StartTyping(String tag) {
	    int typing = FALSE;

	    if (calscreen == NULL || !calscreen.visible) {
		if (defined("typing", root.components[tag])) {
		    if (!root.components[tag].typing) {
			lastunixtime = GetUnixtime();
			lasttext = root.components[tag].text;
			root.components[tag].text = "";
			root.components[tag].typing = TRUE;
		    }
		    typing = root.components[tag].typing;
		}
	    }
	    return(typing);
	}

	StopTyping(String tag) {
	    String text;

	    if (defined("typing", root.components[tag]) && root.components[tag].typing) {
		root.components[tag].typing = FALSE;
		text = root.components[tag].text;
		if (text@sizeof > lasttext@sizeof)
		    text = lasttext;
		text = strfmt(strfmt("%%0%ds", lasttext@sizeof), text);
		UpdateDisplay(root.components[tag].caltype, atoi(text) - atoi(lasttext));
		if (root.components[tag].text !== text)
		    SetCalendar(lastunixtime);
	    }
	}

	SyncFocus() {
	    Object comp;

	    if (!defined("owner", this) || !defined("SyncFocus", owner)) {
		if ((comp = lastfocuscomponent) != NULL)
		    comp.requestfocus = TRUE;
		else this.requestfocus = TRUE;
	    } else owner.SyncFocus(this);
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;
	    Object color;

	    //
	    // Sets the external indication of our state (i.e., the color
	    // of our panel's border title) by trying to compare our date
	    // with the current end date.
	    //

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();

	    if (sync_linked) {
		if (defined(linked_tag, root.components)) {
		    if (defined("SyncState", root.components[linked_tag]))
			root.components[linked_tag].SyncState();
		}
	    }
	}

	TypedChar(String tag, String str) {
	    String text;

	    if (StartTyping(tag)) {
		text = trim(root.components[tag].text);
		switch (str) {
		    case "\n":
			StopTyping(tag);
			break;

		    case "\b":
			if (text@sizeof > 0)
			    root.components[tag].text = new String[text@sizeof-1] text;
			break;

		    default:
			root.components[tag].text = text + str;
			break;
		}
	    }
	}

	UpdateDisplay(int mode, int amount) {
	    if (IsBlank())
		calendar.unixtime = GetUnixtimeForShowCalendar();
	    else calendar.add(mode, amount);

	    MapCalendarToLimits(calendar);
	    MapCalendarToDayModel(calendar);
	    UpdateDisplayParts(strsplit(date(calendar.locale, calendar.timezone, display_format, calendar.unixtime), "|"));
	}

	UpdateDisplayParts(Array parts) {
	    Object comp;
	    int    blanked;
	    int    updated = FALSE;

	    if (parts == NULL) {
		parts = new Array {"", "", "", "", "", "", "", ""};
		blanked = TRUE;
		updated = TRUE;		// force AfterUpdate - recent addition mostly for empty startdate
	    } else blanked = FALSE;

	    if (root.components[tag+"_dow"].text !== parts[0]) {
		comp = root.components[tag+"_dow"];
		comp.text = parts[0];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_minute"].text !== parts[5]) {
		comp = root.components[tag+"_minute"];
		comp.text = parts[5];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_year"].text !== parts[3]) {
		comp = root.components[tag+"_year"];
		comp.text = parts[3];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_month"].text !== parts[1]) {
		comp = root.components[tag+"_month"];
		comp.text = parts[1];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_day"].text !== parts[2]) {
		comp = root.components[tag+"_day"];
		comp.text = parts[2];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_hour"].text !== parts[4]) {
		comp = root.components[tag+"_hour"];
		comp.text = parts[4];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_minute"].text !== parts[5]) {
		comp = root.components[tag+"_minute"];
		comp.text = parts[5];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_ampm"].text !== parts[6]) {
		comp = root.components[tag+"_ampm"];
		comp.text = parts[6];
		updated = TRUE;
	    }
	    if (root.components[tag+"_tz"].text !== parts[7]) {
		comp = root.components[tag+"_tz"];
		comp.text = parts[7];
		updated = TRUE;
	    }

	    if (blanked)
		lastfocuscomponent = NULL;
	    if (updated) {
		if (defined("owner", this) && defined("AfterUpdate", owner)) {
		    if (owner.AfterUpdate@length == 1)
			owner.AfterUpdate(this);
		    else owner.AfterUpdate();
		} else AfterUpdate();
	    }
	}

	UpdatePerformed() {
	    //
	    // A function that applications can define when they want to
	    // be notified after every update.
	    //
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JPanel initializer;

    //
    // Users can now pass displaybackground color as an optional argument, so
    // we handle it before the new panel is returned to the caller.
    //

    if (defined("displaybackground", editor) && editor.displaybackground instanceof Color)
        editor.SetDisplayBackground(editor.displaybackground);

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor,
		BOTH,
	    };
	};
    }
    return(editor);
}

NewJDateJChoiceEditComponent(String tag, String other_tag, String title, int daymodel, int end, int flags, Array items, Object selected, Object apptags, ...) {
    Object selector;
    Object display;

    //
    // A constructor for a component that edits dates and also includes a
    // JChoice that can be loaded with values that select particular dates.
    //
    // The daymodel argument should be negative when the displayed day is
    // always forced to the first day of the month, zero when all days are
    // allowed, and positive when the day is forced to the last day of the
    // month. The daymodel is also used to select the elements in the date
    // display that are activated (i.e., have non-NULL event handlers).
    //
    // The end argument should be negative when the date displayed by this
    // component is a lower bound and positive if it's an upper bound. If
    // end is zero (or other_tag is NULL or doesn't reference a component
    // in the current screen) then any non-blank date is considered valid.
    //
    // NOTE - any extra arguments handed to this function are be passed to
    // NewJChoice() after the explicit dictionary argument (just look for
    // the closing paren in the NewJChoice() call and you'll find where we
    // do it). It's a bit obscure, but good enough for now. It also means
    // all extra arguments are handed to the JChoice, which also is good
    // enough for now.
    //
    // NOTE - DnD is a little tricky and needs special attention.
    //
    // NOTE - haven't ported much of the new startdate code from the other
    // date and date/time constructors, but it's something that eventually
    // should be done.
    //

    tag = PickEditComponentTag(tag);

    if (items@sizeof == 0) {
	items = new Array {
	    " ", NO_SELECTION,
	    "Other", DATE_OTHER,
	};
	selected = 1;
    }

    selector = NewJChoice(tag, items, selected, new Dictionary {
	String display_tag = tag + "_display";
	String panel_tag = tag + "_panel";
	String other_tag = other_tag;
	String other_display_tag = (other_tag != NULL) ? other_tag + "_display" : NULL;
	String defaultdate;
	String otherdate;
	Object minlimit = NULL;
	Object maxlimit = NULL;
	int    daymodel = daymodel;
	int    end = end;
	int    usedisplayedtime = TRUE;
	int    initialized = FALSE;

	//
	// The preferred_pattern and preferred_format strings are used when
	// dates are loaded (i.e., strings are converted to unixtimes). In
	// addition preferred_format is used when unixtimes are converted to
	// strings that can be sent back to the server. Both values can be
	// changed during initialization, but the should be consistent. The
	// display_format string is only for internal use, so Initialize()
	// makes sure it's set to an appropriate values.
	//

	String preferred_pattern = PATTERN_DATETIME;
	String preferred_format = FORMAT_DATETIME;
	String display_format = NULL;		// special value set in Initialize()

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JChoice that's going to be used an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NO_SELECTION;
	String editlabel = title;
	String startdate = NULL;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	dragEnter(DropTargetEvent e) {
	    int accepted;

	    if (!DragEnterHandler(e)) {
		if (e.transferable instanceof String) {
		    //
		    // We eventually may want to do more here.
		    //
		    accepted = TRUE;
		} else accepted = FALSE;
	    } else accepted = TRUE;
	    return(accepted);
	}

	dragGestureRecognized(e) {
	    if (selected !== NO_SELECTION)
		e.visual = GetValue();
	    else e.visual = NULL;

	    return(e.visual);
	}

	drop(e) {
	    int accepted;

	    if (!DragEnterHandler(e)) {
		if (e.transferable instanceof String) {
		    SetValue(e.transferable);
		    accepted = TRUE;
		}
	    } else accepted = TRUE;

	    return(accepted);
	}

	itemStateChanged(e) {
	    Object calendar;
	    Object minlimit;
	    Object maxlimit;
	    String value;

	    if (e.state) {
		value = selected;
		if (value === NO_SELECTION) {
		    if (defaultdate != NULL) {
			calendar = PickCalendar(defaultdate);
			minlimit = calendar;
			maxlimit = calendar;
		    } else {
			calendar = NULL;
			minlimit = NULL;
			maxlimit = NULL;
		    }
		} else {
		    calendar = PickCalendar(value === DATE_OTHER && otherdate != NULL ? otherdate : value);
		    minlimit = PickLimit(this.minlimit);
		    maxlimit = PickLimit(this.maxlimit);
		}

		root.components[display_tag].Setup(calendar, minlimit, maxlimit, value === DATE_OTHER);
		if (editor != NULL)
		    invokeLater(&editor.AfterEdit, tag);
	    }
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    initialized = FALSE;
	    defaultdate = NULL;
	    otherdate = NULL;
	    selected = NULL;
	    selected = NO_SELECTION;
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetValue() {
	    String value;

	    SyncState();
	    value = root.components[display_tag].GetTimestamp();
	    return(defined("Format", this) ? Format(value) : value);
	}

	Initialize() {
	    Object display;

	    display = root.components[display_tag];
	    display.preferred_pattern = preferred_pattern;
	    display.preferred_format = preferred_format;
	    display.display_format = "EEE|MMM|dd|yyyy";

	    if (startdate != NULL)
		SetValue(startdate);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(root.components[display_tag].IsBlank());
	}

	IsRequired() {
	    return(required);
	}

	IsValid() {
	    Object display;
	    Object other_display;
	    int    valid;

	    //
	    // Eventually will add Validate support to this function, but
	    // right now it's not important because this component isn't
	    // used in the application that we're currently working on.
	    //

	    if (is_edit_component_enabled) {
		display = root.components[display_tag];
		if (!display.IsBlank()) {
		    if (end != 0) { 
			if (defined(other_display_tag, root.components)) {
			    other_display = root.components[other_display_tag];
			    if (!other_display.IsBlank()) {
				//
				// Changed tests so equality is valid - probably should
				// be configurable.
				//
				if (end < 0)
				    valid = (display.GetUnixtime() <= other_display.GetUnixtime());
				else valid = (other_display.GetUnixtime() <= display.GetUnixtime());
			    } else valid = !root.components[other_tag].IsRequired();
			} else valid = TRUE;
		    } else valid = TRUE;
		} else valid = !IsRequired();
	    } else valid = TRUE;

	    return(valid);
	}

	MapDateToItem(String value) {
	    Calendar target;
	    Calendar calendar;
	    String   item = NULL;

	    value = MapValueToDisplayed(value);
	    if (value =~ preferred_pattern) {
		target.unixtime = parseDate(value, preferred_format);
		target.set(target.year, target.month, target.dayofmonth, 0, 0, 0);	// should be unnecessary
		for (ptr in mappings) {
		    if ((calendar = PickCalendar(ptr[0])) != NULL) {
			if (target.year == calendar.year && target.month == calendar.month && target.dayofmonth == calendar.dayofmonth) {
			    item = ptr[0];
			    break;
			}
		    }
		}
		if (item == NULL || selected === DATE_OTHER) {
		    if ((calendar = PickLimit(minlimit)) != NULL) {
			if (target.unixtime >= floor(calendar.unixtime)) {
			    if ((calendar = PickLimit(maxlimit)) != NULL) {
				if (target.unixtime <= floor(calendar.unixtime))
				    item = DATE_OTHER;
			    } else item = DATE_OTHER;
			}
		    } else if ((calendar = PickLimit(maxlimit)) != NULL) {
			if (target.unixtime <= floor(calendar.unixtime))
			    item = DATE_OTHER;
		    } else item = DATE_OTHER;
		}
	    }
	    return(item);
	}

	MapValueToDisplayed(String value) {
	    Calendar calendar;

	    //
	    // Enforces the daymodel setting, so PickCalendar() should be able
	    // ignore adjustments and just return a calendar that's set to the
	    // right month and year (when daymode is non-zero).
	    //

	    if (value != NULL) {
		if ((calendar = PickCalendar(value)) != NULL) {
		    if (daymodel > 0) {
			calendar.add(Calendar.MONTH, 1);
			calendar.dayofmonth = 0;
		    } else if (daymodel < 0)
			calendar.dayofmonth = 1;
		    value = date(preferred_format, calendar.unixtime);
		} else value = "";
	    } else value = "";

	    return(value);
	}

	PickCalendar(String value) {
	    Calendar calendar;
	    double   unixtime;

	    //
	    // A function that's often replaced by a version that knows how
	    // to translate any item that can be selected from items into an
	    // appropriate calendar.
	    //

	    switch (value) {
		case DATE_OTHER:
		    if (otherdate == NULL) {
			if (usedisplayedtime) {
			    if ((unixtime = root.components[display_tag].GetUnixtime()) > 0)
				calendar.unixtime = unixtime;
			}
		    } else {
			//
			// Should be able to do something like
			//
			//     calendar = PickCalendar(otherdate);
			//
			// here, but didn't have time to thoroughly test so we're
			// using brute force.
			//
			if (otherdate =~ preferred_pattern)
			    calendar.unixtime = parseDate(otherdate, preferred_format);
			else if (otherdate =~ PATTERN_DATE)
			    calendar.unixtime = parseDate(otherdate, FORMAT_DATE);
			else if (otherdate =~ PATTERN_DATE_HHmm)
			    calendar.unixtime = parseDate(otherdate, FORMAT_DATE_HHmm);
			else if (otherdate =~ PATTERN_DATE_HHmmss)
			    calendar.unixtime = parseDate(otherdate, FORMAT_DATE_HHmmss);
			else if (otherdate =~ PATTERN_DATETIME_XML)
			    calendar.unixtime = parseDate(otherdate, FORMAT_DATETIME_XML);
			else calendar = NULL;
		    }
		    break;

		default:
		    if (value =~ preferred_pattern)
			calendar.unixtime = parseDate(value, preferred_format);
		    else if (value =~ PATTERN_DATE)
			calendar.unixtime = parseDate(value, FORMAT_DATE);
		    else if (value =~ PATTERN_DATE_HHmm)
			calendar.unixtime = parseDate(value, FORMAT_DATE_HHmm);
		    else if (value =~ PATTERN_DATE_HHmmss)
			calendar.unixtime = parseDate(value, FORMAT_DATE_HHmmss);
		    else if (value =~ PATTERN_DATETIME_XML)
			calendar.unixtime = parseDate(value, FORMAT_DATETIME_XML);
		    else if ((unixtime = PickUnixTime(value)) !== NaN)
			calendar.unixtime = unixtime;
		    else calendar = NULL;
		    break;
	    }
	    if (calendar != NULL)
		calendar.set(calendar.year, calendar.month, calendar.dayofmonth, 0, 0, 0);
	    return(calendar);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	PickLimit(Object limit) {
	    Calendar calendar;

	    if (limit == NULL)
		calendar = NULL;
	    else if (limit === DATE_OTHER)
		calendar = PickCalendar(DATE_OTHER);
	    else if (limit instanceof String)
		calendar = PickCalendar(limit);
	    else if (limit instanceof Number)
		calendar.unixtime = limit;
	    else if (limit instanceof Calendar)
		calendar.unixtime = limit.unixtime;
	    else calendar = NULL;

	    if (calendar != NULL)
		calendar.set(calendar.year, calendar.month, calendar.dayofmonth, 0, 0, 0);

	    return(calendar);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetStartDate(String value) {
	    startdate = value;
	    Initialize();
	}

	SetValue(String value, ...) {
	    String item = MapDateToItem(value);
	    String last = selected;

	    if (!initialized) {
		//
		// Old version always assigned value to defaultdate - should we
		// take another look??
		//
		if (item === DATE_OTHER) {
		    otherdate = value;
		    defaultdate = NULL;
		} else {
		    defaultdate = value;
		    otherdate = NULL;
		}
		initialized = TRUE;
	    }

	    if (item != NULL) {
		//
		// Old version compared selected to DATE_OTHER - should we take
		// another look?? If so itemStateChanged() will also need work
		// and it's all very sensitive!!
		//
		if (item === DATE_OTHER)
		    otherdate = value;
		selected = NULL;
		selected = item;
	    } else {
		defaultdate = value;
		selected = NULL;
		selected = NO_SELECTION;
	    }

	    if (last !== selected)
		root.components[display_tag].SetLastFocusComponent(this);
	    SyncState();
	}

	SyncFocus() {
	    root.components[display_tag].SyncFocus();
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;
	    Object color;

	    //
	    // Sets the external indication of our state (i.e., the color
	    // of our panel's border title) by trying to compare our date
	    // with the current end date.
	    //

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}
    }, unroll(&apptags + 1));

    //
    // The initializer used to create display is a modified version of the
    // JPanel built by the YWAIT NewJDatePanel() constructor. It probably
    // wouldn't be hard turn it into a new YWAIT constructor - maybe later.
    //

    display = new JPanel {
	Calendar calendar = new Calendar;
	String   selector_tag = tag;
	String   other_tag = other_tag;
	String   panel_tag = tag + "_panel";
	String   tag = tag + "_display";
	Object   minlimit = NULL;
	Object   maxlimit = NULL;
	Object   calscreen;
	Object   normalborder = NULL;
	Object   activeborder = NULL;
	Object   pressedborder = NULL;
	Object   lastfocuscomponent = NULL;
	double   lastunixtime;
	String   lasttext;
	Object   font = GetPreferredLabelFont();
	Color    foreground = GetPreferredForeground();
	int      track = FALSE;
	int      daymodel = daymodel;
	int      activeyear = flags & ACTIVE_YEAR;

	//
	// These values are all set by the selector's Initialize() function,
	// so assigning values to them here won't work. See the comments in
	// the selector that describe the strings.
	//

	String preferred_pattern = NULL;
	String preferred_format = NULL;
	String display_format = NULL;

	GridBagLayout layoutmanager;
	Array layout = {
	    new JLabel {
		//
		// Padding between display and selector that handles DnD.
		//
		// NOTE - using assignments like
		//
		//     Pointer drop = &selector.drop;
		//
		// is allowed because some simple changes were made to the
		// Yoix interpreter and it works in this "edit component"
		// (and not in the simpler date edit component) because the
		// JChoice that's really used in the screen has already been
		// created.
		//
		String text = " ";

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_dow";
		Object font = GetPreferredLabelFont();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "Www"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.DAY_OF_WEEK;
		int    focusable = FALSE;
		int    visible = flags & VISIBLE_DOW;

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;
	    },
	    new JLabel {
		String text = " ";
		int    visible = flags & VISIBLE_DOW;

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_month";
		String selector_tag = selector_tag;
		Font   font = GetPreferredLabelFont();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "Www"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.MONTH;

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;

		Function mouseEntered = CalendarMouseEntered;
		Function focusGained = CalendarFocusGained;
		Function focusLost = CalendarFocusLost;
		Function keyPressed = CalendarKeyPressed;
		Function mouseWheelMoved = CalendarMouseWheelMoved;
		Function mousePressed = CalendarMousePressed;
		Function mouseReleased = CalendarMouseReleased;
	    },
	    new JLabel {
		String text = " ";

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_day";
		Font   font = GetPreferredLabelFont();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "00"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.DATE;
		int    typing = FALSE;

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;

		Function mouseEntered = daymodel == 0 ? CalendarMouseEntered : NULL;
		Function focusGained = daymodel == 0 ? CalendarFocusGained : NULL;
		Function focusLost = daymodel == 0 ? CalendarFocusLost : NULL;
		Function keyPressed = daymodel == 0 ? CalendarKeyPressed : NULL;
		Function mouseWheelMoved = daymodel == 0 ? CalendarMouseWheelMoved : NULL;
		Function mousePressed = daymodel == 0 ? CalendarMousePressed : NULL;
		Function mouseReleased = daymodel == 0 ? CalendarMouseReleased : NULL;
	    },
	    new JLabel {
		String text = " ";

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;
	    },
	    new JLabel {
		String basetag = tag;
		String tag = basetag + "_year";
		Font   font = GetPreferredLabelFont();
		Dimension preferredsize = {
		    double width = 2.0 * VM.screen.pixelwidth + stringWidth(font, "0000"); // account for border width
		};
		double border = VM.screen.pixelwidth;
		Object saveborder;
		int    autotrim = TRUE;
		int    caltype = Calendar.YEAR;
		int    typing = FALSE;

		Pointer dragEnter = &selector.dragEnter;
		Pointer dragGestureRecognized = &selector.dragGestureRecognized;
		Pointer drop = &selector.drop;

		Function mouseEntered = activeyear ? CalendarMouseEntered : NULL;
		Function focusGained = activeyear ? CalendarFocusGained : NULL;
		Function focusLost = activeyear ? CalendarFocusLost : NULL;
		Function keyPressed = activeyear ? CalendarKeyPressed : NULL;
		Function mouseWheelMoved = activeyear ? CalendarMouseWheelMoved : NULL;
		Function mousePressed = activeyear ? CalendarMousePressed : NULL;
		Function mouseReleased = activeyear ? CalendarMouseReleased : NULL;
	    },
	};

	AfterUpdate() {
	    Object selector = root.components[selector_tag];

	    selector.SyncState();
	    if (defined(other_tag, root.components))
		root.components[other_tag].SyncState();
	    if (selector.editor != NULL)
		invokeLater(&selector.editor.AfterEdit, selector_tag);
	}

	BlankDisplay() {
	    UpdateDisplayParts(NULL);
	}

	CalBack(Dictionary selection, Object fields) {
	    Calendar cal;

	    //
	    // Changed mostly because the original implementation didn't use
	    // minlimit and maxlimit to constrain the final date. Eventually
	    // could use them to limit the calandar screen.
	    // 

	    cal.set(selection.year, selection.month - 1, selection.day, 0, 0, 0);
	    Setup(cal, this.minlimit, this.maxlimit, TRUE);
	}

	GetTimestamp(...) {
	    String value;

	    if (!IsBlank())
		value = (argc == 2) ? date(argv[1], calendar.unixtime) : date(preferred_format, calendar.unixtime);
	    else value = NULL;
	    return(value);
	}

	GetUnixtime() {
	    //
	    // Apparently Calendar.set() doesn't clear milliseconds so we do
	    // it here.
	    //
	    return(floor(calendar.unixtime));
	}

	HideCalendar() {
	    if (calscreen != NULL)
		calscreen.HideScreen();
	}

	IsBlank() {
	    return(root.components[tag+"_month"].text@sizeof == 0);
	}

	MapCalendarToDayModel(Calendar cal) {
	    if (cal != NULL) {
		if (daymodel > 0) {
		    cal.add(Calendar.MONTH, 1);
		    cal.dayofmonth = 0;
		} else if (daymodel < 0)
		    cal.dayofmonth = 1;
		cal.set(cal.year, cal.month, cal.dayofmonth, 0, 0, 0);
	    }
	    return(cal);
	}

	MapCalendarToLimits(Calendar cal) {
	    Object ref;

	    if (minlimit instanceof Calendar) {
		if ((ref = minlimit.unixtime) > cal.unixtime) {
		    if (track && defined("SetCalendar", minlimit)) {
			minlimit.SetCalendar(cal.unixtime);
			if (minlimit.calendar.unixtime > cal.unixtime)
			    cal.unixtime = minlimit.calendar.unixtime;
		    } else cal.unixtime = ref;
		}
	    }

	    if (maxlimit != NULL) {
		if ((ref = maxlimit.unixtime) < cal.unixtime) {
		    if (track && defined("SetCalendar", maxlimit)) {
			maxlimit.SetCalendar(cal.unixtime);
			if (maxlimit.calendar.unixtime < cal.unixtime)
			    cal.unixtime = maxlimit.calendar.unixtime;
		    } else cal.unixtime = ref;
		}
	    }
	}

	ResetDisplay() {
	    UpdateDisplay(Calendar.YEAR, 0);
	}

	SetCalendar(Number value, ...) {
	    if (argc == 2)
		calendar.unixtime = value;
	    else if (argc >= 4 && argc <= 6)
		calendar.set(unroll(&value));
	    else VM.abort(BADCALL);
	    ResetDisplay();
	}

	SetEnableEvents(int state) {
	    Object month;
	    Object day;
	    Object year;
	    Object next;

	    //
	    // Seems friendlier than disabling the entire panel and doesn't
	    // obscure the text displayed in labels.
	    //
	    // NOTE - checking the focusowner before removing event handlers
	    // is a precaution that's occasionally needed to make sure the
	    // highlighted border is properly cleared. The behavior can be
	    // reproduced on Linux when the mouse wheel is used to change a
	    // selection in the JChoice that's controlling our behavior. A
	    // very obscure problem and unfortunately more direct approaches
	    // didn't always work!!
	    //

	    month = root.components[tag+"_month"];
	    day = root.components[tag+"_day"];
	    year = root.components[tag+"_year"];

	    if (state) {
		month.mouseEntered = CalendarMouseEntered;
		month.focusGained = CalendarFocusGained;
		month.focusLost = CalendarFocusLost;
		month.keyPressed = CalendarKeyPressed;
		month.mouseWheelMoved = CalendarMouseWheelMoved;
		month.mousePressed = CalendarMousePressed;
		month.mouseReleased = CalendarMouseReleased;
		if (daymodel == 0) {
		    day.mouseEntered = CalendarMouseEntered;
		    day.focusGained = CalendarFocusGained;
		    day.focusLost = CalendarFocusLost;
		    day.keyPressed = CalendarKeyPressed;
		    day.mouseWheelMoved = CalendarMouseWheelMoved;
		    day.mousePressed = CalendarMousePressed;
		    day.mouseReleased = CalendarMouseReleased;
		}
		if (activeyear) {
		    year.mouseEntered = CalendarMouseEntered;
		    year.focusGained = CalendarFocusGained;
		    year.focusLost = CalendarFocusLost;
		    year.keyPressed = CalendarKeyPressed;
		    year.mouseWheelMoved = CalendarMouseWheelMoved;
		    year.mousePressed = CalendarMousePressed;
		    year.mouseReleased = CalendarMouseReleased;
		}
		month.focusable = TRUE;
		day.focusable = (daymodel == 0);
		year.focusable = activeyear;
	    } else {
		HideCalendar();
		if (!month.focusowner && !day.focusowner && !year.focusowner) {
		    month.mouseEntered = NULL;
		    month.focusGained = NULL;
		    month.focusLost = NULL;
		    month.keyPressed = NULL;
		    month.mouseWheelMoved = NULL;
		    month.mousePressed = NULL;
		    month.mouseReleased = NULL;
		    if (daymodel == 0) {
			day.mouseEntered = NULL;
			day.focusGained = NULL;
			day.focusLost = NULL;
			day.keyPressed = NULL;
			day.mouseWheelMoved = NULL;
			day.mousePressed = NULL;
			day.mouseReleased = NULL;
		    }
		    if (activeyear) {
			year.mouseEntered = NULL;
			year.focusGained = NULL;
			year.focusLost = NULL;
			year.keyPressed = NULL;
			year.mouseWheelMoved = NULL;
			year.mousePressed = NULL;
			year.mouseReleased = NULL;
		    }
		    month.focusable = FALSE;
		    day.focusable = FALSE;
		    year.focusable = FALSE;
		} else {
		    if ((next = getFocusComponentAfter(year, root.components[panel_tag])) == NULL) {
			month.requestfocus = FALSE;
			day.requestfocus = FALSE;
			year.requestfocus = FALSE;
		    } else next.requestfocus = TRUE;
		    invokeLater(&SetEnableEvents, state);
		}
	    }
	}

	SetLastFocusComponent(Object comp) {
	    lastfocuscomponent = comp;
	}

	Setup(Calendar cal, Calendar minlimit, Calendar maxlimit, int enableevents) {
	    this.minlimit = MapCalendarToDayModel(minlimit);
	    this.maxlimit = MapCalendarToDayModel(maxlimit);

	    if (cal != NULL) {
		cal = MapCalendarToDayModel(cal);
		SetCalendar(cal.unixtime);
		SetEnableEvents(enableevents);
	    } else {
		calendar.unixtime = 0;
		BlankDisplay();
		SetEnableEvents(FALSE);
	    }
	}

	ShowCalendar() {
	    Object selector = root.components[selector_tag];
	    Object screen;
	    String name = "calendar_" + root.tag;

	    if (selector.editor == NULL || !selector.editor.edit_readonly) {
		if ((screen = GetCachedScreen(name)) != NULL) {
		    if (defined("cbdict", screen) && screen.cbdict != this)
			screen.HideScreen();
		}

		calscreen = GetAndShowScreen(
		    name, "calendar",
		    "parent", root,
		    "autodispose", TRUE,
		    "callback", "CalBack",
		    "cbdict", this,
		    "now", calendar,
		    "anchorpoint", this,
		    "screenanchor", SOUTHWEST,
		    "anchorstyle", NORTHWEST
		);
	    }
	}

	StartTyping(String tag) {
	    int typing = FALSE;

	    if (calscreen == NULL || !calscreen.visible) {
		if (defined("typing", root.components[tag])) {
		    if (!root.components[tag].typing) {
			lastunixtime = GetUnixtime();
			lasttext = root.components[tag].text;
			root.components[tag].text = "";
			root.components[tag].typing = TRUE;
		    }
		    typing = root.components[tag].typing;
		}
	    }
	    return(typing);
	}

	StopTyping(String tag) {
	    String text;

	    if (defined("typing", root.components[tag]) && root.components[tag].typing) {
		root.components[tag].typing = FALSE;
		text = root.components[tag].text;
		if (text@sizeof > lasttext@sizeof)
		    text = lasttext;
		text = strfmt(strfmt("%%0%ds", lasttext@sizeof), text);
		UpdateDisplay(root.components[tag].caltype, atoi(text) - atoi(lasttext));
		if (root.components[tag].text !== text)
		    SetCalendar(lastunixtime);
	    }
	}

	SyncFocus() {
	    Object comp;

	    if ((comp = lastfocuscomponent) != NULL)
		comp.requestfocus = TRUE;
	    else this.requestfocus = TRUE;
	}

	TypedChar(String tag, String str) {
	    String text;

	    if (StartTyping(tag)) {
		text = trim(root.components[tag].text);
		switch (str) {
		    case "\n":
			StopTyping(tag);
			break;

		    case "\b":
			if (text@sizeof > 0)
			    root.components[tag].text = new String[text@sizeof-1] text;
			break;

		    default:
			root.components[tag].text = text + str;
			break;
		}
	    }
	}

	UpdateDisplay(int mode, int amount) {
	    //
	    // Tried using mode to figure out how to set lastfocuscomponent,
	    // but unfortunately it didn't work. Eventually will investigate,
	    // but the culprit may be in the way SetValue() handles selected.
	    // Bottom line is there's some room for improvement in the way
	    // UpdateDisplayParts() sets lastfocuscomponent.
	    //

	    calendar.add(mode, amount);

	    MapCalendarToLimits(calendar);
	    MapCalendarToDayModel(calendar);
	    UpdateDisplayParts(strsplit(date(calendar.locale, calendar.timezone, display_format, calendar.unixtime), "|"));
	}

	UpdateDisplayParts(Array parts) {
	    Object comp;
	    int    blanked;
	    int    updated = FALSE;

	    if (parts == NULL) {
		parts = new Array {"", "", "", ""};
		blanked = TRUE;
		updated = TRUE;		// force AfterUpdate - recent addition mostly for empty startdate
	    } else blanked = FALSE;

	    if (root.components[tag+"_dow"].text !== parts[0]) {
		comp = root.components[tag+"_dow"];
		comp.text = parts[0];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_year"].text !== parts[3]) {
		comp = root.components[tag+"_year"];
		comp.text = parts[3];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_month"].text !== parts[1]) {
		comp = root.components[tag+"_month"];
		comp.text = parts[1];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }
	    if (root.components[tag+"_day"].text !== parts[2]) {
		comp = root.components[tag+"_day"];
		comp.text = parts[2];
		if (comp.focusable)
		    lastfocuscomponent = comp;
		updated = TRUE;
	    }

	    if (blanked)
		lastfocuscomponent = NULL;
	    if (updated)
		AfterUpdate();
	}
    };

    return(new JPanel {
	String tag = tag + "_panel";
	Border border = (title != NULL) ? NewEtchedBorder(title) : NULL;

	GridBagLayout layoutmanager;
	Array layout = {
	    selector,
	    display,
	};
    });
}

NewJListEditComponent(String tag, String title, Array items, int rows, Object selected, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    //
    // A constructor for a JList edit component.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[9, ...] {
	String tag = tag;
	Object font = GetPreferredTextFont();
	Object selected = selected;
	Array  items = items;
	Color  background = GetPreferredTextBackground();
	Color  foreground = GetPreferredTextForeground();
	int    rows = rows;
	int    multiplemode = TRUE;
	int    scroll = AS_NEEDED;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JList that's going to be used as an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;
	int    sizecontrol = 0x0911;	// some YoixSwingJScrollPane magic

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	valueChanged(e) {
	    if (e.sequence == 0) {
		if (editor != NULL)
		    invokeLater(&editor.AfterEdit, tag);
	    }
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    selected = items[1];	// kludge to force scroll to first item
	    selected = NULL;
	    SyncState();
	}

	CompareNumbers(Object arg1, Object arg2) {
	    //
	    // A comparison function used to make sure we generate identical keys
	    // when we're presented with comma separated lists that could contain
	    // the same set of numbers.
	    //

	    arg1 = atoi(arg1);
	    arg2 = atoi(arg2);
	    return(arg1 < arg2 ? -1 : (arg1 > arg2 ? 1 : 0));
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetValue() {
	    String value;

	    SyncState();
	    value = strjoin(qsort(selected, CompareNumbers), ",");
	    return(defined("Format", this) ? Format(value) : value);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(selected@sizeof == 0);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else valid = FALSE;
		    } else valid = FALSE;
		} else valid = (!IsEmpty() || !required);
	    } else valid = TRUE;
	    return(valid);
	}

	LoadData(Object data) {
	    if (data instanceof String || data instanceof Array || data == NULL) {
		if (data instanceof Array)
		    data = strjoin(data, ",");
		SetValue(data);
	    }
	}

	MapValueToDisplayed(String value) {
	    String displayed = "";
	    Array  values;
	    int    index;

	    if (value != NULL) {
		values = strsplit(value, ",");
		for (ptr in values) {
		    if ((index = indexOfObject(mappings, ptr[0])) >= 0) {
			if (displayed@sizeof)
			    displayed += ", ";
			displayed += labels[index];
		    }
		}
	    }
	    return(displayed);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetItems(Array items) {
	    this.items = items;
	    selected = NULL;
	}

	SetValue(String value, ...) {
	    selected = NULL;
	    selected = strsplit(value, ",");
	    SyncState();
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JList initializer;

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor
	    };
	};
    }
    return(editor);
}

NewJRadioButtonPanelEditComponent(String tag, String title, Array items, Object selected, int orientation, Object apptags, ...) {

    return(NewJButtonPanelEditComponent(tag, title, items, selected, RADIO_BUTTON, orientation, apptags, unroll(&apptags + 1)));
}

NewJTableEditComponent(String tag, String title, Object inputfilter, int scroll, Object apptags, ...) {
    //
    // This edit component provides support for editing, formatting, and
    // validating table cells, that's activated when you add fields named
    // "editor", "formatter", and "validator" to the JTableColumns defined
    // in the table's columns array. More...
    //

    Dictionary initializer;
    Object     editor;
    Object     ptr;

    //
    // A constructor for a JTable edit component.
    //
    // NOTE - you probably should restrict columns that are edited using a
    // JTextField to STRING_TYPE or TEXT_TYPE, otherwise the validation in
    // JTable may interfere. Unfortunately supplying a JTable validator()
    // probably won't help much.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[15, ...] {
	Object outputfilter = inputfilter instanceof String ? new Array {inputfilter, "\n"} : NULL;
	double rowheightadjustment = -1;
	int    edit = TRUE;

	//
	// Variables that are used by the YWAIT table support code.
	//

	Dictionary tags;
	Dictionary datatags;
	Array      activecolumns;
	Array      activetags;
	Color      activeforeground = NULL;
	int        activemask = 0;
	Array      vieworder;

	//
	// The current implementation probably doesn't handle row additions or
	// deletions gracefully in a table that's been filtered, so for now it
	// filtering must be explicitly requested by setting filtering to TRUE.
	//

	int filtering = FALSE;

	//
	// If selection_mark isn't NULL a special selection column is added to
	// the start of the table and the selection_mark string is displayed in
	// the row that's currently selected in that column. The value assigned
	// to selection_color_model controls how cells in the seleted row are
	// colored. The value should be 0 for no coloring, 1 if the only cell
	// that's colored is the special selection column, and 2 if all cells
	// should be highlighted. Initialize() decides if selection_color_model
	// is negative, which means model 1 if there's a selection column and 2
	// if there isn't.
	//
	// NOTE - we usually recommend setting selection_mark, even though the
	// current default is NULL, and in that case the we also think model 1
	// (which you eventually get when selection_color_model is -1) is the
	// best choice.
	//

	String selection_mark = NULL;
	int    selection_color_model = -1;	// negative => set in Initialize()
	int    selection_mark_count;		// always set in Initialize()

	//
	// If there's a boolean column that's supposed to be checked to indicate
	// the user has clicked on the row assign its tag to visitedtag.
	//

	String visitedtag;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// Variables that are used, if they're defined, by table event handlers
	// when they want to generate a visual indication that an active cell in
	// the table has been pressed.
	//

	double clickradius2 = 72.0/12;
	Point  pressed = NULL;
	int    modifiers = 0;

	//
	// Theses two definitions mean the editable cells in the table will
	// accept DnD drops. Unfortunately the Yoix interpreter's JTable code
	// needed some changes to make sure DnD also worked in the components
	// (e.g., a JTextField) that are used to support editing, so you need
	// version 2.3.1-beta12 or later for full DnD support.
	//
	// NOTE - right now drag out of a cell editor doesn't currently work,
	// at least not when the editor is an internal Swing component, like
	// a JTextField.
	//

	Function dragGestureRecognized = DragGestureRecognized;		// force cellwise drags
	Function dragEnter = DragEnter;
	Function drop = Drop;

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JTable that's going to be used as an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	int    required = TRUE;
	int    is_edit_table = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	//
	// The original_columns field is a kludge that makes sure we have a
	// copy of the columns used to create the JTable so any extra fields
	// added to the JTableColumns don't disappear and can be used later
	// on. It has to be initialized before the JTable is created, so the
	// code that handles the assignment can't run in Initialize(), as you
	// might expect. Instead the official JTable constructors have been
	// modified to look for a NULL original_columns and when found assign
	// columns to it, thus preserving a snapshot of the columns array.
	//
	// NOTE - the real solution would turn the JTableColumns defined in
	// the columns array into "active components" that stick around and
	// can be queried or used to manipulate the table's JTableColumns.
	//

	Array original_columns = NULL;
	int   column_count = 0;

	//
	// If collectflags is nonnegative it determines how the data that's
	// sent to the server is collected, otherwise loadedflags, which is
	// set based on the data received from the server, is used. A value
	// that's 0 means rows with inputfilter delimited columns, a value
	// of 2 means a complete xml representation of the table, while 1
	// is a hybrid with xml delimited rows that use inputfilter as the
	// column delimiter.
	//
	// NOTE - collectflags probably should be set to 2 (i.e., full XML)
	// whenever the edit component includes columns that represent files
	// that the user may want to upload to the server, becaus that's the
	// only setting that will make CollectEdits() include the content of
	// files in the data that's returned to the sender. We should think
	// about forcing it whenever there's a column with isdocument set to
	// TRUE - think about it tonight.
	//

	int collectflags = -1;		// can be set by edit components
	int loadedflags = 0;

	//
	// We keep a snapshot of the values initially loaded in the table
	// and we maintain a count of the number of invalid table cells.
	//

	Array initial_cell_strings = NULL;
	Array modified_cell_states = NULL;
	int   initial_row_count = 0;
	int   current_row_count = 0;
	int   invalid_cell_count = 0;
	int   modified_cell_count = 0;
	int   first_data_row = 0;
	int   first_data_column = 0;

	//
	// The text representation of an empty row that can be used when we
	// append rows to the table.
	//

	String empty_row;

	//
	// We save the original foreground and background specified in the
	// table columns so they're easily available whenever we build the
	// arrays that we use to set a column's cellcolors.
	//

	Array tablecolumn_foregrounds;
	Array tablecolumn_backgrounds;

	//
	// Unfortunately it looks like the table's cellcolors field applies
	// to rows rather than individual cells in the table, so we have to
	// manage individual cell colors by column and set them using the
	// SET_COLUMN_FIELD builtin. The column_foregrounds array is loaded
	// with an array for each column that specifies the foreground color
	// for each row in that column. Cell entries in the array can also
	// be used for validity checks because NULL entries are supposed to
	// mean ValidateCell() returned TRUE. The column_backgrounds array
	// is only needed to highlight empty cells that are invalid because
	// in that case there's nothing to paint using the cell's foreground
	// color.
	//

	Array column_foregrounds;
	Array column_backgrounds;
	Array column_selected_backgrounds;

	//
	// The invalid_cell_flags can be used to determine how invalid cells
	// are marked. The choices, right now are 0 and 1.
	// 

	int invalid_cell_flags = 0x07;

	//
	// Rows in the table are associated with an integer called the rowid
	// that's stored in the state maintained by the editor and used to
	// support operations, like undo and redo. In some situations rowid
	// is equivalent to the row's index in the view model, but there's
	// no guarantee that's always the case. Anyway, rowidmap is used to
	// map a rowid to the row's index in the values matrix, which gets
	// harder when arbitrary row deletions are involved.
	//

	Array rowidmap = NULL;

	//
	// All table columns that are supposed to behave like radio buttons
	// should define a radiobutton field that's TRUE. Initialize() looks
	// through the saved copy of the table's columns array looking for
	// the radiobutton field and builds the radiobuttons array.
	// 

	Array radiobuttons = NULL;

	//
	// Setting synctable to FALSE during loading lets us skip SyncTable()
	// calls that may be unnecessary.
	//

	int synctable = TRUE;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	Function CancelMousePressed = TableCancelMousePressed;
	Function mouseDragged = TableMouseDragged;
	Function mousePressed = TableMousePressed;
	Function mouseReleased = TableMouseReleased;
	Function GetFieldsByTag = TableGetFieldsByAppTag;

	//
	// An important assumption, necessary for reliable undo/redo support,
	// is that every change made to a table cell editor results in a call
	// to exactly one of the next three event handlers. Each of the event
	// handlers is responsible for updating the appropriate cell and the
	// other data structures used by the edit component by making a call
	// to HandleCellChange(). In other words, the contents of table cell
	// editor and cell that's being edited should be identical after the
	// appropriate event handler has finished its work. Unfortunately all
	// three event handlers are really required!!
	//

	invocationEdit(e) {
	    int row;
	    int column;

	    //
	    // This is needed to handle changes made to a BOOLEAN_TYPE cell
	    // or to a cell that uses a JComboBox as its editor. It shouldn't
	    // be called when the editor is a JTextField because each typed
	    // character generates a call to invocationEditKey(), which makes
	    // sure the contents of the editor and cell match.
	    //
	    // NOTE - restoring e.oldtext before the HandleCellChange() call
	    // is a real kludge that's only supposed to make sure functions
	    // that are called by SetValue() (e.g., LoadTableCell()) detect
	    // when cell data transitions from valid to invalid or invalid to
	    // valid so they can update counts and colors. The kludge doesn't
	    // seem to be noticeable, but there are alternatives. For example,
	    // change ValidateCell() so it accepts the cell's old cell value
	    // as an optional argument and only reads the cell when the old
	    // cell value isn't supplied. Hard part proably is making sure
	    // old data gets passed through to all appropriate functions. We
	    // probably will implement this in the near future - until then
	    // this kludge should be sufficient.
	    //
	    // NOTE - the kludge indirectly depends on the fact that we don't
	    // trigger a call to this event handler when text is typed into
	    // the JTextField used for cell edits because invocationEditKey()
	    // calls HandleCellChange() which makes sure the underlying cell
	    // is synced to the editor. In other words the Java code that the
	    // interpreter uses to manage JTables should believe the cell is
	    // up to date when editing is stopped and should skip the call to
	    // this function. Enforcing that behavior required a small fix to
	    // the method YoixSwingJTable.checkAndSetValueAt() that was made
	    // on 10/24/10.
	    //
	    // NOTE - recently added a test to HandleCellChange() that makes
	    // sure the old and new values are really different before doing
	    // anything. I didn't think about whether the HandleCellChange()
	    // change means the assumption mentioned in the previous NOTE is
	    // still necessary.
	    //

	    row = e.valuesRow;
	    column = e.valuesColumn;
	    action(SET_FIELD, row, column, e.oldtext);		// kludge!!
	    HandleCellChange(row, column, FormatForCell(e.text, row, column), e.oldtext);
	}

	invocationEditKey(e) {
	    String value;
	    String edited;
	    int    row;
	    int    column;

	    if (e.keyevent == KEYTYPED) {
		row = e.valuesRow;
		column = e.valuesColumn;
		edited = action(EDIT_GET_FIELD);
		if ((value = FormatForCell(edited, row, column)) !== edited)
		    action(EDIT_SET_FIELD, value);
		HandleCellChange(row, column, value, action(GET_FIELD, row, column));
	    }
	}

	invocationEditImport(e) {
	    String value;
	    int    row;
	    int    column;

	    //
	    // This is a realtively new event handler that was needed to make
	    // sure a Yoix script can get notified whenever the user changes
	    // a cell editor using a DnD or copy and paste operation. Support
	    // for this event handler appeared in release 2.3.1-beta12.
	    //

	    row = e.valuesRow;
	    column = e.valuesColumn;
	    if ((value = FormatForCell(e.text, row, column)) !== e.text)
		action(EDIT_SET_FIELD, value);
	    HandleCellChange(row, column, value, action(GET_FIELD, row, column));
	}

	invocationSelection(e) {
	    Dictionary selection;
	    int        index;

	    if ((e.modifiers & BUTTON1_MASK) != 0) {
		if ((index = indexOfObject(activecolumns, e.valuesColumn)) >= 0) {
		    if (pressed != NULL) {
			if (defined(visitedtag, tags))
			    action(SET_FIELD, e.valuesRow, tags[visitedtag], 1);
			selection = new Dictionary {
			    int    row = e.valuesRow;
			    int    column = e.valuesColumn;
			    int    modifiers = e.modifiers;
			    String key = tags[activecolumns[index]]@nameof;
			    String arg = action(GET_FIELD, e.valuesRow, e.valuesColumn);
			};
			if (defined("HandleSelection"))
			    invokeLater(&HandleSelection, selection, this);
			else if (defined("HandleSelection", root))
			    invokeLater(&root.HandleSelection, selection, this);
		    }
		}
		pressed = NULL;
		selectionbackground = NULL;
	    }

	    SyncEditColors(e.valuesRow, e.valuesColumn);
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	AfterTableChange() {
	    //
	    // This function is called after the table is changed, either
	    // because new data was loaded or a cell was edited, and should
	    // be customized by applications that need to initialize things
	    // (e.g., cell dependent tooltips) that may have changed.
	    //
	    // NOTE - we eventually may want an argument that provides more
	    // info about what changed.
	    //
	}

	CancelEdit() {
	    SetValue(NULL, TRUE);
	}

	CollectEdits() {
	    Dictionary fields;
	    Dictionary document;
	    Object     tablecolumn;
	    String     edits;
	    String     name;
	    String     value;
	    String     message;
	    Array      unreadable;
	    Array      records;
	    int        errors;
	    int        flags;
	    int        next;
	    int        row;
	    int        column;

	    action(EDIT_STOP);

	    if (IsModified()) {
		flags = (collectflags < 0) ? loadedflags : collectflags;
		if (flags & 0x03) {
		    records = new Array[2*current_row_count];
		    next = 0;
		    for (ptr in rowidmap) {
			if ((row = rowidmap[ptr@offset]) >= 0) {
			    records[next++] = "row";
			    if (flags & 0x02) {
				fields = new Dictionary[0, ...];
				for (ptr in datatags) {
				    column = ptr[0];
				    tablecolumn = original_columns[column];
				    name = ptr[0]@nameof;
				    value = action(GET_FIELD, row, column);
				    if (defined("isdocument", tablecolumn) && tablecolumn.isdocument) {
					document = new Dictionary {
					    String path = value;
					    String content = NULL;
					};
					if (IsCellModified(row, column)) {
					    if ((document.content = GetDocument(document.path)) == NULL) {
						if (unreadable == NULL)
						    unreadable = new Array[0, ...];
						unreadable[unreadable@sizeof] = document.path;
						unreadable[unreadable@sizeof] = row;
						unreadable[unreadable@sizeof] = column;
						errors++;
					    } else {
						if (defined("DocumentEncoder", tablecolumn)) {
						    if (tablecolumn.DocumentEncoder instanceof Callable)
							document.content = tablecolumn.DocumentEncoder(document.content);
						}
					    }
					}
					fields[name] = document;
				    } else fields[name] = value;
				}
				records[next++] = fields;
			    } else records[next++] = action(GET_ROW, row);
			}
		    }
		    edits = yoixToXML(records, FALSE, "");
		} else edits = GetText();
	    } else edits = NULL;

	    if (errors > 0) {
		message = strfmt("The %s\n\n", (errors == 1) ? "file" : "files");
		for (ptr in unreadable by 3)
		    message += strfmt("    %s\n\n", ptr[0]);
		message += strfmt("%s unreadable.", (errors == 1) ? "is" : "are");
		message += strfmt(" Fix the %s and then try again.\n", (errors == 1) ? "mistake" : "mistakes");
		ShowComponent(this, root.components);
		action(EDIT_START, unreadable[1], unreadable[2]);
		ShowError(this, message);
		abort(strfmt("CollectEdits() aborted in table %s because of unreadable files\n", tag));
	    }

	    return(edits);
	}

	CollectSideEffects(int row, int column, String newtext, String oldtext) {
	    String encoded;
	    int    counter = 0;
	    int    n;

	    if (row >= 0) {
		if (column >= 0) {
		    if (radiobuttons[column]) {
			if (ToBoolean(newtext)) {
			    newtext = "false";
			    for (n = 0; n < current_row_count; n++) {
				if (n != row) {
				    oldtext = action(GET_FIELD, n, column);
				    if (ToBoolean(oldtext)) {
					if (counter++ == 0)
					    encoded = "<sideeffects>";
					encoded += strfmt("<cell_%d>", counter);
					encoded += DataToXML(n, column, newtext, oldtext);
					encoded += strfmt("</cell_%d>", counter);
				    }
				}
			    }
			    if (counter)
				encoded += "</sideeffects>";
			}
		    }
		} else {
		    //
		    // Eventually may want to handle row additions here, but
		    // it's probably not urgent because right now we only add
		    // "empty" rows. Code would have to collect side effects
		    // from every column that behaves like a radio button.
		    // 
		}
	    }
	    return(encoded);
	}

	CountInvalidCells() {
	    int invalids = 0;
	    int row;
	    int column;

	    for (row = 0; row < current_row_count; row++) {
		for (column = 0; column < column_count; column++) {
		    if (!IsCellValid(row, column))
			invalids++;
		}
	    }
	    return(invalids);
	}

	DataToXML(int row, int column, String newtext, String oldtext) {
	    String encoded;
	    int    rowid = MapRowToRowid(row);

	    encoded = strfmt("<rowid>%d</rowid><column>%d</column><text>%s</text>", rowid, column, yoixToXML(newtext));
	    if (oldtext != NULL)
		encoded += "<oldtext>" + yoixToXML(oldtext) + "</oldtext>";
	    return(encoded);
	}

	DecodeData(String encoded) {
	    Dictionary decoded = NULL;
	    Dictionary dict;

	    if ((dict = xmlToYoix(encoded)) != NULL) {
		if (defined("encoded", dict) && dict.encoded instanceof Dictionary) {
		    dict = dict.encoded;
		    if (defined("rowid", dict) && defined("column", dict) && defined("text", dict)) {
			decoded = new Dictionary {
			    String text = dict.text;
			    String oldtext = defined("oldtext", dict) ? dict.oldtext : NULL;
			    int    rowid = atoi(dict.rowid);
			    int    column = atoi(dict.column);
			    Object sideeffects = defined("sideeffects", dict) ? dict.sideeffects : NULL;
			};
			for (ptr in decoded.sideeffects) {
			    dict = ptr[0];
			    ptr[0] = new Dictionary {
				String text = dict.text;
				String oldtext = defined("oldtext", dict) ? dict.oldtext : NULL;
				int    rowid = atoi(dict.rowid);
				int    column = atoi(dict.column);
				Object sideeffects = NULL;
			    };
			}
		    }
		}
	    }
	    return(decoded);
	}

	EncodeData(int row, int column, String newtext, String oldtext) {
	    String encoded;
	    int    rowid = MapRowToRowid(row);

	    encoded = "<encoded>";
	    encoded += DataToXML(row, column, newtext, oldtext);
	    encoded += CollectSideEffects(row, column, newtext, oldtext);
	    encoded += "</encoded>";
	    return(encoded);
	}

	FormatForCell(String value, int row, int column) {
	    Object formatter;

	    if (row >= 0 && row < current_row_count) {
		if (column >= 0 && column < column_count) {
		    if (defined("formatter", original_columns[column])) {
			formatter = original_columns[column].formatter;
			if (formatter instanceof Function) {
			    switch (formatter@length) {
				case 1:
				    value = formatter(value);
				    break;

				case 2:
				    value = formatter(value, column);
				    break;

				case 3:
				    value = formatter(value, row, column);
				    break;
			    }
			}
		    }
		}
	    }
	    return(value);
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetDocument(String path) {
	    String document;
	    Stream stream;

	    if (path != NULL) {
		if (!isDirectoryPath(path)) {
		    if ((stream = open(path, "r")) != NULL) {
			document = readStream(stream);
			close(stream);
		    }
		}
	    }
	    return(document);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetText() {
	    String value = NULL;
	    String line;
	    int    row;

	    //
	    // Adding and deleting rows can affect their order in the values
	    // matrix, which in turn affects where they appear when the text
	    // field is read. Instead of reading the table's text field this
	    // function uses rowidmap to make sure the order of rows in the
	    // string that we return reflects the order in which they first
	    // appeared.
	    //

	    for (ptr in rowidmap) {
		if ((row = rowidmap[ptr@offset]) >= 0) {
		    if ((line = action(GET_ROW, row)) != NULL)
			value += line + "\n";
		}
	    }
	    return(value);
	}

	GetValue() {
	    //
	    // We assume that data stored in the table is always formatted
	    // properly, so no formatting is required here.
	    //
	    // NOTE - this assumption may mean LoadTable() should make sure
	    // it's a valid assumption. If there's no formatting of the data
	    // initially loaded in the table then we're implicitly assuming
	    // everything received from the server is valid, which may not
	    // be a bad assumption. Think about it some!!
	    // 

	    SyncState();
	    return(EncodeData(-1, -1, GetText(), NULL));
	}

	HandleAppendRow(String value) {
	    String data;
	    int    row;

	    try {
		action(EDIT_STOP);
		row = current_row_count;
		data = EncodeData(row, -1, value@sizeof ? value : empty_row, "");
		if (editor != NULL)
		    editor.AfterEdit(tag, data);
		else SetValue(data);
	    }
	    catch(e) {}
	}

	HandleCellChange(int row, int column, String value, String oldvalue) {
	    String data;

	    //
	    // Assumption here is that the user changed the contents of the
	    // cell by typing or an operation like DnD, so we want to make
	    // sure changes are properly recorded for any future Undo/Redo
	    // operations.
	    //
	    // NOTE - the test that compares value and oldvalue is new and
	    // was initially added because changing a JCheckBox cell editor
	    // by a keystroke (i.e., typing a space when it has the focus)
	    // resulted in invocationEditKey() and invocationEdit() calls,
	    // which violated some of our initial assumptions and resulted
	    // in unnecessary states being saved on the stack. Adding the
	    // test is reasonable and eliminates the unnecessary state, but
	    // I'm not convinced the behavior of the Yoix JTable Java code
	    // is completely correct - eventually should investigate more.
	    //
	    // NOTE - selectionmark is a field that was recently added to
	    // JTableColumns. If it's not NULL the JTable Java code makes
	    // sure it's displayed in the selected rows in that column and
	    // that code also makes sure the column isn't editable, so any
	    // changes to the column come from the JTable Java code and not
	    // the user. That means we shouldn't call AfterEdit() because we
	    // definitely don't want them saved as state changes that would
	    // be subject to undo/redo operations. Bit of a kludge, but it's
	    // probably OK for now.
	    //

	    try {
		if (value !== oldvalue) {
		    data = EncodeData(row, column, value, oldvalue);
		    if (editor != NULL) {
			if (original_columns[column].selectionmark == NULL)
			    editor.AfterEdit(tag, data);
			else SetValue(data);
		    } else SetValue(data);
		    SyncEditColors(row, column);
		}
	    }
	    catch(e) {}
	}

	HandleDeleteRow(int row) {
	    String value;
	    String data;
	    int    rowid;

	    //
	    // The supplied row must be in the values matrix - any required
	    // conversion to the table view (e.g., as used in DELETE_ROWS)
	    // will be handled elsewhere.
	    //

	    try {
		value = action(GET_ROW, row, FALSE, TRUE);
		if (value@sizeof > 0) {
		    action(EDIT_STOP);
		    data = EncodeData(row, -1, "", value);
		    if (editor != NULL)
			editor.AfterEdit(tag, data);
		    else SetValue(data);
		    //
		    // We could run into a JTable bug if we don't choose a
		    // selected cell using SET_CELL_SELECTION. In this case
		    // I'm not sure what the choice should be when the row
		    // that we're deleting contains the selected cell. Need
		    // to think about it - suspect the right answer is to
		    // fix YoixSwingJTable.java so it doesn't complain when
		    // changeSelection() is called with an invalid row.
		    //
		}
	    }
	    catch(e) {}
	}

	HandleDeleteSelectedRow(int confirm) {
	    Array selections;

	    //
	    // We currently assume single selection mode.
	    //

	    selections = action(GET_ROW_SELECTION);
	    if (selections@sizeof > 0) {
		if (!confirm || ShowConfirm(root, DELETE_SELECTED_TABLE_ROW).confirmed)
		    HandleDeleteRow(selections[0].valuesRow);
	    }
	}

	Initialize() {
	    Object value;
	    String sep;
	    int    column;

	    //
	    // Fairly standard table initialization followed by important
	    // stuff that's required by this edit component.
	    //

	    TableInitializer(this);
	    BuildTableTags(this);
	    if (defined("SyncToolTipText", this))
		SyncToolTipText();

	    column_count = columns@sizeof;
	    radiobuttons = new Array[column_count];
	    datatags = new Dictionary[0, ...];
	    first_data_row = -1;	// unnecessary - it's not changed in the loop
	    first_data_column = -1;
	    selection_mark_count = 0;

	    for (ptr in original_columns) {
		column = ptr@offset;
		if (defined("editor", ptr[0])) {
		    value = ptr[0].editor;
		    if (value instanceof Array || value instanceof JComboBox) {
			if (value instanceof Array) {
			    value = new JComboBox {
				Array labels[] = value;
				int   edit = FALSE;
			    };
			}
			if (value.edit)
			    value.selected = NULL;
			else value.selected = 0;
			action(SET_EDITOR_BOX, column, value);
		    }
		}
		if (defined("radiobutton", ptr[0]) && ptr[0].radiobutton) {
		    //
		    // Eventually could expand this to other types, but right
		    // now there are a few places that assume a BOOLEAN_TYPE
		    // column.
		    //
		    if (ptr[0].type == BOOLEAN_TYPE)
			radiobuttons[column] = TRUE;
		    else radiobuttons[column] = FALSE;
		} else radiobuttons[column] = FALSE;

		if (defined("datatag", ptr[0]) && ptr[0].datatag instanceof String)
		    datatags[ptr[0].datatag] = column;

		if (ptr[0].selectionmark == NULL) {
		    if (first_data_column < 0)
			first_data_column = column;
		} else if (ptr[0].visible)
		    selection_mark_count++;

		if (collectflags < 0) {
		    if (defined("isdocument", ptr[0]) && ptr[0].isdocument)
			collectflags = 0x02;
		}
	    }

	    first_data_row = max(0, first_data_row);
	    first_data_column = max(0, first_data_column);

	    if (selection_color_model < 0)
		selection_color_model = (selection_mark_count > 0) ? 1 : 2;

	    tablecolumn_foregrounds = new Array[column_count];
	    tablecolumn_backgrounds = new Array[column_count];
	    for (column = 0; column < column_count; column++) {
		tablecolumn_foregrounds[column] = NULL;
		tablecolumn_backgrounds[column] = NULL;
	    }

	    for (ptr in activecolumns)
		tablecolumn_foregrounds[ptr[0]] = action(GET_COLUMN_FIELD, ptr[0], "foreground");

	    sep = inputfilter;
	    value = "";
	    for (column = 0; column < column_count - 1; column++)
		value += sep;
	    empty_row = value;
	}

	IsCellEmpty(int row, int column) {
	    int empty = TRUE;

	    //
	    // Right now this should only be used to decide whether the cell
	    // displays anything that is affected when the cell's foreground
	    // color is changed.
	    //

	    switch (types[column]) {
		case BOOLEAN_TYPE:
		case ICON_TYPE:
		    empty = TRUE;
		    break;

		default:
		    try {
			empty = trim(action(GET_FIELD, row, column))@length == 0;
		    }
		    catch(e) {
			empty = TRUE;
		    }
		    break;
	    }
	    return(empty);
	}

	IsCellModified(int row, int column) {
	    int rowid;
	    int modified;

	    if (row >= 0 && row < current_row_count && column >= 0 && column < column_count) {
		if ((rowid = MapRowToRowid(row)) >= 0 && rowid < initial_row_count)
		    modified = modified_cell_states[row][column];
		else modified = TRUE;
	    } else modified = FALSE;

	    return(modified);
	}

	IsCellValid(int row, int column) {
	    return(ValidateCell(row, column));
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(current_row_count == 0);
	}

	IsEncoded(String value) {
	    return(value =~ "^([0-9][0-9]*,[0-9][0-9]*):");
	}

	IsModified() {
	    return(modified_cell_count > 0);
	}

	IsNewRow(int row) {
	    int rowid;

	    return((rowid = MapRowToRowid(row)) >= 0 && rowid >= initial_row_count);
	}

	IsSelectionMarkColumn(int column) {
	    return(original_columns[column].selectionmark != NULL);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			switch (Validate@length) {
			    case 0:
				valid = Validate();
				break;

			    case 1:
				valid = Validate(this);
				break;

			    default:
				valid = FALSE;
				break;
			}
		    } else valid = FALSE;
		} else valid = ((current_row_count > 0 || !required) && invalid_cell_count == 0);
	    } else valid = TRUE;
	    return(valid);
	}

	LoadData(Object data) {
	    String value;
	    String sep;
	    Array  fields;
	    int    index;

	    synctable = FALSE;
	    loadedflags = 0x00;

	    if (data != NULL) {
		if (!(data instanceof String)) {
		    sep = inputfilter;
		    data = xmlToYoix(yoixToXML(data), 0);	// force array model
		    if (data instanceof Array) {
			for (ptr in data by 2) {
			    if (ptr[0] === "row") {
				loadedflags |= 0x01;
				if (ptr[1] instanceof String || ptr[1] instanceof Array) {
				    if (value != NULL)
					value += "\n";
				    if (ptr[1] instanceof Array) {
					fields = new Array[column_count];
					for (ptr in ptr[1] by 2) {
					    if (defined(ptr[0], datatags)) {
						fields[datatags[ptr[0]]] = ptr[1];
						loadedflags |= 0x02;
					    }
					}
					value += strjoin(fields, inputfilter, TRUE);
				    } else value += ptr[1];
				}
			    }
			}
			SetValue(value, TRUE);
		    }
		} else SetValue(data, TRUE);
	    } else SetValue(data, TRUE);

	    synctable = TRUE;
	    SyncTable();
	}

	LoadTable(String value) {
	    Array records;
	    int row;
	    int column;

	    //
	    // We eventually may want to make sure formatters that might be
	    // applied in FormatForCell() are applied to strings that are
	    // initially loaded in the table. Skipping the step means we're
	    // assuming all data received from the server is formatted the
	    // way we expect. Probably OK for starters, but I suspect we'll
	    // eventually want to address the issue.
	    //
	    // NOTE - an older version saved the text that was loaded here,
	    // but it doesn't look like it was needed so we no longer bother.
	    //

	    initial_cell_strings = GetLoadableTableRecords(value, outputfilter[0]);
	    initial_row_count = initial_cell_strings@sizeof;
	    current_row_count = initial_row_count;

	    modified_cell_count = 0;
	    modified_cell_states = new Array[initial_row_count];
	    for (row = 0; row < initial_row_count; row++) {
		modified_cell_states[row] = new Array[column_count];
		for (ptr in modified_cell_states[row])
		    ptr[0] = FALSE;
	    }

	    rowidmap = new Array[initial_row_count, ...];
	    for (row = 0; row < initial_row_count; row++)
		rowidmap[row] = row;

	    values = initial_cell_strings;
	    SyncTable();
	}

	LoadTableCell(Dictionary data, int select) {
	    Dictionary cell;
	    Array      foregrounds;
	    Array      backgrounds;
	    Array      selectedbackgrounds;
	    Color      tableselectionbackground;
	    Color      defaultselectionbackground;
	    int        flags;
	    int        row;
	    int        column;
	    int        wasvalid;
	    int        wasempty;
	    int        isvalid;
	    int        isempty;

	    foregrounds = column_foregrounds;
	    backgrounds = column_backgrounds;
	    selectedbackgrounds = column_selected_backgrounds;
	    flags = invalid_cell_flags & 0x07;

	    if (foregrounds != NULL && backgrounds != NULL && selectedbackgrounds != NULL) {
		row = MapRowidToRow(data.rowid);
		column = data.column;
		wasvalid = IsCellValid(row, column);
		wasempty = IsCellEmpty(row, column);
		action(SET_FIELD, row, column, data.text);
		isvalid = IsCellValid(row, column);
		isempty = IsCellEmpty(row, column);
		tableselectionbackground = this.selectionbackground;
		if (selection_color_model)
		    defaultselectionbackground = (selection_color_model == 2 || IsSelectionMarkColumn(column)) ? tableselectionbackground : NULL;
		else defaultselectionbackground = NULL;
		UpdateModifiedCellCount(data, 0);

		if (isvalid != wasvalid || isempty != wasempty) {
		    if (isvalid != wasvalid)
			invalid_cell_count += wasvalid ? 1 : -1;
		    switch (flags) {
			case 0:
			    foregrounds[column][row] = tablecolumn_foregrounds[column];
			    backgrounds[column][row] = tablecolumn_backgrounds[column];
			    selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 1:
			    foregrounds[column][row] = isvalid ? tablecolumn_foregrounds[column] : GetPreferredInvalidComponentForeground();
			    backgrounds[column][row] = tablecolumn_backgrounds[column];
			    selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 2:
			    foregrounds[column][row] = tablecolumn_foregrounds[column];
			    backgrounds[column][row] = isvalid ? tablecolumn_backgrounds[column] : GetPreferredInvalidTableCellSelectedBackground();
			    selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 3:
			    foregrounds[column][row] = isvalid ? tablecolumn_foregrounds[column] : GetPreferredInvalidComponentForeground();
			    backgrounds[column][row] = !isvalid && isempty ? GetPreferredInvalidTableCellBackground() : tablecolumn_backgrounds[column];
			    selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 4:
			    foregrounds[column][row] = tablecolumn_foregrounds[column];
			    backgrounds[column][row] = tablecolumn_backgrounds[column];
			    if (selection_color_model == 2)
				selectedbackgrounds[column][row] = isvalid ? defaultselectionbackground : GetPreferredInvalidTableCellSelectedBackground();
			    else selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 5:
			    foregrounds[column][row] = isvalid ? tablecolumn_foregrounds[column] : GetPreferredInvalidComponentForeground();
			    backgrounds[column][row] = tablecolumn_backgrounds[column];
			    if (selection_color_model == 2)
				selectedbackgrounds[column][row] = isvalid ? defaultselectionbackground : GetPreferredInvalidTableCellSelectedBackground();
			    else selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 6:
			    foregrounds[column][row] = tablecolumn_foregrounds[column];
			    backgrounds[column][row] = isvalid ? tablecolumn_backgrounds[column] : GetPreferredInvalidTableCellBackground();
			    if (selection_color_model == 2)
				selectedbackgrounds[column][row] = isvalid ? defaultselectionbackground : GetPreferredInvalidTableCellSelectedBackground();
			    else selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;

			case 7:
			    foregrounds[column][row] = isvalid ? tablecolumn_foregrounds[column] : GetPreferredInvalidComponentForeground();
			    backgrounds[column][row] = !isvalid && isempty ? GetPreferredInvalidTableCellBackground() : tablecolumn_backgrounds[column];
			    if (selection_color_model == 2)
				selectedbackgrounds[column][row] = isvalid ? defaultselectionbackground : GetPreferredInvalidTableCellSelectedBackground();
			    else selectedbackgrounds[column][row] = defaultselectionbackground;
			    break;
		    }
		    //
		    // The two extra arguments in this call are used to set the
		    // selection foreground and background colors. Needs version
		    // 2.3.1-beta14 or later!!
		    //
		    action(SET_COLUMN_FIELD, column, "cellcolors", new Array {backgrounds[column], foregrounds[column], selectedbackgrounds[column], foregrounds[column]});
		}
		//
		// Old JTable documentation said row and column are
		// supposed to be indices in the values matrix, but
		// the Java code implementation seems to disagree.
		// We should fix the documentation.
		//
		if (select) {
		    //
		    // The next test was thrown in quickly after the
		    // selectionmark field was added to JTableColumns.
		    // Omit it and you will notice SHIFT-TAB keyboard
		    // traversal misbehaves. Bit of a kludge, but it's
		    // probably OK for now.
		    //
		    if (original_columns[column].selectionmark == NULL)
			action(SET_CELL_SELECTION, modelToView(row, "r"), modelToView(column, "c"));
		}
	    }
	}

	LoadTableData(Dictionary data) {
	    if (data.rowid >= 0) {
		if (data.column >= 0)
		    LoadTableCell(data, TRUE);
		else LoadTableRow(data, TRUE);
		LoadSideEffects(data.sideeffects);
	    } else LoadTable(data.text);
	    AfterTableChange();
	}

	LoadTableRow(Dictionary data, int select) {
	    Array selections;
	    int   viewrow;
	    int   row;

	    //
	    // There's lots of room for improvement here, but most probably
	    // isn't worth too much effort, at least not at this point. One
	    // obvious complaint is the positioning of appended rows, which
	    // doesn't guarantee that a deleted row will be returned to its
	    // original location. It's harder than you might expect, mostly
	    // because we use rowid and rowidmap to map integer ids that are
	    // saved in the edit stack states to rows in the table's values
	    // matrix. Modifying the table's values matrix in an attempt to
	    // improve row placement means rowidmap would also need changes.
	    // We decided not to bother, at least for now, although we did
	    // make several unsuccessful attempts. Adding a hidden column to
	    // the table that we could use to store a unique id might be a
	    // better approach. Anyway, as mentioned above, there really is
	    // room for improvement even though the current implementation
	    // does work.
	    //
	    // NOTE - unfortunately aborts in yoixConvertColumnIndexToModel()
	    // and yoixConvertColumnIndexToView() in our JTable code can be
	    // trouble and forced the order of the SyncTable() calls (which
	    // calls SyncTableView()). If you move things around you may be
	    // able to trigger the abort(), which for me happened when there
	    // wasn't a selected cell (for whatever reason) and I type some
	    // characters.
	    //

	    if ((row = MapRowidToRow(data.rowid)) >= 0) {
		viewrow = action(GET_ROW_VIEW_INDEX, row);
		if (data.text@sizeof > 0) {
		    action(APPEND_ROWS, data.text, viewrow - 1, FALSE);
		    current_row_count++;
		    UpdateModifiedCellCount(data, 1);
		    SyncTable();
		    if (select)
			action(SET_CELL_SELECTION, viewrow, first_data_column);
		} else {
		    action(DELETE_ROWS, viewrow, viewrow, FALSE);
		    RegisterRow(-1, data.rowid);
		    current_row_count--;
		    UpdateModifiedCellCount(data, -1);
		    SyncTable();
		    //
		    // Not completely convinced by this. Perhaps the selected
		    // should be preserved - here and in append. Means we get
		    // selections at the start, check the column, and use it
		    // here (and above).
		    //
		    if (select) {
			if (rows > 0) {
			    selections = action(GET_ROW_SELECTION);
			    if (selections@sizeof == 0) {
				if (viewrow < rows)
				    action(SET_CELL_SELECTION, viewrow, first_data_column);
				else action(SET_CELL_SELECTION, viewrow-1, first_data_column);
				requestfocus = TRUE;
			    }
			}
		    }
		}
	    }
	}

	LoadSideEffects(Dictionary sideeffects) {
	    Dictionary data;

	    for (ptr in sideeffects) {
		data = ptr[0];
		if (data.rowid >= 0) {
		    if (data.column >= 0)
			LoadTableCell(data, FALSE);
		    else LoadTableRow(data, FALSE);
		}
	    }
	}

	MapRowidToRow(int rowid) {
	    int row;
	    int index;
	    int n;

	    if (rowid >= 0) {
		if (rowid >= rowidmap@sizeof) {		// probably unnecessary
		    for (n = rowidmap@sizeof; n <= rowid; n++)
			rowidmap[n] = -1;
		}
		if ((row = rowidmap[rowid]) < 0) {
		    rowidmap[rowid] = values@sizeof;
		    row = rowidmap[rowid];
		}
	    } else row = -1;
	    return(row);
	}

	MapRowToRowid(int row) {
	    int rowid;

	    if (row >= 0) {
		if ((rowid = indexOfObject(rowidmap, row)) < 0)
		    rowid = RegisterRow(row, -1);
	    } else rowid = -1;
	    return(rowid);
	}

	PickCellColorFromColumnColors(int row, int column, Array colors) {
	    Color color = NULL;

	    if (column >= 0 && column < colors@sizeof) {
		colors = colors[column];
		if (row >= 0 && row < colors@sizeof)
		    color = colors[row];
	    }
	    return(color);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	RegisterRow(int row, int rowid) {
	    int target;

	    if (rowid < rowidmap@sizeof) {		// should always be true!!
		if (rowid < 0) {
		    rowid = rowidmap@sizeof;
		    rowidmap[rowid] = -1;
		}
		if (rowidmap[rowid] != row) {
		    if (row >= 0) {
			//
			// This loop probably is never really needed.
			//
			for (ptr in rowidmap) {
			    if (ptr[0] >= row)
				ptr[0]++;
			}
			rowidmap[rowid] = row;
		    } else {
			if ((target = rowidmap[rowid]) >= 0) {
			    for (ptr in rowidmap) {
				if (ptr[0] > target)
				    ptr[0]--;
			    }
			    rowidmap[rowid] = row;
			 }
		    }
		}
	    } else rowid = -1;

	    return(rowid);
	}

	RestoreRowBackground() {
	    Array foregrounds;
	    Array backgrounds;
	    Array selectedbackgrounds;
	    int   column;

	    foregrounds = column_foregrounds;
	    backgrounds = column_backgrounds;
	    selectedbackgrounds = column_selected_backgrounds;

	    if (foregrounds != NULL && backgrounds != NULL && selectedbackgrounds != NULL) {
		for (column = 0; column < column_count; column++)
		    action(SET_COLUMN_FIELD, column, "cellcolors", new Array {backgrounds[column], foregrounds[column], selectedbackgrounds[column], foregrounds[column]});
	    }
	}

	RestoreStates(Array states, int direction) {
	    Dictionary data;
	    String     value;
	    int        length;
	    int        index;

	    //
	    // This is only designed to handle undo/redo operations. It's
	    // needed because state information is only saved on the stack
	    // when there's a change in the table (e.g., a cell is edited).
	    // It's an approach that simplifies some things, but can make
	    // a simple undo operation harder (e.g., when the edited cell
	    // changes) and complicates undos and redos that span several
	    // states (e.g., hold SHIFT when you press the Undo or Redo
	    // buttons).
	    //

	    action(EDIT_STOP);

	    if (direction < 0) {	// was an undo operation
		length = states@sizeof - 1;
		index = 0;
	    } else {
		length = states@sizeof;
		index = 1;
	    }

	    for (; index < length; index++) {
		if ((value = states[index][tag]) != NULL) {
		    if ((data = DecodeData(value)) != NULL) {
			if (direction < 0) {
			    data.text = data.oldtext;
			    for (ptr in data.sideeffects)
				ptr[0].text = ptr[0].oldtext;
			    LoadTableData(data);
			} else LoadTableData(data);
		    } else LoadTable(value);
		} else LoadTable(value);
	    }

	    SyncState();
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetFocusToFirst() {
	    requestfocus = TRUE;
	    if (current_row_count > 0)
		action(SET_CELL_SELECTION, first_data_row, first_data_column);
	}

	SetRowBackground(int row, Color color) {
	    Color currentbackground;
	    Color currentselectedbackground;
	    Array foregrounds;
	    Array backgrounds;
	    Array selectedbackgrounds;
	    int   column;

	    //
	    // This doesn't currently make permanent changes to the colors
	    // stored in column_backgrounds and column_selected_backgrounds,
	    // so it should only be used for very temporary changes to the
	    // background color of an entire row. Right now it's only used
	    // to highlight the selected row when a cell in an active column
	    // is pressed (see TableMousePressed()).
	    //

	    foregrounds = column_foregrounds;
	    backgrounds = column_backgrounds;
	    selectedbackgrounds = column_selected_backgrounds;

	    if (foregrounds != NULL && backgrounds != NULL && selectedbackgrounds != NULL) {
		if (row >= 0 && row < current_row_count) {
		    for (column = 0; column < column_count; column++) {
			currentbackground = backgrounds[column][row];
			currentselectedbackground = selectedbackgrounds[column][row];
			backgrounds[column][row] = color;
			selectedbackgrounds[column][row] = color;
			action(SET_COLUMN_FIELD, column, "cellcolors", new Array {backgrounds[column], foregrounds[column], selectedbackgrounds[column], foregrounds[column]});
			backgrounds[column][row] = currentbackground;
			selectedbackgrounds[column][row] = currentselectedbackground;
		    }
		}
	    }
	}

	SetValue(String value, ...) {
	    Dictionary data;

	    if (argc > 2 && argv[2])
		action(EDIT_STOP);

	    if (value != NULL) {
		if ((data = DecodeData(value)) != NULL)
		    LoadTableData(data);
		else LoadTable(value);
	    } else LoadTable(value);

	    SyncState();
	}

	SyncEditColors(int row, int column) {
	    action(EDIT_SET_FOREGROUND, PickCellColorFromColumnColors(row, column, column_foregrounds));
	    action(EDIT_SET_BACKGROUND, PickCellColorFromColumnColors(row, column, column_backgrounds));
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}

	SyncTable() {
	    Array foregrounds;
	    Array backgrounds;
	    Array selectedbackgrounds;
	    Array rowforegrounds;
	    Array rowbackgrounds;
	    Array rowselectedbackgrounds;
	    Color invalidforeground;
	    Color invalidbackground;
	    Color invalidselectedbackground;
	    Color tableselectionbackground;
	    Color defaultselectionbackground;
	    int   flags;
	    int   row;
	    int   column;

	    if (synctable) {
		invalid_cell_count = 0;
		column_foregrounds = NULL;
		column_backgrounds = NULL;
		column_selected_backgrounds = NULL;
    
		foregrounds = new Array[column_count];
		backgrounds = new Array[column_count];
		selectedbackgrounds = new Array[column_count];
		invalidforeground = GetPreferredInvalidComponentForeground();
		invalidbackground = GetPreferredInvalidTableCellBackground();
		invalidselectedbackground = GetPreferredInvalidTableCellSelectedBackground();
		tableselectionbackground = this.selectionbackground;
		flags = invalid_cell_flags & 0x07;
    
		for (column = 0; column < column_count; column++) {
		    if (current_row_count > 0) {
			rowforegrounds = new Array[current_row_count];
			rowbackgrounds = new Array[current_row_count];
			rowselectedbackgrounds = new Array[current_row_count];
			if (selection_color_model)
			    defaultselectionbackground = (selection_color_model == 2 || IsSelectionMarkColumn(column)) ? tableselectionbackground : NULL;
			else defaultselectionbackground = NULL;
			for (row = 0; row < current_row_count; row++) {
			    if (!IsCellValid(row, column)) {
				switch (flags) {
				    case 0:
					rowforegrounds[row] = tablecolumn_foregrounds[column];
					rowbackgrounds[row] = tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = defaultselectionbackground;
					break;
    
				    case 1:
					rowforegrounds[row] = invalidforeground;
					rowbackgrounds[row] = tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = defaultselectionbackground;
					break;
    
				    case 2:
					rowforegrounds[row] = tablecolumn_foregrounds[column];
					rowbackgrounds[row] = tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = defaultselectionbackground;
					break;
    
				    case 3:
					rowforegrounds[row] = invalidforeground;
					rowbackgrounds[row] = IsCellEmpty(row, column) ? invalidbackground : tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = defaultselectionbackground;
					break;
    
				    case 4:
					rowforegrounds[row] = tablecolumn_foregrounds[column];
					rowbackgrounds[row] = tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = (selection_color_model == 2) ? invalidselectedbackground : defaultselectionbackground;
					break;
    
				    case 5:
					rowforegrounds[row] = invalidforeground;
					rowbackgrounds[row] = tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = (selection_color_model == 2) ? invalidselectedbackground : defaultselectionbackground;
					break;
    
				    case 6:
					rowforegrounds[row] = tablecolumn_foregrounds[column];
					rowbackgrounds[row] = invalidbackground;
					rowselectedbackgrounds[row] = (selection_color_model == 2) ? invalidselectedbackground : defaultselectionbackground;
					break;
    
				    case 7:
					rowforegrounds[row] = invalidforeground;
					rowbackgrounds[row] = IsCellEmpty(row, column) ? invalidbackground : tablecolumn_backgrounds[column];
					rowselectedbackgrounds[row] = (selection_color_model == 2) ? invalidselectedbackground : defaultselectionbackground;
					break;
    
				}
				invalid_cell_count++;
			    } else {
				rowforegrounds[row] = tablecolumn_foregrounds[column];
				rowbackgrounds[row] = tablecolumn_backgrounds[column];
				rowselectedbackgrounds[row] = defaultselectionbackground;
			    }
			}
			foregrounds[column] = rowforegrounds;
			backgrounds[column] = rowbackgrounds;
			selectedbackgrounds[column] = rowselectedbackgrounds;
		    } else {
			foregrounds[column] = NULL;
			backgrounds[column] = NULL;
			selectedbackgrounds[column] = NULL;
		    }
		    //
		    // The two extra arguments in this call are used to set the
		    // selection foreground and background colors. Needs version
		    // 2.3.1-beta14 or later!!
		    //
		    action(SET_COLUMN_FIELD, column, "cellcolors", new Array {backgrounds[column], foregrounds[column], selectedbackgrounds[column], foregrounds[column]});
		}
    
		column_foregrounds = foregrounds;
		column_backgrounds = backgrounds;
		column_selected_backgrounds = selectedbackgrounds;
		SyncTableView();
	    }
	}

	UpdateModifiedCellCount(Dictionary data, int type) {
	    int rowid;
	    int column;

	    if (data != NULL) {
		if ((rowid = data.rowid) >= 0) {
		    switch (type) {
			case -1:	// row deleted
			    if (rowid < initial_row_count) {
				for (column = 0; column < column_count; column++) {
				    if (!modified_cell_states[rowid][column])
					modified_cell_count++;
				}
			    } else modified_cell_count -= column_count;
			    break;

			case 0:		// cell changed
			    column = data.column;
			    if (rowid < initial_row_count) {
				if (initial_cell_strings[rowid][column] === data.text) {
				    if (modified_cell_states[rowid][column]) {
					modified_cell_states[rowid][column] = FALSE;
					modified_cell_count--;
				    }
				} else {
				    if (!modified_cell_states[rowid][column]) {
					modified_cell_states[rowid][column] = TRUE;
					modified_cell_count++;
				    }
				}
			    }
			    break;

			case 1:		// row added
			    if (rowid < initial_row_count) {
				for (column = 0; column < column_count; column++) {
				    if (!modified_cell_states[rowid][column])
					modified_cell_count--;
				}
			    } else modified_cell_count += column_count;
			    break;

		    }
		}
	    }
	}

	ValidateCell(int row, int column) {
	    Object validator;
	    String value;
	    int    valid;

	    if (column >= 0 && column < column_count) {
		if (defined("validator", original_columns[column])) {
		    if ((validator = original_columns[column].validator) != NULL) {
			value = action(GET_FIELD, row, column);
			if (validator instanceof String)
			    valid = (value =~ validator);
			else if (validator instanceof Regexp)
			    valid = regexp(validator, value);
			else if (validator instanceof int)
			    valid = (ToInteger(value, !validator) == validator);
			else if (validator instanceof Array)
			    valid = (indexOfObject(validator, value) >= 0);
			else if (validator instanceof Function)
			    valid = validator(value);
			else valid = FALSE;
		    } else valid = TRUE;
		} else valid = TRUE;
	    } else valid = FALSE;

	    return(valid);
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    //
    // A recent addition that automatically adds a special selection column
    // to the start of the table when there's a string named selection_mark
    // that's not NULL defined in initializer.
    //

    if (defined("columns", initializer) && initializer.columns instanceof Array) {	// should always be true
	if (defined("selection_mark", initializer) && initializer.selection_mark != NULL) {
	    if (initializer.selection_mark instanceof String) {
		initializer.columns = new Array {
		    new JTableColumn {
			String header = "";
			String alttooltiptext = "";
			String selectionmark = initializer.selection_mark;
			double width = PickTableColumnWidth(NULL, initializer.selection_mark, 72.0/8);
			int    type = STRING_TYPE;
			int    alignment = CENTER;
			int    visible = TRUE;
		    },
		    unroll(initializer.columns)
		};
	    } else if (initializer.selection_mark instanceof Array) {
		//
		// Eventually could implement this as a way of adding more
		// than one mark to the table. For example, an array with
		// two strings could mean add one as the first column and
		// the other as the last column. Not very important right
		// now so we'll wait til there's a request.
		//
	    }
	}
    }

    if (initializer.filtering)
	editor = NewJTableWithSearch(tag, inputfilter, scroll, NULL, initializer);
    else editor = NewJTable(tag, inputfilter, scroll, NULL, initializer);

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor,
		BOTH,
	    };
	};
    }
    return(editor);
}

NewJTextAreaEditComponent(String tag, String title, String text, int rows, int columns, int scroll, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    //
    // A constructor for a JTextArea edit component.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[17, ...] {
	String tag = tag;
	String text = text;
	Insets insets = GetTextAreaInsets();
	Object transferhandler = NULL;		// required for custom drag and drop
	Color  background = GetPreferredTextBackground();
	Color  foreground = GetPreferredTextForeground();
	Object font = GetPreferredTextFont();
	Object minimumsize = NULL;
	int    rows = rows;
	int    columns = columns;
	int    scroll = scroll;
	int    textwrap = 1;
	int    edit = TRUE;
	int    opaque = TRUE;
	int    caretmodel = 1;

	Function keyTyped = KeyTyped;
	Function dragGestureRecognized = DragGestureRecognized;
	Function dragEnter = DragEnter;
	Function drop = Drop;
	Function mouseReleased = MouseReleased;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JTextField that's going to be used as an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	//
	// A string used to match the characters that will be allowed in the
	// JTextArea. It's a change from the original version of the code that
	// appeared in the riddler application.
	//

	String allowed = "\n -~";	// allowing newlines is also a change

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	//
	// We want our own definition of keyPressed, but we also want to call
	// the default YWAIT version, so we have to make a copy because there
	// probably are references to "this" in the default implementation.
	//

	Function KeyPressed = KeyPressed;	// also want to call the default

	keyPressed(e) {
	    String panel_tag = tag + "_panel";
	    Object comp;

	    KeyPressed(e);
	    if (e.keycode == KeyCode.VK_TAB) {
		if (e.modifiers == SHIFT_MASK)
		    comp = getFocusComponentBefore(this, root.components[panel_tag]);
		else comp = getFocusComponentAfter(this, root.components[panel_tag]);
		if (comp != NULL)
		    comp.requestfocus = TRUE;
		else comp.requestfocus = FALSE;
	    }
	}

	textValueChanged(e) {
	    String saved;
	    String current;

	    if (editor != NULL) {
		saved = editor.PeekAtField(tag);
		current = text;
		if (current =~ "^[" + allowed + "]*$") {
		    if (saved !== current) {
			if (saved@sizeof || current@sizeof) {
			    if (editor != NULL)
				editor.AfterEdit(tag);
			}
		    }
		} else {
		    //
		    // Test assumes the user typed a tab character if the event
		    // indicates a single character was added and that character
		    // was a tab. In that case we delete it, but other tabs that
		    // we find (e.g., added via DnD) are converted to spaces. Not
		    // 100% correct, but good enough for our purposes.
		    //
		    if (e.length == 1 && e.offset > 0 && e.offset < current@sizeof - 1 && current[e.offset] == '\t')
			current = substring(current, 0, e.offset) + substring(current, e.offset + 1);
		    current = gsubsti(" ", "[^" + allowed + "]+", current);
		    text = trim(current);
		    caret = e.offset;
		}
	    }
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    text = NULL;
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetValue() {
	    String value;

	    SyncState();
	    value = text;
	    return(defined("Format", this) ? Format(value) : value);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(text@sizeof == 0);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else if (Validate@length == 1)
			    valid = Validate(text);
			else valid = FALSE;
		    } else if (!IsEmpty()) {
			if (Validate instanceof Regexp)
			    valid = regexp(Validate, text);
			else if (Validate instanceof String)
			    valid = (text =~ Validate);
			else if (Validate instanceof Array)
			    valid = (indexOfObject(Validate, text) >= 0);
			else valid = FALSE;
		    } else valid = !required;
		} else valid = (!IsEmpty() || !required);
	    } else valid = TRUE;
	    return(valid);
	}

	PickCaretPosition(String current, String next) {
	    int delta;

	    //
	    // The extra work done here is mostly designed to try to position
	    // the caret properly after undo/redo operations. Handling changes
	    // that happen because data was reformatted (by a Format function)
	    // leaves lots to be desired, but probably is sufficient for now.
	    //

	    for (; current@sizeof && next@sizeof && *current == *next; current++, next++) ;

	    if ((delta = next@sizeof - current@sizeof) >= 0)
		next += delta;
	    else current += -delta;
	    if (next@sizeof > 0 && strcmp(next, current))
		next += next@sizeof;

	    return(next@offset);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetValue(String value, ...) {
	    int next_caret;

	    if (text !== value) {
		next_caret = PickCaretPosition(text, value);
		text = value;
		caret = next_caret;
	    }
	    SyncState();
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    if (initializer.minimumsize == NULL && initializer.rows > 0) {
	JTextArea jt = {
	    Object font = initializer.font;
	    int    rows = initializer.rows;
	    int    columns = initializer.columns;
	};
	initializer.minimumsize = jt.preferredsize;
    }

    editor = new JTextArea initializer;

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor,
		BOTH,
	    };
	};
    }
    return(editor);
}

NewJTextFieldEditComponent(String tag, String title, String text, int columns, Object apptags, ...) {
    Dictionary initializer;
    Object     editor;
    Object     ptr;

    //
    // A constructor for a JTextField edit component.
    //

    tag = PickEditComponentTag(tag);

    initializer = new Dictionary[15, ...] {
	String tag = tag;
	String text = text;
	Insets insets = GetTextFieldInsets();
	Object transferhandler = NULL;		// required for custom drag and drop
	Color  background = GetPreferredTextBackground();
	Color  foreground = GetPreferredTextForeground();
	Object font = GetPreferredTextFont();
	int    autotrim = TRUE;
	int    edit = TRUE;
	int    lengthreq = 0;
	int    columns = columns;
	int    opaque = TRUE;
	int    caretmodel = 1;

	Function keyPressed = KeyPressed;
	Function keyTyped = KeyTyped;
	Function dragGestureRecognized = DragGestureRecognized;
	Function dragEnter = DragEnter;
	Function drop = Drop;
	Function mouseReleased = MouseReleased;

	//
	// Strings in the apptags array are special "application tag strings"
	// that this edit component is willing to accept when an entire row
	// in a JTable is dragged or selected by some other operation (e.g.,
	// pressing a button).
	//

	Array apptags = apptags instanceof Array ? apptags : new Array {apptags};

	//
	// If selector_builder isn't NULL a selector button will be created
	// and displayed to the right of the JTextField. The value assigned
	// to selector_builder should be the name of the builder that YWAIT
	// uses to identify the screen (e.g., "table_selector"). The value
	// that's assigned to selector_args should be a string or an array
	// of strings that are used by the screen to build the appropriate
	// selector. Check the selector screen itself for more information
	// about selector_args.
	// 

	String selector_builder = NULL;
	Object selector_args = NULL;

	//
	// These three functions are needed to support a DnD operation that
	// started by dragging an entire row out of a specially configured
	// JTable. In those tables TableDragGestureRecognized() creates a
	// dictionary transferable indexed by "application tag strings" and
	// the one that's appropriate for an edit component can be located
	// using strings defined in the apptags array.
	//

	Function DragEnterHandler = DragEnterHandlerForEditComponent;
	Function DropHandler = DropHandlerForEditComponent;
	Function SyncDropTargetEvent = SyncDropTargetEventForEditComponent;

	//
	// These are the custom variables and functions that must be defined
	// in a JTextField that's going to be used as an "edit component".
	//

	Object editor = NULL;
	String datatag = startsWith(tag, "$_") ? tag + 2 : tag;
	String defaultvalue = NULL;
	String editlabel = title;
	int    required = TRUE;
	int    is_edit_component = TRUE;
	int    is_edit_component_enabled = TRUE;

	//
	// Older versions defined an object named "validate", but we decided
	// to change the name to Validate because it often will be a function
	// and we usually try to reserve the names of callable objects that
	// start with a lowercase letter to builtins.
	//

	Object Validate = NULL;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	textValueChanged(e) {
	    String saved;

	     if (editor != NULL) {
		saved = editor.PeekAtField(tag);
	 	if (saved !== text) {
		    if (saved@sizeof || text@sizeof) {
			if (editor != NULL)
			    editor.AfterEdit(tag);
		    }
		}
	    }
	}

	////////////////////////////
	//
	// Edit Functions
	//
	////////////////////////////

	CancelEdit() {
	    text = NULL;
	    SyncState();
	}

	GetAppTags() {
	    return(apptags);
	}

	GetDataTag() {
	    return(datatag);
	}

	GetDefaultValue() {
	    return(defaultvalue);
	}

	GetEditLabel() {
	    return(editlabel);
	}

	GetInitialValue() {
	    return(GetValue());
	}

	GetValue() {
	    String value;

	    SyncState();
	    value = text;
	    return(defined("Format", this) ? Format(value) : value);
	}

	IsEditComponentEnabled() {
	    return(is_edit_component_enabled);
	}

	IsEmpty() {
	    return(text@sizeof == 0);
	}

	IsValid() {
	    int valid;

	    if (is_edit_component_enabled) {
		if (Validate != NULL) {
		    if (Validate instanceof Function) {
			if (Validate@length == 0)
			    valid = Validate();
			else if (Validate@length == 1)
			    valid = Validate(text);
			else valid = FALSE;
		    } else if (!IsEmpty()) {
			if (Validate instanceof Regexp)
			    valid = regexp(Validate, text);
			else if (Validate instanceof String)
			    valid = (text =~ Validate);
			else if (Validate instanceof Array)
			    valid = (indexOfObject(Validate, text) >= 0);
			else valid = FALSE;
		    } else valid = !required;
		} else valid = (!IsEmpty() || !required);
	    } else valid = TRUE;
	    return(valid);
	}

	PickCaretPosition(String current, String next) {
	    int delta;

	    //
	    // The extra work done here is mostly designed to try to position
	    // the caret properly after undo/redo operations. Handling changes
	    // that happen because data was reformatted (by a Format function)
	    // leaves lots to be desired, but probably is sufficient for now.
	    //

	    for (; current@sizeof && next@sizeof && *current == *next; current++, next++) ;

	    if ((delta = next@sizeof - current@sizeof) >= 0)
		next += delta;
	    else current += -delta;
	    if (next@sizeof > 0 && strcmp(next, current))
		next += next@sizeof;

	    return(next@offset);
	}

	PickInvalidForeground() {
	    return(editor != NULL ? editor.PickInvalidForeground() : NULL);
	}

	SetEnabled(int state) {
	    is_edit_component_enabled = state;
	    enabled = state;
	}

	SetValue(String value, ...) {
	    int next_caret;

	    if (text !== value) {
		next_caret = PickCaretPosition(text, value);
		text = value;
		caret = next_caret;
	    }
	    SyncState();
	}

	SyncState() {
	    String label_tag = tag + "_label";
	    String panel_tag = tag + "_panel";
	    Object border;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}
    };

    for (ptr = &apptags + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    editor = new JTextField initializer;

    if (editor.selector_builder != NULL) {
	editor = new JPanel {
	    GridBagLayout layoutmanager;
	    Array layout = {
		editor,
		HORIZONTAL,
		NewEditSelectorButton(NULL, editor.selector_builder, editor.selector_args, editor),
		NONE,
	    };
	};
    }

    if (title != NULL) {
	editor = new JPanel {
	    String tag = tag + "_panel";
	    Border border = NewEtchedBorder(title);

	    GridBagLayout layoutmanager;
	    Array layout = {
		editor,
		HORIZONTAL,
	    };
	};
    }
    return(editor);
}

////////////////////////////
//
// Edit Support
//
////////////////////////////

NewJDateDayCounter(String tag, String title, String start_tag, String end_tag, ...) {
    Dictionary initializer;
    Object     ptr;
    Object     counter;
    Object     border;
    double     width;

    //
    // An implementation of a component can be used to automatically update
    // the total number of days spanned by the start_tag and end_tag date
    // edit components, but only if our tag is assigned to their linked_tag
    // field.
    //

    initializer = new Dictionary[0, ...] {
	String tag = tag;
	String start_tag = start_tag;
	String end_tag = end_tag;
	String prototypevalue = "000";
	String prefix = NULL;
	String suffix = NULL;
	Object activeborder = NULL;
	int    mindays = MIN_INT;
	int    startdays = 1;
	int    lastdays;
	int    requestfocusenabled = TRUE;
	int    typing = FALSE;

	////////////////////////////
	//
	// Event Handlers
	//
	////////////////////////////

	focusGained(e) {
	    if (enabled && root.components[end_tag].enabled) {
		if (activeborder == NULL) {
		    activeborder = new Border {
			int    type = LINED;
			double thickness = VM.screen.pixelwidth;
			Color  background = foreground;
		    };
		}
		border = activeborder;
	    }
	}

	focusLost(e) {
	    border = NULL;
	    StopTyping();
	}

	keyPressed(e) {
	    if (enabled && root.components[end_tag].enabled) {
		switch(e.keycode) {
		    case KeyCode.VK_UP:
			SetDays(GetDays() + 1);
			if (defined("consumed", e))
			    e.consumed = TRUE;
			break;

		    case KeyCode.VK_DOWN:
			SetDays(GetDays() - 1);
			if (defined("consumed", e))
			    e.consumed = TRUE;
			break;
		}
	    }
	}

	keyTyped(e) {
	    String text;
	    
	    if (enabled && root.components[end_tag].enabled) {
		if (StartTyping()) {
		   text = trim(this.text);
		   switch (e.keystring) {
			case "\n":
			    StopTyping();
			    break;

			case "\b":
			    if (text@sizeof > 0)
				this.text = new String[text@sizeof - 1] text;
			    break;

			default:
			    this.text = text + e.keystring;
			    break;
		   } 
		}
	    }
	}

	mouseEntered(e) {
	    if (root.components[end_tag].enabled)
		requestfocus = TRUE;
	}

	mouseWheelMoved(e) {
	    double start;
	    double end;
	    int    days;

	    if (root.components[end_tag].enabled) {
		if (IsBlank())
		    SetDays(startdays);
		else SetDays(GetDays() - e.wheelrotation);
	    }
	}

	////////////////////////////
	//
	// Miscellaneous Functions
	//
	////////////////////////////

	GetDays() {
	    Calendar start;
	    Calendar end;
	    int      days;

	    if (!root.components[start_tag].IsBlank() && !root.components[end_tag].IsBlank()) {
		start.unixtime = root.components[start_tag].GetUnixtime();
		end.unixtime = root.components[end_tag].GetUnixtime();
		days = ((end.unixtime + end.dstoffset/1000) - (start.unixtime + start.dstoffset/1000))/86400;
	    } else days = startdays;
	    return(days);
	}

	GetDaysFromState(Dictionary state) {
	    Calendar start;
	    Calendar end;
	    int      days;
	
	    if (defined(start_tag, state) && defined(end_tag, state)) {
		start.unixtime = parseDate(state[start_tag], root.components[start_tag].preferred_format);
		end.unixtime = parseDate(state[end_tag], root.components[end_tag].preferred_format);
		days = ((end.unixtime + end.dstoffset/1000) - (start.unixtime + start.dstoffset/1000))/86400;
	    } else days = startdays;
	    return(days);
	}

	IsBlank() {
	    String str = trim(text);

	    return(str@sizeof == 0);
	}

	IsValid() {
	    return(root.components[end_tag].IsValid() && root.components[start_tag].IsValid());
	}

	PickInvalidForeground() {
	    return(root.components[end_tag].PickInvalidForeground());
	}

	SetDays(int days) {
	    Calendar cal;

	    if (days < mindays)
		days = mindays;

	    if (!(defined("owner", this) && defined("AfterUpdate", this.owner) && this.owner.AfterUpdate(this, days))) {
		cal.unixtime = root.components[start_tag].GetUnixtimeForShowCalendar();
		cal.add(Calendar.DATE, days);
		root.components[end_tag].SetCalendar(cal.unixtime);
		SyncState();
	    }
	}

	StartTyping() {
	    if (!typing) {
		lastdays = GetDays();
		text = "";
		typing = TRUE;
	    }
	    return(typing);
	}

	StopTyping() {
	    int days;

	    if (typing) {
		typing = FALSE;
		if ((days = atoi(text, 10, -1)) < 0)
		    days = lastdays;
		SetDays(days);
	    }
	}

	SyncState() {
	    Calendar start;
	    Calendar end;
	    Object   border;
	    String   label_tag = tag + "_label";
	    String   panel_tag = tag + "_panel";
	    String   value;
	    int      days;

	    //
	    // Automatically called by the AfterUpdate() function defined in
	    // the start_tag and end_tag date edit components, but only when
	    // our tag has been assigned to their linked_tag field.
	    //

	    if (!root.components[start_tag].IsBlank() && !root.components[end_tag].IsBlank()) {
		if ((days = GetDays()) < mindays)
		    days = mindays;
		if (prefix != NULL)
		    value = prefix;
		value += toString(days);
		if (suffix != NULL) {
		    if (suffix === "" || suffix === "day" || suffix === "days")
			value += (days != 1 && days != -1) ? " days" : " day";
		    else value += suffix;
		}
	    }
	    text = value;

	    if (defined(panel_tag, root.components)) {
		if ((border = root.components[panel_tag].border) != NULL) {
		    border.foreground = IsValid() ? NULL : PickInvalidForeground();
		    root.components[panel_tag].border = border;
		}
	    } else if (defined(label_tag, root.components))
		root.components[label_tag].foreground = IsValid() ? NULL : PickInvalidForeground();
	}
    };

    for (ptr = &end_tag + 1; ptr@sizeof > 0; ptr++) {
	if (*ptr instanceof String) {
	    if (ptr@sizeof > 1)
		initializer[*ptr] = *++ptr;
	} else if (*ptr instanceof Dictionary)
	    unroll(*ptr, initializer);
    }

    counter = NewJLabel(tag, NULL, initializer);

    //
    // Wait on this until so we can use the real font.
    //

    counter.preferredsize = new Dimension {
	double width = stringWidth(counter.font, counter.prototypevalue);
    };

    if (title != NULL) {
	border = NewEtchedBorder(title);
	counter.preferredsize = new Dimension {
	    double width = max(counter.preferredsize.width, stringWidth(border.font, title) + 72.0/16);
	};

	counter = new JPanel {
	    String tag = tag + "_panel";
	    Border border = border;

	    GridBagLayout layoutmanager;
	    Array layout = {
		counter
	    };
	};
    }

    return(counter);
}

NewLabeledEditComponent(String text, Object comp) {
    //
    // Returns a panel with a label that the edit component automatically
    // uses to indicate the validity of the contents of that component by
    // changing its foreground color. The label's tag is the key - see the
    // SyncState() function defined in all edit components.
    //

    return(new JPanel {
	int visible = comp.visible;

	GridBagLayout layoutmanager;
	Array layout = {
	    NewJLabel(comp.tag + "_label", text),
	    LEFT, NONE,
	    72.0/32,
	    comp,
	    BOTH,
	};
    });
}

NewLabeledEditComponentWithTag(String tag, String text, Object comp) {
    //
    // Returns a panel with a label that the edit component automatically
    // uses to indicate the validity of the contents of that component by
    // changing its foreground color. The label's tag is the key - see the
    // SyncState() function defined in all edit components.
    //

    return(new JPanel {
	String tag = tag;
	int    visible = comp.visible;

	GridBagLayout layoutmanager;
	Array layout = {
	    NewJLabel(comp.tag + "_label", text),
	    LEFT, NONE,
	    72.0/32,
	    comp,
	    BOTH,
	};
    });
}

//
// Unfortunately many of the edit related constructors currently need a tag
// that's not NULL to successfully build the component, so these were added
// to help when the caller doesn't explicitly set the tag. Not conviced it's
// a real kludge, but we eventaully should take a close look at constructors
// that really need this.
//

Dictionary TAGLOCK = {
    int counter = 1;
};

PickEditComponentTag(String tag) {
    if (tag == NULL) {
	synchronized(TAGLOCK) {
	    tag = "$_edit_component_" + toString(TAGLOCK.counter++);
	}
    }
    return(tag);
}

PickEditComponentTagForEditor(Object editor) {
    String tag;

    syncronized(TAGLOCK) {
	if (defined("tag", editor))
	    tag = editor.tag;
	else if (editor instanceof String)
	    tag = editor;
	if (tag == NULL)
	    tag = "$_edit_component";
	tag += tag + "_" + toString(TAGLOCK.counter++);
    }
    return(tag);
}

PickEditorTag(String tag) {
    if (tag == NULL) {
	syncronized(TAGLOCK) {
	    tag = "$_editor_" + toString(TAGLOCK.counter++);
	}
    }
    return(tag);
}
