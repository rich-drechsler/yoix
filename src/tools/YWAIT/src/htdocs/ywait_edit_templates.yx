//
// Dictionaries that constructors for edit related objects should use when
// they create new objects.
//
// NOTE - templates are used to initialize other objects, which means that
// if the template creates an object, like a dictionary, that's not NULL
// that object (i.e., it's body) will be shared by every object that was
// created using the template. Occasionally that may be what you intended,
// but it's more likely to be a bug. The bottom line is that most pointer
// variables should be initialized by one of the functions defined in the
// template.
//
// NOTE - recently made a simple change to the indexOfObject() builtin, so
// this code now needs a very recent version of the interpreter. We should
// probably add some version testing code!!
//

final Dictionary EDITSCREEN_TEMPLATE = {
    //
    // This template should be used to create a screen (e.g., a JFrame) that
    // will be used to support editing.
    //

    Object edit_manager = NULL;
    int    is_edit_screen = TRUE;

    ////////////////////////////
    //
    // Edit Screen Functions
    //
    ////////////////////////////

    CanAdvance(Object container, int model) {
	return(edit_manager.CanAdvance(container, model));
    }

    CanHideScreen(int confirm) {
	int result;

	if (visible && (HaveEdits() && HaveUnsavedWork())) {
	    if (confirm) {
		toFront(this);
		result = ShowConfirm(this, CLOSESCREEN_WITH_UNSAVED_EDITS).confirmed;
	    } else result = FALSE;
	} else result = TRUE;
	return(result);
    }

    CanLoadScreen(int confirm) {
	int result;

	if (visible && (HaveEdits() && HaveUnsavedWork())) {
	    if (confirm) {
		toFront(this);
		result = ShowConfirm(this, LOADSCREEN_WITH_UNSAVED_EDITS).confirmed;
	    } else result = FALSE;
	} else result = TRUE;
	return(result);
    }

    CanSave(int model) {
	return(edit_manager.CanSave(model));
    }

    CanSubmit(int model) {
	return(edit_manager.CanSubmit(model));
    }

    CollectData() {
	return(edit_manager.CollectData());
    }

    CollectEdits() {
	return(edit_manager.CollectEdits());
    }

    CountAllChangedEditors() {
	return(edit_manager.CountAllChangedEditors());
    }

    CountAllEdits() {
	return(edit_manager.CountAllEdits());
    }

    GetNeighborFlags(Object container) {
	return(edit_manager.GetNeighborFlags(container));
    }

    HaveEdits() {
	return(edit_manager.HaveEdits());
    }

    HaveUnsavedWork() {
	//
	// Edit screens should redefine this function when they have extra
	// checks to make before deciding if the screen can be closed or
	// reloaded.
	//
	return(FALSE);
    }

    InitializeEditScreen() {
	edit_manager = components.$_edit_manager;
	edit_manager.InitializeEditManager();
	SyncScreen();
    }

    LoadEditScreen(Object data) {
	edit_manager.LoadEditManager(data);
    }

    NextCard(Object container, int direction) {
	edit_manager.NextCard(container, direction);
    }

    SetReadOnly(int state) {
	edit_manager.SetReadOnly(state);
    }

    SyncSavedState() {
	edit_manager.SyncSavedState();
	SyncScreen();
    }

    SyncScreen() {
	//
	// A placeholder that can be customized by edit screens.
	//
    }
};

final Dictionary EDITMANAGER_TEMPLATE = {
    //
    // This template should be automatically used by edit screen constructors
    // to create a JPanel that manages the editors displayed by the screen.
    //

    Dictionary managed_datatags = NULL;
    Dictionary neighbor_flags = NULL;
    Dictionary focus_owners = NULL;
    String     tag = "$_edit_manager";
    Array      managed_editors = NULL;
    Array      managed_afterload_handlers = NULL;
    Array      managed_beforeload_handlers = NULL;
    int        managed_readonly = FALSE;
    int        is_edit_manager = TRUE;


    //
    // Several variables that are used to try to eliminate unnecessary work
    // that can be generated by SyncEditManager() calls. Added without too
    // much testing, but this seem to be working properly.
    //

    int initialized = FALSE;
    int loading = FALSE;

    ////////////////////////////
    //
    // Edit Manager Functions
    //
    ////////////////////////////

    AtSavedState() {
	int result = TRUE;

	for (ptr in managed_editors) {
	    if (!ptr[0].AtSavedState()) {
		result = FALSE;
		break;
	    }
	}
	return(result);
    }

    CanAdvance(Object container, int model) {
	Object editor;
	Object selected;
	int    count;
	int    result;

	//
	// This is designed for edit screens that use a CardLayout to present
	// editors and that call the NextCard() function that's defined below
	// to change panels.
	//

	if (model != ADVANCE_ALWAYS) {
	    if ((selected = PickCurrentCard(container)) != NULL) {
		switch (model) {
		    case ADVANCE_IS_READY:
			result = TRUE;
			for (ptr in managed_editors) {
			    editor = ptr[0];
			    if (indexOfObject(selected.components, editor, FALSE) >= 0) {
				if (editor.NotReady()) {
				    result = FALSE;
				    break;
				}
			    }
			}
			break;

		    case ADVANCE_NOT_EMPTY:
			result = FALSE;
			count = 0;
			for (ptr in managed_editors) {
			    editor = ptr[0];
			    if (indexOfObject(selected.components, editor, FALSE) >= 0) {
				count++;
				if (editor.NotEmpty() || editor.IsOptional()) {
				    result = TRUE;
				    break;
				}
			    }
			}
			result = result || (count == 0);
			break;

		    default:
			result = FALSE;
			break;
		}
	    } else result = FALSE;
	} else result = TRUE;

	return(result);
    }

    CanSave(int model) {
	return(!AtSavedState() && CanSubmit(model));
    }

    CanSubmit(int model) {
	int count;
	int result;

	//
	// Canned answers for some predefined models, but there's absolutely
	// no reason why screens have to use this function to decide whether
	// their "submit button" should be enabled or not.
	//

	switch (model) {
	    case SUBMIT_ALL_READY:
		result = TRUE;
		for (ptr in managed_editors) {
		    if (ptr[0].NotReady()) {
			result = FALSE;
			break;
		    }
		}
		break;

	    case SUBMIT_ALWAYS:
		result = TRUE;
		break;

	    case SUBMIT_ANY_CHANGED:
		result = FALSE;
		for (ptr in managed_editors) {
		    if (ptr[0].edit_count > 0) {
			result = TRUE;
			break;
		    }
		}
		break;

	    case SUBMIT_ANY_CHANGED_ALL_READY:
		count = 0;
		result = TRUE;
		for (ptr in managed_editors) {
		    if (ptr[0].NotReady()) {
			result = FALSE;
			break;
		    } else count += ptr[0].edit_count;
		}
		result = result && (count > 0);
		break;

	    case SUBMIT_ALL_CHANGED:
		result = TRUE;
		for (ptr in managed_editors) {
		    if (ptr[0].edit_count == 0) {
			result = FALSE;
			break;
		    }
		}
		break;

	    case SUBMIT_ALL_CHANGED_ALL_READY:
		result = TRUE;
		for (ptr in managed_editors) {
		    if (ptr[0].edit_count == 0 || ptr[0].NotReady()) {
			result = FALSE;
			break;
		    }
		}
		break;

	    default:
		result = FALSE;
		break;
	}

	return(result);
    }

    CollectData() {
	Object comp;
	String key;
	Object value;
	Array  collected[0, ...];

	//
	// The behavior, at least in terms of visited components, is supposed
	// mirror what's done in LoadEditManager(), but the actual collection
	// of data should look like CollectEdits().
	//
	// NOTE - older versions did this in a try/catch. Not sure why and it
	// made debugging harder, so the try/catch has been removed 
	//

	for (ptr in managed_datatags) {
	    comp = ptr[0];
	    key = ptr[0]@nameof;
	    if (defined("CollectData", comp)) {
		if (comp.CollectData != NULL)
		    value = comp.CollectData();
		else value = NULL;
	    } else if (defined("SetValue", comp))	// because LoadEditManager uses it
		value = defined("GetValue", comp) ? comp.GetValue() : NULL;
	    else value = NULL;
	    if (value != NULL) {
		collected[collected@sizeof] = key;
		collected[collected@sizeof] = value;
	    }
	}
	for (ptr in managed_editors) {
	    comp = ptr[0];
	    if (!defined("datatag", comp) || comp.datatag == NULL) {
		if ((value = comp.CollectData()) != NULL)
		    unroll(value, &collected[collected@sizeof]);
	    }
	}
	return(collected@sizeof > 0 ? collected : NULL);
    }

    CollectEdits() {
	Object editor;
	String key;
	Object value;
	Array  collected[0, ...];

	//
	// NOTE - older versions did this in a try/catch. Not sure why and it
	// made debugging harder, so the try/catch has been removed 
	//

	for (ptr in managed_editors) {
	    editor = ptr[0];
	    if ((value = editor.CollectEdits()) != NULL) {
		key = editor.GetDataTag();
		if (key@sizeof > 0) {
		    collected[collected@sizeof] = key;
		    collected[collected@sizeof] = value;
		} else unroll(value, &collected[collected@sizeof]);
	    }
	}
	return(collected@sizeof > 0 ? collected : NULL);
    }

    CountAllChangedEditors() {
	int count = 0;

	for (ptr in managed_editors) {
	    if (ptr[0].edit_count > 0)
		count++;
	}
	return(count);
    }

    CountAllEdits() {
	int count = 0;

	for (ptr in managed_editors)
	    count += ptr[0].edit_count;
	return(count);
    }

    GetNeighborFlags(Object container) {
	int flags = 0;

	if (defined("tag", container)) {
	    if (!defined(container.tag, neighbor_flags))
		SaveNeighborFlags(container);
	    flags = neighbor_flags[container.tag];
	} else flags = 0;

	return(flags);
    }

    HaveEdits() {
	int result = FALSE;

	for (ptr in managed_editors) {
	    if (ptr[0].edit_count > 0) {
		result = TRUE;
		break;
	    }
	}
	return(result);
    }

    InitializeEditManager() {
	Object comp;
	int    index;

	//
	// Looping through components the way we do here works because the
	// Yoix interpreter guarantees that a component, like a JPanel, is
	// immediately followed by the components that were defined in its
	// layout array. In other word, components that InitializeEditor()
	// or InitializePanel() claim won't also be claimed here.
	//

	initialized = FALSE;		// recent addition

	managed_datatags = new Dictionary[0, ...];
	managed_editors = new Array[0, ...];
	managed_afterload_handlers = new Array[0, ...];
	managed_beforeload_handlers = new Array[0, ...];
	neighbor_flags = new Dictionary[0, ...];
	focus_owners = new Dictionary[0, ...];

	for (index = 0; index < components@sizeof; index++) {
	    if ((comp = components[index]) != this) {		// could start at index 1
		comp = components[index];
		if (defined("datatag", comp) && comp.datatag != NULL)
		    managed_datatags[comp.datatag] = comp;
		if (defined("AfterLoad", comp))
		     managed_afterload_handlers[managed_afterload_handlers@sizeof] = comp;
		if (defined("BeforeLoad", comp))
		     managed_beforeload_handlers[managed_beforeload_handlers@sizeof] = comp;
		if (defined("is_editor", comp) && comp.is_editor) {
		    managed_editors[managed_editors@sizeof] = comp;
		    comp.SetEditManager(this);
		    comp.InitializeEditor();
		    if (defined("components", comp) && comp.components@sizeof > 1)
			index += (comp.components@sizeof - 1);
		} else if (defined("InitializePanel", comp)) {
		    //
		    // Not convinced by this!!!
		    //
		    if (comp.InitializePanel@length == 1) {
			comp.InitializePanel(this);
			if (defined("components", comp) && comp.components@sizeof > 1)
			    index += (comp.components@sizeof - 1);
		    } else comp.InitializePanel();
		}
	    }
	}
	initialized = TRUE;
    }

    LoadEditManager(Object data) {
	Object comp;

	loading = TRUE;

	for (ptr in managed_beforeload_handlers)
	    ptr[0].BeforeLoad();

	for (ptr in managed_datatags) {
	    comp = ptr[0];
	    if (defined("LoadEditor", comp)) {
		comp.LoadEditor(data);
	    } else if (defined("LoadData", comp)) {
		comp.LoadData(data);
	    } else if (data instanceof String || data == NULL) {
		if (defined("SetValue", comp))
		    comp.SetValue(data);
		else if (defined("SetText", comp))
		    comp.SetText(data);
		else if (defined("text", comp))
		    comp.text = data;
	    } else ShowWarning(comp, strfmt("Problem loading data that's not a string in component %s.", comp.tag));
	}

	for (ptr in managed_editors) {
	    comp = ptr[0];
	    if (!defined("datatag", comp) || comp.datatag == NULL)
		ptr[0].LoadEditor(data);
	}

	for (ptr in managed_afterload_handlers)
	    ptr[0].AfterLoad();

	loading = FALSE;
	SyncEditManager();
    }

    NextCard(Object container, int direction) {
	Object nextcard;

	if ((nextcard = PickNextCard(container, direction)) != NULL) {
	    SaveFocusOwner(container);
	    container.nextcard = nextcard;
	    SaveNeighborFlags(container);
	    if (indexOfObject(managed_editors, nextcard) >= 0)
		nextcard.SyncEditor();
	    SyncEditManager();
	    RestoreFocusOwner(container);
	}
    }

    PickCurrentCard(Object container) {
	return(PickNextCard(container, 0));
    }

    PickCurrentCardIndex(Object container) {
	return(PickNextCardIndex(container, 0));
    }

    PickNextCard(Object container, int direction) {
	int index;

	return((index = PickNextCardIndex(container, direction)) >= 0 ? container.layout[index] : NULL);
    }

    PickNextCardIndex(Object container, int direction) {
	Array panels;
	int   index = -1;

	if (defined("layoutmanager", container) && container.layoutmanager != NULL) {
	    if (container.layoutmanager.type == CARDLAYOUT) {
		panels = container.layout;
		for (ptr in panels) {
		    if (ptr[0].visible) {
			index = ptr@offset;
			break;
		    }
		}
		if (index >= 0) {
		    if (direction > 0)
			index = (index < panels@sizeof - 1) ? index+1 : -1;
		    else if (direction < 0)
			index = (index > 0) ? index-1 : -1;
		    else index = index;
		} else index = (direction == 0 && panels@sizeof > 0) ? 0 : -1;
	    }
	}
	return(index);
    }

    RestoreFocusOwner(Object container) {
	Object currentcard;

	if (defined("trackfocus", container) && container.trackfocus) {
	    if ((currentcard = PickCurrentCard(container)) != NULL) {
		if (defined(currentcard.tag, focus_owners) && focus_owners[currentcard.tag] != NULL)
		    root.components[focus_owners[currentcard.tag]].requestfocus = TRUE;
	    }
	}
    }

    SaveFocusOwner(Object container) {
	Object currentcard;
	Object focusowner;

	if (defined("trackfocus", container) && container.trackfocus) {
	    if ((currentcard = PickCurrentCard(container)) != NULL) {
		if ((focusowner = getFocusOwner()) != NULL)
		    focus_owners[currentcard.tag] = focusowner.tag;
		else focus_owners[currentcard.tag] = NULL;
	    }
	}
    }

    SaveNeighborFlags(Object container) {
	int flags;
	int index;

	if ((index = PickCurrentCardIndex(container)) >= 0) {
	    flags = 0;
	    if (index > 0)
		flags |= 0x01;
	    if (index < container.layout@sizeof - 1)
		flags |= 0x02;
	    neighbor_flags[container.tag] = flags;
	}
    }

    SetReadOnly(int state) {
	managed_readonly = state;
	for (ptr in managed_editors)
	    ptr[0].SetReadOnly(state);
    }

    SyncEditManager() {
	if (initialized && !loading)
	    root.SyncScreen();
    }

    SyncSavedState() {
	for (ptr in managed_editors)
	    ptr[0].SyncSavedState();
    }
};

final Dictionary EDITOR_TEMPLATE = {
    Dictionary edit_stack = NULL;
    Dictionary edit_buttons = NULL;
    Object     edit_manager = NULL;
    Object     edit_buffer = NULL;
    String     edit_buffer_tag = NULL;
    String     edit_buffer_session_tag = NULL;
    String     edit_buffer_status_tag = NULL;
    String     edit_deleted_tag = NULL;
    String     edit_status_label_tag = NULL;
    Object     edit_arg = NULL;
    Array      edit_tags = NULL;
    Array      edit_layout = NULL;
    Array      edit_foregrounds = NULL;
    Array      edit_foreground_tags = NULL;
    Array      edit_children = NULL;
    Array      edit_afterload_handlers = NULL;
    Array      edit_beforeload_handlers = NULL;
    Array      edit_table_tags = NULL;
    int        edit_readonly = FALSE;
    int        edit_standalone = TRUE;
    int        edit_optional_data = FALSE;
    int        edit_drop_model = 0;	// 0 means we overwrite edit components
    int        edit_need_states = FALSE;
    int        edit_count;
    int        edit_session;
    int        is_editor = TRUE;

    //
    // Every component that has a field named datatag is remembered in the
    // managed_datatags dictionary and will be a candidate for loading by
    // LoadEditor().
    //

    Dictionary managed_datatags = NULL;

    //
    // If editor_ancestor isn't NULL and defines a SyncAsEditorAncestor()
    // function then it will be called from SyncEditor().
    //

    Object editor_ancestor = NULL;

    //
    // Several variables that are used to try to eliminate unnecessary work
    // that can be generated by SyncEditor() calls. Added without too much
    // testing, but this seem to be working properly.
    //

    int activated = TRUE;
    int initialized = FALSE;
    int loading = FALSE;
    int shown = FALSE;

    //
    // A lock that we use to make sure this editor is only activated by one
    // thread. Means editors could be activated by a low level thread and
    // an explicit call without causing any problems.
    //

    final String ACTIVATELOCK = "Editor Activation Lock";

    ////////////////////////////
    //
    // Event Handlers
    //
    ////////////////////////////

    componentShown(e) {
	//
	// We use this to try to set the editor's initial focus to the most
	// appropriate component. Convenient and friendly, but not required
	// for the operation of the editor.
	//
	// NOTE - had to make a small change to the interpreter's Java code
	// that handles CardLayouts to make sure the first card really gets
	// the event.
	//

	if (!shown) {
	    shown = TRUE;
	    SetFocusToFirst();
	}
    }

    ////////////////////////////
    //
    // Editor Functions
    //
    ////////////////////////////

    ActivateEditor() {
	if (!activated) {
	    synchronized(ACTIVATELOCK) {
		if (!activated) {		// just in case
		    activated = TRUE;
		    if (!initialized)
			InitializeEditor();
		}
	    }
	}
    }

    AfterEdit(Object arg, ...) {
	Dictionary stack;
	Dictionary state;
	Dictionary tmp;
	String     edited_tag;
	String     previous;
	String     current;

	if ((stack = edit_stack) != NULL) {
	    if (stack.IsEnabled()) {
		if (arg instanceof String || arg instanceof Array) {
		    state = NULL;
		    for (ptr in (arg instanceof String) ? new Array {arg} : arg) {
			edited_tag = ptr[0];
			if (indexOfObject(edit_tags, edited_tag) >= 0) {
			    current = (argc > 2 && argv[2] instanceof String) ? argv[2] : components[edited_tag].GetValue();
			    previous = ((tmp = stack.Peek()) != NULL) ? tmp[edited_tag] : NULL;
			    if (current !== previous) {
				if (!edit_readonly) {
				    //
				    // Explicitly calling SetValue() to make sure the new
				    // value is stored in the edit component isn't always
				    // necessary, but there definitely are cases where it
				    // is required!! For example, the string returned by
				    // GetValue() could be formatted so it wouldn't match
				    // the value that's displayed by the edit component. 
				    // JTable edit components also usually need the call
				    // to make sure the contents of editor and the table
				    // cell that's being edited match.
				    //
				    components[edited_tag].SetValue(current);
				    state = GetCurrentEditStateForTag(edited_tag, current, state);
				} else components[edited_tag].SetValue(previous);
			    }
			}
		    }
		    if (state != NULL) {
			stack.Push(state);
			if (argc > 4 && argv[3] != NULL)
			    stack.SetExtra(argv[3], argv[4]);
		    }
		    SyncEditor();
		}
	    }
	}
    }

    AtSavedState() {
	Dictionary stack;

	//
	// Decided to return TRUE when there's no stack - probably not a big
	// deal it changed.
	//

	return((stack = edit_stack) != NULL ? stack.AtSavedState() : TRUE);
    }

    CancelEdit() {
	edit_stack = NULL;		// this should be first
	edit_arg = NULL;

	for (ptr in edit_layout)
	    ptr[0].CancelEdit();

	if (edit_buffer == NULL) {
	    if (edit_standalone) {
		if (edit_layout@sizeof > 0)
		    edit_layout[0].requestfocus = TRUE;
		else this.requestfocus = TRUE;
	    } else this.requestfocus = TRUE;
	} else edit_buffer.requestfocus = TRUE;

	SyncEditor();
    }

    CanLoadEditor(int confirm) {
	int result;

	if (IsModified()) {
	    if (confirm) {
		toFront(root);
		result = ShowConfirm(root, LOADEDITOR_WITH_UNSAVED_EDITS).confirmed;
	    } else result = FALSE;
	} else result = TRUE;
	return(result);
    }

    CompareEditStates(Dictionary state1, Dictionary state2) {
	int result = TRUE;

	if (state1 != state2) {
	    for (ptr in edit_tags) {
		if (defined(ptr[0], state1) && defined(ptr[0], state2)) {
		    if (state1[ptr[0]] !== state2[ptr[0]]) {
			result = FALSE;
			break;
		    }
		}
	    }
	}
	return(result);
    }

    CollectData() {
	Object comp;
	String key;
	Object value;
	Array  data;
	Array  pairs;
	int    m;
	int    n;

	//
	// The behavior, at least in terms of visited components, is supposed
	// mirror what's done in LoadEditor(), but the actual collection of
	// data should look like CollectEdits().
	//

	data = new Array[0, ...];
	for (ptr in managed_datatags) {
	    comp = ptr[0];
	    if (defined("CollectData", comp)) {
		if (comp.CollectData != NULL)
		    value = comp.CollectData();
		else value = NULL;
	    } else if (defined("SetValue", comp))		// because LoadEditor() uses it
		value = defined("GetValue", comp) ? comp.GetValue() : NULL;
	    else value = NULL;
	    if (value != NULL) {
		key = ptr[0]@nameof;
		if (value instanceof Array) {
		    pairs = new Array[2*value@sizeof];
		    for (n = 0, m = 0; n < value@sizeof; n++) {
			pairs[m++] = NULL;
			pairs[m++] = value[n];
		    }
		    value = pairs;
		} else if (value instanceof Dictionary) {
		    if (value@sizeof == 1 && defined("", value))	// magic
			value = value[""];
		    else value = unroll(value, new Array[0, ...]);
		}
		data[data@sizeof] = key;
		data[data@sizeof] = value;
	    }
	}
	return(data@sizeof > 0 ? data : NULL);
    }

    CollectEdits() {
	Dictionary stack;
	Dictionary current;
	Dictionary original;
	String     key;
	Object     value;
	Array      edits;
	Array      pairs;
	int        m;
	int        n;

	if (edit_count > 0) {
	    edits = new Array[0, ...];
	    if (edit_buffer != NULL) {
		if ((value = edit_buffer.CollectEdits()) != NULL) {
		    edits[edits@sizeof] = edit_buffer.GetDataTag();
		    edits[edits@sizeof] = value;
		}
	    } else {
		if ((stack = edit_stack) != NULL) {
		    if ((current = stack.Peek()) != NULL) {
			if ((original = stack.PeekAtBottom()) != NULL) {
			    for (ptr in edit_tags) {
				if (current[ptr[0]] !== original[ptr[0]]) {
				    key = components[ptr[0]].GetDataTag();
				    if (defined("CollectEdits", components[ptr[0]]))
					value = components[ptr[0]].CollectEdits();
				    else value = current[ptr[0]];
				    if (value instanceof Array) {
					pairs = new Array[2*value@sizeof];
					for (n = 0, m = 0; n < value@sizeof; n++) {
					    pairs[m++] = NULL;
					    pairs[m++] = value[n];
					}
					value = pairs;
				    } else if (value instanceof Dictionary) {
					if (value@sizeof == 1 && defined("", value))	// magic
					    value = value[""];
					else value = unroll(value, new Array[0, ...]);
				    }
				    edits[edits@sizeof] = key;
				    edits[edits@sizeof] = value;
				}
			    }
			}
		    }
		}
	    }
	}

	return(edits@sizeof > 0 ? edits : NULL);
    }

    DisableEditor() {
	for (ptr in edit_layout)
	    ptr[0].enabled = edit_standalone && ptr[0].is_edit_component_enabled;
    }

    EnableEditor() {
	for (ptr in edit_layout)
	    ptr[0].enabled = ptr[0].is_edit_component_enabled;
    }

    GetActiveEditKey() {
	String key = NULL;

	if (edit_buffer != NULL) {
	    if (edit_arg instanceof int && edit_arg >= 0)
		key = edit_buffer.GetEditKeyForRow(edit_arg);
	} else if (edit_standalone) {
	    if (edit_arg instanceof String)
		key = edit_arg;
	    else key = "";
	}
	return(key);
    }

    GetActiveEditRow() {
	return(edit_buffer != NULL && edit_arg instanceof int ? edit_arg : -1);
    }

    GetCurrentDeletedState() {
	int deleted = FALSE;

	if (edit_deleted_tag != NULL) {
	    if (defined(edit_deleted_tag, components))
		deleted = ToBoolean(components[edit_deleted_tag].GetValue());
	}
	return(deleted);
    }

    GetCurrentEditState() {
	Dictionary state = NewEditorState();

	//
	// Returns a state dictionary filled in using the values currently
	// stored in edit components listed in edit_tags.
	// 

	for (ptr in edit_tags)
	    state[ptr[0]] = components[ptr[0]].GetValue();
	return(state);
    }

    GetCurrentEditStateForTag(String edited_tag, String value, Dictionary state) {
	Dictionary stack;
	Dictionary current;
	Object     edited;
	String     data;

	//
	// Builds an edit state after the user changed the component named
	// edit_tag, usually by copying the state currently on top of the
	// stack, which is modified to reflect the state of the edited_tag
	// component.
	// 

	if (defined(edited_tag, components)) {
	    if ((stack = edit_stack) != NULL) {
		if ((current = stack.Peek()) != NULL) {
		    if (state == NULL)
			state = new Dictionary[current@sizeof, ...] current;
		    edited = components[edited_tag];
		    state[edited_tag] = value;
		    state.editor = this;
		    state.hash = NULL;
		    if (!defined("deleted", state))
			state.deleted = GetCurrentDeletedState();
		    //
		    // Most of the time the following tests let us skip the
		    // calculations that query every edit component. Replace
		    // the lines with
		    //
		    //     state.empty = GetCurrentEmptyState();
		    //     state.valid = GetCurrentValidState();
		    //
		    // if you don't trust our faster implementation.
		    //
		    if (!edited.IsEmpty())
			state.empty = FALSE;
		    else if (!defined("empty", state) || !state.empty)
			state.empty = GetCurrentEmptyState();
		    if (defined("IsEditorStateValid", edited))
			state.valid = edited.IsEditorStateValid();
		    else if (!edited.IsValid())
			state.valid = FALSE;
		    else if (!defined("valid", state) || !state.valid)
			state.valid = GetCurrentValidState();
		} else state = GetCurrentEditState();
	    } else state = GetCurrentEditState();
	} else state = GetCurrentEditState();

	return(state);
    }

    GetCurrentEmptyState() {
	int empty = TRUE;

	for (ptr in edit_layout) {
	    if (!ptr[0].IsEmpty()) {
		empty = FALSE;
		break;
	    }
	}
	return(empty);
    }

    GetCurrentValidState() {
	int valid = TRUE;

	for (ptr in edit_layout) {
	    if (!ptr[0].IsValid()) {
		valid = FALSE;
		break;
	    }
	}
	return(valid);
    }

    GetDataTag() {
	return(defined("datatag", this) ? this.datatag : NULL);
    }

    GetBuffer() {
	return(edit_buffer != NULL ? edit_buffer : NULL);
    }

    GetDataCount() {
	Object buffer;

	return((buffer = GetBuffer()) != NULL ? buffer.GetDataCount() : GetEditCount());
    }

    GetEditCount() {
	return(edit_count);
    }

    GetEditHashFromState(Dictionary state) {
	String hash = NULL;
	Object table;
	String sep;

	//
	// Now assumes there's a hash field defined in all dictionaries
	// that get passed to us.
	//

	if (state != NULL) {
	    if (state.hash == NULL) {
		sep = (edit_buffer != NULL) ? edit_buffer.GetFieldSeparator() : "\t";
		for (ptr in edit_tags) {
		    if (hash != NULL)
			hash += sep;
		    hash += state[ptr[0]];
		}
		state.hash = hash;
	    } else hash = state.hash;
	}
	return(hash);
    }

    GetEditStack() {
	Dictionary stack;
	Array      states;

	if (edit_stack == NULL) {
	    if ((states = GetInitialEditStates()) != NULL) {
		stack = NewEditStack(
		    GetActiveEditKey(),
		    GetActiveEditRow(),
		    this
		);
		stack.LoadStates(states);
		edit_stack = stack;
		SyncToStack(NULL, 0);
	    }
	}
	return(edit_stack);
    }

    GetInitialEditState() {
	Dictionary state = NewEditorState();

	//
	// Returns a dictionary that represents the editor's initial state
	// using the values currently stored in the edit components listed
	// in edit_tags. In many cases the answer will be exactly the same
	// as the state that's returned by GetCurrentEditState(), but this
	// gives individual edit components a chance to decide because we
	// call their GetInitialValue() function instead of GetValue(). A
	// JTable editor may be the only real exception.
	// 

	for (ptr in edit_tags)
	    state[ptr[0]] = components[ptr[0]].GetInitialValue();
	return(state);
    }

    GetInitialEditStates() {
	Dictionary state;
	String     key;
	Array      states = NULL;

	//
	// For an edit buffer the current states are the original state plus
	// any others that have already been saved.
	//

	if (edit_buffer != NULL) {
	    if ((key = GetActiveEditKey()) != NULL) {
		states = edit_buffer.GetEditStatesByKey(key);
		if (states@sizeof > 0) {
		    //
		    // If there's only one state it's the first time the row
		    // has been edited and there will be fields that need to
		    // be added and properly initialized. Otherwise it's the
		    // first time the row's been edited and all saved states
		    // should be consistent, but as a precaution we decided
		    // to check the last state.
		    // 
		    state = states[states@sizeof - 1];
		    if (!defined("valid", state) || !defined("empty", state)) {
			LoadEditComponentsFromState(state);
			state.editor = this;
			state.deleted = GetCurrentDeletedState();
			state.empty = GetCurrentEmptyState();
			state.valid = GetCurrentValidState();
		    }
		}
	    } else states = new Array {GetInitialEditState()};
	} else states = new Array {GetInitialEditState()};
	return(states);
    }

    HandleDragEnter(DropTargetEvent e, Object target) {
	//
	// Only called when a drag operation enters an edit component, so
	// trying to base the answer on the cell that was entered doesn't
	// make sense because we don't get a chance to change our answer as
	// the cusor moves around in the table. Besides, if we return FALSE
	// the YWAIT default code gets a chance to decide.
	//
	// NOTE - probably no reason why we can't use the YWAIT DragEnter()
	// that now supports JTables. We eventually will take a closer look.
	// Returning FALSE here means that's what will be used, so it's easy
	// to check, but eliminating this function will take a bit more work.
	//

	return(e.transferable instanceof Dictionary || (target instanceof JTable && e.transferable instanceof String));
    }

    HandleDrop(DropTargetEvent e, Object target) {
	Dictionary cell;
	Object     transferable;
	String     value;
	Array      columns;
	int        row;
	int        column;
	int        accepted = TRUE;

	//
	// In this case there's editor specific code that we want to run, so
	// it's really needed. By default we return TRUE, mostly to prevent
	// the default JTable drop code from running because it changes cells
	// directly rather than by using target.HandleCellChange().
	//

	if (e.transferable instanceof Dictionary) {
	    transferable = e.transferable;
	    for (ptr in edit_layout) {
		if ((value = PickValue(ptr[0].GetAppTags(), transferable)) != NULL) {
		    if (edit_drop_model != 0) {
			if (defined("drop", ptr[0])) {
			    e.transferable = value;
			    ptr[0].drop(e);
			}
		    } else ptr[0].SetValue(value);
		}
	    }
	} else if (target instanceof JTable) {
	    transferable = e.transferable;
	    if (transferable instanceof String) {
		if (target.edit) {
		    if ((cell = target.action(FIND_CELL_AT, e.location)) != NULL) {
			if ((row = cell.valuesRow) >= 0 && (column = cell.valuesColumn) >= 0) {
			    if ((columns = target.columns) != NULL) {
				if (columns[column].edit == NULL || columns[column].edit) {
				    target.action(EDIT_STOP);
				    target.HandleCellChange(row, column, transferable, target.action(GET_FIELD, row, column));
				}
			    }
			}
		    }
		}
	    }
	} else accepted = FALSE;

	return(accepted);
    }

    InitializeEditor() {
	JButton dummy;
	Regexp  re;
	String  name;
	Object  comp;
	int     n;

	//
	// Generic editor initialization that's called once right after the
	// screen is built (e.g., indirectly from InitializeScreen()). We
	// initialize edit_buttons using a dummy JButton just in case you
	// decide to omit one or more buttons (e.g., save or cancel) from
	// the editor's layout.
	//

	if (activated) {
	    StopEditor(initialized);	// recent change - argument was FALSE
	    initialized = FALSE;		// recent change
    
	    edit_tags = new Array[0, ...];
	    edit_layout = new Array[0, ...];
	    edit_table_tags = new Array[0, ...];
	    edit_need_states = FALSE;
	    edit_afterload_handlers = new Array[0, ...];
	    edit_beforeload_handlers = new Array[0, ...];
	    edit_children = new Array[0, ...];
	    managed_datatags = new Dictionary[0, ...];
    
	    dummy.visible = FALSE;
	    edit_buttons = new Dictionary[0, ...] {
		"$_cancel_button", dummy,
		"$_redo_button", dummy,
		"$_save_button", dummy,
		"$_undo_button", dummy,
	    };
    
	    re.type = TEXT_PATTERN;
	    re.pattern = tag;
    
	    for (ptr in components) {
		if ((comp = ptr[0]) != this) {
		    name = ptr[0]@nameof;
		    if (defined("editor", comp))
			comp.editor = this;
		    if (defined("datatag", comp) && comp.datatag != NULL)
			managed_datatags[comp.datatag] = comp;
		    if (defined("AfterLoad", comp))
			edit_afterload_handlers[edit_afterload_handlers@sizeof] = comp;
		    if (defined("BeforeLoad", comp))
			edit_beforeload_handlers[edit_beforeload_handlers@sizeof] = comp;
		    if (defined("SyncAsEditorChild", comp)) {
			if (comp.SyncAsEditorChild instanceof Function && comp.SyncAsEditorChild@length == 1)
			    edit_children[edit_children@sizeof] = comp;
		    }
		    if (defined("is_edit_component", comp) && comp.is_edit_component) {
			edit_tags[edit_tags@sizeof] = name;
			edit_layout[&components[name]@offset] = comp;
			if (defined("is_edit_table", comp) && comp.is_edit_table)
			    edit_table_tags[edit_table_tags@sizeof] = name;
			if (defined("Initialize", comp))
			    comp.Initialize();
		    } else if (defined("is_edit_button", comp) && comp.is_edit_button) {
			if (startsWith(name, tag + "_") && endsWith(name, "_button"))
			    edit_buttons[substi("$", re, name)] = comp;
		    } else if (defined("InitializeEditBuffer", comp))
			comp.InitializeEditBuffer();
		    else if (defined("InitializePanel", comp))
			comp.InitializePanel();
		}
	    }
    
	    edit_layout = new Array[] {unroll(edit_layout)};
    
	    if (edit_foregrounds == NULL) {
		if (defined("edit_foregrounds", edit_manager) && edit_manager.edit_foregrounds != NULL)
		    edit_foregrounds = edit_manager.edit_foregrounds;
		else if (defined("edit_foregrounds", root) && root.edit_foregrounds != NULL)
		    edit_foregrounds = root.edit_foregrounds;
		else edit_foregrounds = new Array {foreground, GetPreferredEditedTabForeground(), GetPreferredInvalidTabForeground()};
	    }

	    if (defined("edit_foreground_tags", edit_manager) && edit_manager.edit_foreground_tags != NULL) {
		if (edit_foreground_tags != NULL)
		    edit_foreground_tags = new Array {unroll(edit_foreground_tags), unroll(edit_manager.edit_foreground_tags)};
		else edit_foreground_tags = edit_manager.edit_foreground_tags;
		edit_manager.edit_foreground_tags = NULL;
	    }
    
	    if (defined("edit_foreground_tags", root) && root.edit_foreground_tags != NULL) {
		if (edit_foreground_tags != NULL)
		    edit_foreground_tags = new Array {unroll(edit_foreground_tags), unroll(root.edit_foreground_tags)};
		else edit_foreground_tags = root.edit_foreground_tags;
		root.edit_foreground_tags = NULL;
	    }
    
	    if (edit_buffer_tag != NULL) {
		if (!defined(edit_buffer_tag, components)) {
		    edit_buffer_tag = NULL;		// issue a warning??
		    edit_buffer = NULL;
		} else edit_buffer = components[edit_buffer_tag];
	    } else edit_buffer = NULL;
    
	    if (edit_table_tags@sizeof == 0) {
		edit_table_tags = NULL;
		edit_need_states = FALSE;
	    } else edit_need_states = TRUE;
    
	    StartEditor(FALSE);
	    initialized = TRUE;
	}
    }

    IsActivated() {
	return(activated);
    }

    IsBuffered() {
	return(edit_buffer != NULL);
    }

    IsEditComponentModified(Object comp) {
	Dictionary stack;
	Dictionary current;
	Dictionary initial;
	int        result = FALSE;

	if (defined("tag", comp)) {
	    if ((stack = edit_stack) != NULL) {
		if ((current = stack.Peek()) != NULL) {
		    if ((initial = stack.PeekAtBottom()) != NULL) {
			if (current != initial) {
			    if (defined(comp.tag, current) && defined(comp.tag, initial))
				result = (current[comp.tag] !== initial[comp.tag]);
			}
		    }
		}
	    }
	}
	return(result);
    }

    IsEdited() {
	Dictionary stack;

	return((stack = edit_stack) != NULL ? stack.IsEdited() : FALSE);
    }

    IsEditing() {
	Dictionary stack;

	return((stack = edit_stack) != NULL ? stack.IsEditing() : FALSE);
    }

    IsEmpty() {
	return(GetDataCount() == 0);
    }

    IsManagedEditComponent(Object comp) {
	return(comp != NULL && indexOfObject(edit_layout, comp) >= 0);
    }

    IsModified() {
	Dictionary stack;

	return((stack = edit_stack) != NULL ? stack.IsModified() : FALSE);
    }

    IsOptional() {
	return(edit_optional_data);
    }

    IsReady() {
	Dictionary stack;
	int        result;

	if (IsValid()) {
	    if (NotOptional() && IsBuffered())
		result = GetDataCount() > 0;
	    else result = TRUE;
	} else result = FALSE;

	return(result);
    }

    IsSavable() {
	Dictionary stack;

	return((stack = edit_stack) != NULL ? stack.IsSavable() : FALSE);
    }

    IsStateModified(Dictionary state) {
	Dictionary stack;
	Dictionary startstate;
	Object     comp;
	int        result = FALSE;

	//
	// Very much like CompareEditStates(), but comparing fields stored
	// in the states doesn't currently work (and probably never will)
	// for JTable edit components, so we need another mechanism that
	// didn't seem to fit well in CompareEditStates().
	//

	if ((stack = edit_stack) != NULL) {
	    if ((startstate = stack.PeekAtStartState()) != NULL) {
		if (state != startstate) {
		    for (ptr in edit_tags) {
			comp = components[ptr[0]];
			if (comp.IsEditComponentEnabled()) {
			    if (!defined("IsModified", comp)) {
				if (defined(ptr[0], state) && defined(ptr[0], startstate)) {
				    if (state[ptr[0]] !== startstate[ptr[0]]) {
					result = TRUE;
					break;
				    }
				}
			    } else {
				if (defined(ptr[0], state)) {
				    if (comp.IsModified()) {
					result = TRUE;
					break;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
	return(result);
    }

    IsValid() {
	Dictionary stack;
	int        result;

	//
	// When edits are buffered but the edit components contain changes
	// that may or may not be valid, then this function returns FALSE.
	// That means users have to cancel the edit or finish it and save
	// the changes in the object that's handling the buffering, which
	// currently must be a JTable.
	//


	if (NotBuffered()) {
	    if ((stack = edit_stack) != NULL)
		result = stack.IsValid();
	    else result = GetCurrentValidState();
	} else result = NotEditing() || NotModified();

	return(result);
    }

    LoadEditComponentsFromState(Dictionary state) {
	//
	// Trivial function that loads edit components from state. Omits all
	// checks and doesn't sync the editor or edit screen with the loaded
	// edit components, so the caller is responsible for whatever else
	// needs to be done!!
	// 

	for (ptr in edit_tags)
	    components[ptr[0]].SetValue(state[ptr[0]], TRUE);
    }

    LoadEditor(Object data) {
	String key;
	Object value;
	Object comp;

	//
	// Currently assumes data only loads individual edit components if
	// there's no edit table.
	//

	loading = TRUE;
	StopEditor(TRUE);

	for (ptr in edit_beforeload_handlers)
	    ptr[0].BeforeLoad();

	for (ptr in managed_datatags) {
	    key = ptr[0]@nameof;
	    if ((value = xmlGet(key, data)) != NULL) {
		comp = ptr[0];
		if (defined("LoadData", comp)) {
		    comp.LoadData(value);
		} else if (defined("LoadEditBuffer", comp)) {
		    comp.LoadEditBuffer(value, edit_tags);
		} else if (value instanceof String || value == NULL) {
		    if (defined("SetValue", comp))
			comp.SetValue(value);
		    else if (defined("SetText", comp))
			comp.SetText(value);
		    else if (defined("text", comp))
			comp.text = value;
		} else ShowWarning(comp, strfmt("Problem loading data that's not a string in component %s.", comp.tag));
	    }
	}

	for (ptr in edit_afterload_handlers)
	    ptr[0].AfterLoad();

	edit_session = 1;

	StartEditor(FALSE);
	loading = FALSE;
	SyncEditor();
    }

    NewEditorState() {
	//
	// Returns a growable dictionary with a few initialized fields that
	// still needs to be filled in with fields that represent the state
	// of each edit component supported by this editor.
	//

	return(new Dictionary[0, ...] {
	    String key;
	    String hash;
	    Object editor = this;
	    int    deleted = GetCurrentDeletedState();
	    int    empty = GetCurrentEmptyState();
	    int    valid = GetCurrentValidState();
	});
    }

    NotActivated() {
	return(!IsActivated());
    }

    NotBuffered() {
	return(!IsBuffered());
    }

    NotEditComponentModified(Object comp) {
	return(!IsEditComponentModified(comp));
    }

    NotEdited() {
	return(!IsEdited());
    }

    NotEditing() {
	return(!IsEditing());
    }

    NotEmpty() {
	return(!IsEmpty());
    }

    NotManagedEditComponent(Object comp) {
	return(!IsManagedEditComponent(comp));
    }

    NotModified() {
	return(!IsModified());
    }

    NotOptional() {
	return(!IsOptional());
    }

    NotReady() {
	return(!IsReady());
    }

    NotSavable() {
	return(!IsSavable());
    }

    NotValid() {
	return(!IsValid());
    }

    PeekAtField(String name) {
	Dictionary stack;
	Dictionary state;
	String     value = NULL;

	if ((stack = edit_stack) != NULL) {
	    if ((state = stack.Peek()) != NULL) {
		if (defined(name, state))
		    value = state[name];
	    }
	}
	return(value);
    }

    PickForegroundByStatus(int valid, int modified) {
	Object color;

	if (edit_foregrounds@sizeof > 1) {
	    if (valid)
		color = edit_foregrounds[modified ? 1 : 0];
	    else color = edit_foregrounds[edit_foregrounds@sizeof > 2 ? 2 : 0];
	} else color = foreground;

	return(color);
    }

    PickInvalidForeground() {
	Dictionary stack;
	Color      color = NULL;

	if ((stack = edit_stack) != NULL) {
	    if (stack.IsEditing())
		color = GetPreferredInvalidComponentForeground();
	}
	return(color);
    }

    PickValue(Array keys, Dictionary values) {
	String value = NULL;

	for (ptr in keys) {
	    if (defined(ptr[0], values)) {
		if ((value = values[ptr[0]]) != NULL)
		    break;
	    }
	}
	return(value);
    }

    RedoEdit(int modifiers) {
	Dictionary stack;
	Array      states;

	if ((stack = edit_stack) != NULL) {
	    if (stack.IsEnabled()) {
		states = stack.Redo(modifiers);
		SyncToStack(states, 1);
		SyncFocusToStack(1);
	    }
	}
    }

    RestoreEditComponentFromStates(Array states, int direction) {
	if (states@sizeof > 0) {
	    for (ptr in edit_layout) {
		if (defined("RestoreStates", ptr[0]))
		    ptr[0].RestoreStates(states, direction);
	    }
	}
    }

    SaveEdit() {
	Dictionary stack;
	Dictionary state;

	if ((stack = edit_stack) != NULL) {
	    if (stack.IsEnabled()) {
		if (edit_buffer != NULL) {
		    if ((state = stack.Peek()) != NULL) {
			edit_buffer.SaveState(state);
			edit_session++;
		    }
		}
		CancelEdit();
	    }
	}
    }

    SetEditManager(Object manager) {
	if (edit_manager == NULL) {
	    edit_manager = manager;
	    edit_readonly = edit_manager.managed_readonly;
	}
    }

    SetEditorAncestor(Object comp) {
	if (defined("SyncAsEditorAncestor", comp) && comp.SyncAsEditorAncestor@length == 1)
	    editor_ancestor = comp;
    }

    SetFocusByTag(String focus_tag) {
	int index;

	if ((index = indexOfObject(edit_tags, focus_tag, FALSE)) >= 0)
	    components[edit_tags[index]].requestfocus = TRUE;
	else SetFocusToFirst();
    }

    SetFocusToFirst() {
	Object comp;

	if (edit_stack != NULL) {
	    if (edit_layout@sizeof > 0 && edit_layout[0].enabled) {
		comp = edit_layout[0];
		if (defined("SetFocusToFirst", comp))
		    comp.SetFocusToFirst();
		else comp.requestfocus = TRUE;
	    } else if (edit_buffer != NULL)
		edit_buffer.requestfocus = TRUE;
	} else if (edit_buffer != NULL)
	    edit_buffer.requestfocus = TRUE;
    }

    SetReadOnly(int state) {
	//
	// Added quickly, so at this point I'm not sure this works properly
	// once edits have been made. Suspect it's OK, but that still needs
	// a close look.
	//

	edit_readonly = state;
    }

    SetValueByAppTag(Dictionary values) {
	String value;

	for (ptr in edit_layout) {
	    if ((value = PickValue(ptr[0].GetAppTags(), values)) != NULL)
		ptr[0].SetValue(value);
	}
    }

    StartEdit(Object arg) {
	//
	// Should this function check to see if the component already is
	// the current editor?
	//

	edit_arg = arg;		// save the argument in the editor

	for (ptr in edit_layout) {
	    if (defined("StartEdit", ptr[0]))
		ptr[0].StartEdit(edit_arg);
	}

	StartEditor(TRUE);
    }

    StartEditor(int force) {
	if (force || edit_standalone) {
	    EnableEditor();
	    GetEditStack();
	}
    }

    StopEditor(int cancel) {
	if (cancel)
	    CancelEdit();
	DisableEditor();
    }

    SyncEditComponents() {
	Dictionary stack;

	if ((stack = edit_stack) != NULL) {
	    EnableEditor();
	    if (edit_buttons != NULL) {
		edit_buttons.$_undo_button.enabled = stack.CanUndo();
		edit_buttons.$_redo_button.enabled = stack.CanRedo();
		edit_buttons.$_save_button.enabled = stack.IsSavable();
		edit_buttons.$_cancel_button.enabled = stack.IsEditing();
	    }
	} else {
	    DisableEditor();
	    if (edit_buttons != NULL) {
		edit_buttons.$_undo_button.enabled = FALSE;
		edit_buttons.$_redo_button.enabled = FALSE;
		edit_buttons.$_save_button.enabled = FALSE;
		edit_buttons.$_cancel_button.enabled = FALSE;
	    }
	}
	edit_manager.SyncEditManager();
    }

    SyncEditor() {
	Dictionary stack;

	if (initialized && !loading) {
	    if (edit_buffer != NULL)
		edit_count = edit_buffer.GetEditCount();
	    else if ((stack = edit_stack) != NULL)
		edit_count = stack.IsSavable() ? 1 : 0;
	    else edit_count = 0;

	    for (ptr in edit_layout)
		ptr[0].SyncState();

	    SyncEditorForeground();
	    SyncEditorStatus();
	    SyncEditComponents();

	    for (ptr in edit_children)
		ptr[0].SyncAsEditorChild(this);

	    if (editor_ancestor != NULL)
		editor_ancestor.SyncAsEditorAncestor(this);
	}
    }

    SyncEditorForeground() {
	Dictionary stack;
	Color      color;

	// Setting the editor's foreground color as a way to automatically
	// change the color of things, like a tab's title, works best when
	// the default behavior of components managed by the editor is not
	// to inherit their foreground color from the editor. That wasn't
	// the case in some of the YWAIT constructors, but they've now all
	// been changed (in this version) so they always explicitly choose
	// their own foreground color. The change obviously means you need
	// to set the foreground of a component to NULL if you want it to
	// inherit the editor's foreground.
	//

	if (edit_foregrounds@sizeof > 1) {
	    color = PickForegroundByStatus(IsValid(), edit_count > 0);
	    foreground = color;
	    if (edit_foreground_tags != NULL) {
		for (ptr in edit_foreground_tags) {
		    if (defined(ptr[0], root.components))
			root.components[ptr[0]].foreground = color;
		}
	    }
	    if (defined("AfterSyncEditorForeground", this))
		AfterSyncEditorForeground(color);
	}
    }

    SyncEditorStatus() {
	String status = NULL;
	Object comp;

	if (edit_status_label_tag != NULL) {
	    if (components[edit_status_label_tag].showstatus) {
		if (edit_count > 0) {
		    if (edit_buffer != NULL) {
			if (edit_count > 1)
			    status = toString(edit_count) + " edits";
		 	else status = toString(edit_count) + " edit";
		    } else status = "edited";
		} else status = NULL;
		components[edit_status_label_tag].text = status;
	    }
	}
    }

    SyncFocusToStack(int direction) {
	Dictionary stack;
	Dictionary current;
	Dictionary previous;
	Object     comp;
	String     focus_tag = NULL;

	if ((stack = edit_stack) != NULL) {
	    if ((current = stack.PeekAt(0)) != NULL) {
		if ((previous = stack.PeekAt(direction)) != NULL) {
		    for (ptr in edit_tags) {
			if (current[ptr[0]] !== previous[ptr[0]]) {
			    focus_tag = ptr[0];
			    break;
			}
		    }
		} else focus_tag = edit_tags[0];
	    }
	    if (defined(focus_tag, components)) {
		comp = components[focus_tag];
		if (comp.is_edit_component_enabled) {
		    if (defined("SyncFocus", comp))
			comp.SyncFocus();
		    else comp.requestfocus = TRUE;
		}
	    }
	}
    }

    SyncSavedState() {
	Dictionary stack;

	if ((stack = edit_stack) != NULL)
	    stack.SyncSavedState();
    }

    SyncToStack(Array states, int direction) {
	Dictionary stack;
	Dictionary state;

	if ((stack = edit_stack) != NULL) {
	    if ((state = stack.Peek()) != NULL) {
		if (state.editor == this) {
		    stack.SetEnabled(FALSE);
		    if (states@sizeof > 0)
			RestoreEditComponentFromStates(states, direction);
		    else LoadEditComponentsFromState(state);
		    stack.SetEnabled(TRUE);
		    SyncEditor();
		}
	    }
	}
    }

    UndoEdit(int modifiers) {
	Dictionary stack;
	Array      states;

	if ((stack = edit_stack) != NULL) {
	    if (stack.IsEnabled()) {
		states = stack.Undo(modifiers);
		SyncToStack(states, -1);
		SyncFocusToStack(-1);
	    }
	}
    }
};

final Dictionary JTABLE_EDITBUFFER_TEMPLATE = {
    //
    // The string assigned to datatag is used to identify the data that's
    // supposed to be loaded in the table and it's also used to mark data
    // that's sent back to the server (e.g., as an XML tag). The default
    // value assigned to datatag by InitializeEditBuffer() is the JTable's
    // tag (minus any leading $_).
    //

    String datatag = NULL;

    //
    // Sometimes columns in the table contain newlines that are encoded as
    // an alternate character (e.g., '\r') in data received from or returned
    // to the server. Individual tables that set newlinealias to a positive
    // value will automatically replace that character with '\n' in the data
    // that's loaded into the table. In addition newlines in any of the rows
    // are translated to newlinealias before they're sent back to the server.
    //
    // NOTE - most non-whitespace control characters shouldn't be assigned
    // to newlinealias because they may cause problems when XML is used to
    // load data ('\r' and '\t' are OK but others aren't).
    // 

    int newlinealias = 0;

    //
    // The up and down keyboard arrows change the selected row in the table,
    // and that change can sometimes automatically load the selected row in
    // the editor. When editor_loading_model is negative rows will only load
    // when the user clicks the mouse on a row in the table. Otherwise the
    // value is used to initialize the state of a checkbox menu item in the
    // table's popup menu that syncs editor_loading_model to its state.
    //

    int editor_loading_model = -1;

    //
    // Right now the tags assigned to columns are assumed to match the tag
    // assigned to the "editor component" responsible for that column (if
    // there is one). Tag names assigned to hidden table columns that are
    // associated with visible columns must end in the suffix "_value", so
    // the name can be easily derived from the tag assigned to the primary
    // column (or the editor component). It's an obscure feature that isn't
    // used (or needed) much!!
    //

    Dictionary tags;
    Dictionary datatags;
    Dictionary apptags;
    Array      activecolumns;
    Array      activetags;
    Color      activeforeground = NULL;
    int        activemask = 0;
    Array      vieworder;

    //
    // If there's a boolean column that's supposed to be checked to indicate
    // the user has clicked on the row assign its tag to visitedtag.
    //

    String visitedtag;

    //
    // Columns that have their tags listed in localtags are omitted from the
    // data that's sent back to the server when edits are collected by the
    // default implementation of CollectEdits().
    //

    Array localtags;

    //
    // An optional list of tag names assigned to columns or edit components
    // that can be used to build a key that uniquely identifies a record in
    // the table. If there's more than one tag in the list the inputfilter
    // string (or \t) is used as the separator. When the list is empty the
    // record's row is usually used as the key.
    //

    Array keytags = NULL;

    //
    // The table_data dictionary is used to keep track of information about
    // records in the table.
    //

    Dictionary table_data = NULL;
    int        next_row = 0;
    int        data_count = 0;
    int        edit_count = 0;

    //
    // These are the required "edit buffer" specific variables.
    //

    Object editor = NULL;
    int    is_edit_buffer = TRUE;

    //
    // The original_columns field is a kludge that makes sure we have a copy
    // of the columns used to create the JTable so any extra fields added to
    // the JTableColumns don't disappear and can be used later on. It has to
    // be initialized before the JTable is created, so the code that handles
    // the assignment can't happen in InitializeEditBuffer(), as you might
    // expect. Instead the official JTable constructors have been modified
    // to look for a NULL original_columns and if found they assign columns
    // to it, thus preserving a snapshot of the columns array.
    //
    // NOTE - the real solution would turn the JTableColumns defined in the
    // columns array into "active components" that stick around and can be
    // queried or used to manipulate the table's JTableColumns.
    //

    Array original_columns = NULL;
    int   column_count = 0;
    int   loadedflags = 0;

    //
    // Table columns that are supposed to behave like radio buttons should
    // should define a radiobutton field that's TRUE. InitializeEditBuffer()
    // looks through the saved copy of the table's columns array looking for
    // the radiobutton field and builds the radiobuttontags array.
    //

    Array radiobuttontags = NULL;

    ////////////////////////////
    //
    // Event Handlers
    //
    ////////////////////////////

    Function CancelMousePressed = TableCancelMousePressed;
    Function mouseDragged = TableMouseDragged;
    Function mouseExited = TableMouseExited;
    Function mouseMoved = TableMouseMoved;
    Function mousePressed = TableMousePressed;
    Function mouseReleased = TableMouseReleased;
    Function GetFieldsByTag = TableGetFieldsByAppTag;

    invocationSelection(e) {
	Object column;

	if ((e.modifiers & BUTTON1_MASK) != 0) {
	    if (IsLoaded()) {
		if (editor.CanLoadEditor(TRUE)) {
		    invokeLater(&editor.CancelEdit);
		    if (defined(visitedtag, tags))
			action(SET_FIELD, e.valuesRow, tags[visitedtag], 1);
		    invokeLater(&editor.StartEdit, e.valuesRow);
		    if ((e.modifiers & SHIFT_MASK) != 0) {
			column = columns[e.valuesColumn];
			if (defined("tag", column))
			    invokeLater(&editor.SetFocusByTag, column.tag);
			else invokeLater(&editor.SetFocusToFirst);
		    }
		}
	    }
	}
    }

    keyReleased(e) {
	Array selections;
	int   row;

	if (editor_loading_model > 0) {
	    if (e.keycode == KeyCode.VK_DOWN || e.keycode == KeyCode.VK_UP) {
		selections = action(GET_ROW_SELECTION);
		if (selections@sizeof > 0) {
		    row = selections[0].valuesRow;
		    if (row != editor.GetActiveEditRow()) {
			if (editor.CanLoadEditor(TRUE)) {
			    invokeLater(&editor.CancelEdit);
			    invokeLater(&editor.StartEdit, row);
			}
		    }
		}
	    }
	}
    }

    ////////////////////////////
    //
    // Edit Buffer Functions
    //
    ////////////////////////////

    AddByKey(String key) {
	Dictionary data;
	Dictionary state;
	String     status;
	String     name;
	String     value;
	Object     comp;
	Array      columns[0, ...];
	Array      states;

	//
	// Essentially assumes only calls come from SaveState(), so there's
	// no need to make sure table_data[key] exists and isn't NULL.
	//

	data = table_data[key];
	status = data.status;
	states = data.states;
	state = states[states@sizeof - 1];
	columns = new Array[tags@sizeof];		// assumes a tag for each column
	for (ptr in columns)
	    ptr[0] = "";
	for (ptr in state) {
	    name = ptr[0]@nameof;
	    if (defined(name, tags)) {
		value = ptr[0];
		if (defined(name, root.components)) {
		    comp = root.components[name];
		    if (defined("MapValueToDisplayed", comp)) {
			if (defined(name, tags)) {
			    columns[tags[name]] = comp.MapValueToDisplayed(value);
			    name += "_value";
			}
		    }
		    if (defined(name, tags))
			columns[tags[name]] = value;
		}
	    }
	}
	if (defined("edit_buffer_status_tag", editor) && defined(editor.edit_buffer_status_tag, tags))
	    columns[tags[editor.edit_buffer_status_tag]] = status;
	if (defined("edit_buffer_session_tag", editor) && defined(editor.edit_buffer_session_tag, tags))
	    columns[tags[editor.edit_buffer_session_tag]] = toString(editor.edit_session);
	action(APPEND_ROWS, columns, state.row, FALSE);
	SyncTableView();
    }

    ClearEditBuffer() {
	LoadEditBuffer(NULL, NULL);
    }

    CollectData() {
	String data = NULL;
	String line;
	String sep = "";
	Array  states;

	for (ptr in table_data) {
	    if (ptr[0] != NULL) {
		if (!ptr[0].ignore) {
		    states = ptr[0].states;
		    if ((line = CollectDataFromState(states[states@sizeof - 1])) != NULL) {
			data += sep + line;
			sep = "\n";
		    }
		}
	    }
	}
	return(data);
    }

    CollectDataFromState(Dictionary state) {
	String data = NULL;
	String name;
	String value;
	String sep;

	//
	// We loop using tags so the order of fields matches what was
	// originally sent by the server.
	//

	sep = GetFieldSeparator();
	for (ptr in tags) {
	    name = ptr[0]@nameof;
	    if (!defined(name, state)) {
		if (localtags == NULL || indexOfObject(localtags, name) == -1)
		    value = action(GET_FIELD, state.row, ptr[0]);
		else value = NULL;
	    } else value = state[name];
	    if (value != NULL) {
		if (data != NULL)
		    data += sep;
		data += value;
	    }
	}
	if (data != NULL) {
	    if (newlinealias)
		data = replace(data, '\n', newlinealias);
	}
	return(data);
    }

    CollectEdits() {
	String edits = NULL;
	String line;
	String sep = "";
	Array  states;

	for (ptr in table_data) {
	    if (ptr[0] != NULL) {
		if (!ptr[0].ignore) {
		    if (IsEdited(ptr[0])) {
			states = ptr[0].states;
			if ((line = CollectDataFromState(states[states@sizeof - 1])) != NULL) {
			    edits += sep + line;
			    sep = "\n";
			}
		    }
		}
	    }
	}
	return(edits);
    }

    GetDataCount() {
	int count;

	//
	// Right now the counting that's done when data_count is negative
	// should be unnecessary, so if it's ever used something else must
	// be broken. Should we issue a warning - just to be safe??
	//

	if ((count = data_count) < 0) {
	    count = 0;
	    for (ptr in table_data) {
		if (ptr[0] != NULL) {
		    if (!ptr[0].ignore)
			count++;
		}
	    }
	    data_count = count;
	}
	return(data_count);
    }

    GetDataTag() {
	return(datatag);
    }

    GetEditCount() {
	int count;

	//
	// Right now the counting that's done when edit_count is negative
	// should be unnecessary, so if it's ever used something else must
	// be broken. Should we issue a warning - just to be safe??
	//

	if ((count = edit_count) < 0) {
	    count = 0;
	    for (ptr in table_data) {
		if (ptr[0] != NULL) {
		    if (!ptr[0].ignore) {
			if (IsEdited(ptr[0]))
			    count++;
		    }
		}
	    }
	    edit_count = count;
	}
	return(edit_count);
    }

    GetEditKeyForRow(int row) {
	String key;

	return((key = GetKeyForRow(row)) != NULL ? key : toString(row));
    }

    GetEditKeyFromState(Dictionary state) {
	String key = NULL;
	String value;
	String sep;

	//
	// Now assumes there's a key field defined in all dictionaries
	// that get passed to us. Initially done so we could eliminate
	// the defined() check that would otherwise be required, which
	// gives a small speed boost to the code in LoadEditBuffer()
	// that's used to build the table_data dictionary.
	//
	// NOTE - calculation of value when an entry in keytags[]
	// isn't in state goes directly to the table entry. Code behaves
	// properly even if state.row is negative, which is the case for
	// records that haven't been added to the table yet.
	//

	if (state != NULL) {
	    if (state.key == NULL) {
		if (keytags@sizeof > 0) {
		    sep = GetFieldSeparator();
		    for (ptr in keytags) {
			if (defined(ptr[0], state))
			    value = state[ptr[0]];
			else value = action(GET_FIELD, state.row, tags[ptr[0]]);
			if (key)
			    key += sep + value;
			else key = value;
		    }
		} else key = (state.row >= 0) ? toString(state.row) : NULL;
		state.key = key;
	    } else key = state.key;
	}
	return(key);
    }

    GetEditStatesByKey(String key) {
	Dictionary data;
	Array      states = NULL;

	//
	// Returns a copy of the edit states associated with key or NULL
	// if there's no entry for key in table_data. The old version did
	// much more, making a copy of each individual state using
	//
	//     states[states@sizeof] = new Dictionary[] ptr[0];
	//
	// but we now need to make sure that fields added when the stack
	// is initialized end up in the states saved in table_data.
	//

	if (defined(key, table_data)) {
	    if ((data = table_data[key]) != NULL)
		states = new Array[0, ...] data.states;		// growable probably unnecessary
	}
	return(states);
    }

    GetFieldSeparator() {
	return(inputfilter instanceof String ? inputfilter : "\t");
    }

    GetKeyForRow(int row) {
	String key = NULL;
	String sep;

	if (keytags@sizeof > 0) {
	    sep = GetFieldSeparator();
	    for (ptr in keytags) {
		if (key != NULL)
		    key += sep;
		key += action(GET_FIELD, row, tags[ptr[0]]);
	    }
	}
	return(key);
    }

    InitializeEditBuffer() {
	TableInitializer(this);
	BuildTableTags(this);
	if (defined("SyncToolTipText", this))
	    SyncToolTipText();

	column_count = columns@sizeof;
	table_data = new Dictionary[0, ...];
	next_row = 0;
	data_count = 0;
	edit_count = 0;

	if (datatag == NULL)
	    datatag = startsWith(tag, "$_") ? tag + 2 : tag;

	if (editor_loading_model >= 0) {
	    popup = new JPopupMenu {
		Array items = {
		    new JCheckBoxMenuItem {
			String text = "Enable Keyboard Loading";
			int    state = editor_loading_model;

			itemStateChanged(e) {
			    root.editor_loading_model = state;
			}
		    }
		};
	    };
	} else keyReleased = NULL;		// overkill??

	radiobuttontags = new Array[0, ...];
	datatags = new Dictionary[0, ...];
	apptags = new Dictionary[0, ...];
	for (ptr in original_columns) {
	    if (defined("radiobutton", ptr[0]) && ptr[0].radiobutton) {
		if (ptr[0].type == BOOLEAN_TYPE)
		    radiobuttontags[radiobuttontags@sizeof] = ptr[0].tag;
	    }
	    if (defined("datatag", ptr[0]) && ptr[0].datatag instanceof String)
		datatags[ptr[0].datatag] = ptr@offset;
	    if (defined("apptag", ptr[0]) && ptr[0].apptag instanceof String)
		apptags[ptr[0].apptag] = ptr[0].tag;
	}
    }

    IsAdded(String key) {
	return(defined(key, table_data) ? table_data[key].status === STATUS_ADDED : FALSE);
    }

    IsEdited(Dictionary data) {
	//
	// This is only for table functions.
	//
	return(data.status === STATUS_EDITED || data.status === STATUS_ADDED);
    }

    IsLoaded() {
	return(table_data@sizeof > 0);
    }

    LoadEditBuffer(Object data, Array edit_tags) {
	String value;
	String sep;
	Array  fields;

	//
	// The XML support is new and probably not well tested, however it
	// was borrowed from the JTable edit component and that version was
	// extensively tested.
	// 

	loadedflags = 0x00;

	if (data != NULL) {
	    if (!(data instanceof String)) {
		sep = inputfilter;
		data = xmlToYoix(yoixToXML(data), 0);	// force array model
		if (data instanceof Array) {
		    for (ptr in data by 2) {
			if (ptr[0] === "row") {
			    loadedflags |= 0x01;
			    if (ptr[1] instanceof String || ptr[1] instanceof Array) {
				if (value != NULL)
				    value += "\n";
				if (ptr[1] instanceof Array) {
				    fields = new Array[column_count];
				    for (ptr in ptr[1] by 2) {
					if (defined(ptr[0], datatags)) {
					    fields[datatags[ptr[0]]] = ptr[1];
					    loadedflags |= 0x02;
					}
				    }
				    value += strjoin(fields, inputfilter, TRUE);
				} else value += ptr[1];
			    }
			}
		    }
		    LoadTable(value, edit_tags);
		}
	    } else LoadTable(data, edit_tags);
	} else LoadTable(data, edit_tags);
    }

    LoadTable(Object data, Array edit_tags) {
	Dictionary dict;
	Dictionary state;
	Dictionary column_numbers;
	Array      records;
	int        statesize;
	int        rows;
	int        row;

	if ((records = GetLoadableTableRecords(data, GetFieldSeparator(), newlinealias)) != NULL)
	    values = records;
	else text = NULL;

	edit_count = 0;
	data_count = 0;
	next_row = 0;

	if ((rows = this.rows) > 0) {
	    column_numbers = new Dictionary[0, ...];
	    for (ptr in edit_tags)
		column_numbers[ptr[0]] = tags[ptr[0]];

	    statesize = column_numbers@sizeof + 3;
	    dict = new Dictionary[2*rows, ...];

	    for (row = 0; row < rows; row++) {
		state = new Dictionary[statesize, ...] {
		    String key;
		    String hash;
		    int    row = row;
		};
		for (ptr in column_numbers)
		    state[ptr[0]@nameof] = records[row][ptr[0]];
		dict[GetEditKeyFromState(state)] = new Dictionary {
		    String status = STATUS_UNEDITED;
		    Array  states = new Array {state};
		    int    row = row;
		    int    ignore = FALSE;
		};
	    }

	    data_count = row;
	    next_row = row;
	    table_data = new Dictionary[next_row, ...] dict;
	} else table_data = new Dictionary[0, ...];

	SyncEditBuffer(NULL);
    }

    PickDisplayStatus(Dictionary data) {
	return(data ? data.status : NULL);
    }

    SaveState(Dictionary state, ...) {
	Dictionary data;
	String     key;
	String     status;
	Array      states;
	int        skipsync = (argc > 2) ? argv[2] : FALSE;

	//
	// Now works hard to make sure the values assigned to data_count and
	// edit_count are up to date.
	//

	if (state != NULL) {
	    state = new Dictionary[0, ...] state;		// make a copy - just in case
	    key = GetEditKeyFromState(state);
	    if (defined(key, table_data) && table_data[key] != NULL) {
		data = table_data[key];
		states = data.states;
		data.states = new Array {unroll(states), state};
		if (data.status === STATUS_ADDED) {
		    if (data.ignore != state.deleted) {
			data.ignore = !data.ignore;
			if (data.ignore) {
			    data_count--;
			    edit_count--;
			} else {
			    data_count++;
			    edit_count++;
			}
		    }
		} else {
		    status = (editor.GetEditHashFromState(state) !== editor.GetEditHashFromState(states[0])) ? STATUS_EDITED : STATUS_UNEDITED;
		    if (data.status !== status) {
			data.status = status;
			edit_count += (status === STATUS_EDITED) ? 1 : -1;
		    }
		}
		UpdateByKey(key);
	    } else {
		state.row = next_row++;
		key = GetEditKeyFromState(state);
		table_data[key] = new Dictionary {
		    String status = STATUS_ADDED;
		    Array  states = new Array {state};
		    int    row = state.row;
		    int    ignore = state.deleted;
		};
		if (!table_data[key].ignore) {
		    data_count++;
		    edit_count++;
		}
		AddByKey(key);
	    }
	    if (!skipsync)
		SyncEditBuffer(state);
	}
    }

    SyncEditBuffer(Dictionary state) {
	SyncRadioButtons(state);
	SyncTableView();
	editor.SyncEditor();
    }

    SyncRadioButtons(Dictionary state) {
	Dictionary current;
	Dictionary newstate;
	Array      states;
	String     name;

	//
	// We assume, for now anyway, that when state is NULL there's nothing
	// to do (i.e., data loaded from the server is consistent). There's
	// also nothing to do when a tag listed in radiobuttontags isn't set
	// in state (assuming there's no requirement that exactly one entry
	// in the table's column has to be set).
	//

	if (state != NULL) {
	    if (radiobuttontags@sizeof > 0) {
		if (table_data@sizeof > 0) {
		    for (ptr in radiobuttontags) {
			if ((name = ptr[0]) != NULL) {
			    if (ToBoolean(state[name])) {
				for (ptr in table_data) {
				    if (ptr[0].row != state.row) {
					states = ptr[0].states;
					current = states[states@sizeof - 1];
					if (ToBoolean(current[name])) {
					    newstate = new Dictionary[] current;
					    newstate[name] = "0";
					    newstate.hash = NULL;
					    SaveState(newstate, TRUE);
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

    TouchState(Dictionary state) {
	if (state != NULL) {
	    if (defined("edit_buffer_session_tag", editor) && defined(editor.edit_buffer_session_tag, tags))
		action(SET_FIELD, state.row, tags[editor.edit_buffer_session_tag], editor.edit_session);
	    SyncTableView();
	}
    }

    UpdateByKey(String key) {
	Dictionary data;
	Dictionary state;
	String     status;
	String     name;
	String     value;
	Object     comp;
	Array      states;

	//
	// Essentially assumes only calls come from SaveState(), so there's
	// no need to make sure table_data[key] exists and isn't NULL.
	//

	data = table_data[key];
	status = data.status;
	states = data.states;
	state = states[states@sizeof - 1];
	for (ptr in state) {
	    name = ptr[0]@nameof;
	    if (defined(name, tags)) {
		value = ptr[0];
		if (defined(name, root.components)) {
		    comp = root.components[name];
		    if (defined("MapValueToDisplayed", comp)) {
			if (defined(name, tags)) {
			    action(SET_FIELD, state.row, tags[name], comp.MapValueToDisplayed(value));
			    name += "_value";
			}
		    }
		    if (defined(name, tags))
			action(SET_FIELD, state.row, tags[name], value);
		}
	    }
	}
	if (defined("edit_buffer_status_tag", editor) && defined(editor.edit_buffer_status_tag, tags))
	    action(SET_FIELD, state.row, tags[editor.edit_buffer_status_tag], PickDisplayStatus(data));
	if (defined("edit_buffer_session_tag", editor) && defined(editor.edit_buffer_session_tag, tags))
	    action(SET_FIELD, state.row, tags[editor.edit_buffer_session_tag], editor.edit_session);
	SyncTableView();
    }
};

